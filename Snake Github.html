<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <title>Snake Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Variable de ancho máximo para sincronizar Splash y juego */
        :root {
            --game-max-width: 520px;
        }

        @media (hover: hover) and (pointer: fine) {
            :root {
                --game-max-width: min(75vmin, 700px);
            }
        }

        /* Estilos base del cuerpo y contenedor del juego */
        html {
            height: 100%;
            overflow: hidden; 
        }
        body {
            height: 100%;
            font-family: 'Press Start 2P', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;   
            background-color: #111827; 
            color: #f5f5f5; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden; 
            touch-action: none;
        }

        /* Color violeta para textos en negrita */
        strong {
            color: #8C64AF;
        }

        .hidden {
            display: none !important;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111827;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #splash-content {
            width: 100%;
            max-width: var(--game-max-width);
            height: 100%;
            display: flex;
            background-color: #02010a;
            background-image: url(https://i.imgur.com/rYyiiMo.png);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-radius: 12px;
            box-sizing: border-box;
        }

        #splash-top-image {
            width: 95%;
            max-width: var(--game-max-width); /* Límite para PC, un poco más grande que el juego */
            height: auto;
            object-fit: contain;
            box-sizing: border-box;
        }

        #splash-start-button {
            cursor: pointer;
            width: auto;
            height: auto;
            max-width: min(55vw, 150px); /* Responsivo pero con límite en PC */
            object-fit: contain;
            z-index: 2001;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        #splash-start-button.splash-button-pressed,
        #splash-info-button.splash-button-pressed,
        #splash-settings-button.splash-button-pressed {
            transform: scale(0.90) translateY(2px);
            filter: brightness(0.7);
        }

        #splash-button-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 25px;
            padding-top: 10px;
        }

        #splash-info-button,
        #splash-settings-button {
            cursor: pointer;
            width: auto;
            height: auto;
            max-width: min(20vw, 70px);
            object-fit: contain;
            z-index: 2001;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .get-lives-button {
            cursor: pointer;
            width: auto;
            height: auto;
            max-width: min(30vw, 110px);
            object-fit: contain;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        #splash-bottom-image {
            width: 100%;
            max-width: var(--game-max-width); /* Límite para PC, un poco más grande que el juego */
            height: auto;
            max-height: calc(25vh + 60px);
            object-fit: contain;
            box-sizing: border-box;
            padding-top: 40px;
            padding-bottom: 40px;
        }


        .game-container {
            text-align: center;
            background-color: #1F2937;
            padding-top: 10px;
            padding-left: 10px;
            padding-right: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            width: 100%;
            max-width: var(--game-max-width);
            box-sizing: border-box;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #play-area { position: relative; }

        #top-info-bar {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
            width: 100%;
            margin: 0 auto 4px auto;
            position: relative;
            z-index: 10;
            padding: 4px;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
        }
        #top-info-bar::before {
            content: '';
            position: absolute;
            width: calc(100%);
            height: calc(100%);
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #top-info-bar::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 90%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }

        #selector-info-bar {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
            width: 100%;
            margin: 0 auto 4px auto;
            position: relative;
            z-index: 10;
            padding: 4px;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
        }
        #selector-info-bar::before {
            content: '';
            position: absolute;
            width: calc(100%);
            height: calc(100%);
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #selector-info-bar::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 90%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }

        #top-info-bar .info-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            min-width: 80px;
            min-height: 48px;
            box-sizing: border-box;
            width: 100%;
        }
        #top-info-bar .value-box {
            background-color: #422E58;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            width: 100%;
            text-align: center;
        }
        #top-info-bar .info-icon-wrapper {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translate(15%, -50%);
            width: 40px;
            height: 40px;
        }
        #top-info-bar .info-icon-wrapper img {
            width: 100%;
            height: 100%;
            display: block;
        }
        #selector-info-bar .info-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            min-width: 80px;
            min-height: 48px;
            box-sizing: border-box;
            width: 100%;
        }
        #selector-info-bar .value-box {
            background-color: #422E58;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            width: 100%;
            text-align: center;
        }
        #selector-info-bar .info-icon-wrapper {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translate(15%, -50%);
            width: 40px;
            height: 40px;
        }
        #selector-info-bar .info-icon-wrapper img {
            width: 100%;
            height: 100%;
            display: block;
        }
        #selector-info-bar .life-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-45%, -50%);
            font-size: 0.9em;
            color: #f5f5f5;
        }
        #top-info-bar .info-label {
            display: none;
        }
        #top-info-bar .info-value {
            font-size: 0.85em;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            line-height: 1.3;
        }
        #points-info-group .info-value {
            font-size: 0.75em;
        }
        #target-score-divider {
            margin: 0 2px;
        }
        #selector-info-bar .info-label {
            font-size: 0.65em;
            color: #a0aec0;
            margin-bottom: 4px;
            display: block;
            line-height: 1.1;
            word-break: break-word;
            display: none;
        }
        #selector-info-bar .info-value {
            font-size: 0.85em;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            line-height: 1.3;
        }

        #top-info-bar.selector-mode .info-group {
            background-color: transparent;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        #top-info-bar.selector-mode #coins-info-group {
            background-image: url('https://i.imgur.com/lQ4ltzt.png');
            position: relative;
        }
        #top-info-bar.selector-mode #points-info-group {
            background-image: url('https://i.imgur.com/vPzvx4U.png');
        }
        #top-info-bar.selector-mode #time-info-group {
            background-image: url('https://i.imgur.com/P16YAd1.png');
        }
        #top-info-bar.selector-mode #coins-info-group .flex {
            position: absolute;
            top: 50%;
            left: 60%;
            transform: translate(-50%, -50%);
        }
        #top-info-bar.selector-mode .info-label,
        #top-info-bar.selector-mode .coin-icon {
            display: none;
        }


        #title-panel {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px 10px;
            min-height: 48px;
            width: 100%;
            margin: 0 auto 5px auto;
            position: relative;
            z-index: 10;
        }
        #title-panel h2 {
            font-size: 1.4em;
            margin: 0;
            color: #f3f3f3;
            font-family: 'Press Start 2P', sans-serif;
            letter-spacing: 1px;
            text-shadow:
                0px 0px 2px #422E58,
                -2px -2px 0 #422E58,
                2px -2px 0 #422E58,
                -2px  2px 0 #422E58,
                2px  2px 0 #422E58;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #title-image {
            max-height: 48px;
            width: auto;
            max-width: 90%;
        }

#settings-title img {
    max-height: 48px;
    width: auto;
    max-width: 90%;
}

        #progress-panel {
            display: grid;
            grid-template-columns: 1.01fr 1.99fr;
            gap: 8px;
            width: 100%;
            margin: 0 auto 5px auto;
            position: relative;
            z-index: 10;
        }

        #progress-panel .panel-card {
            position: relative;
            padding: 4px;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            box-sizing: border-box;
        }

        #progress-panel .panel-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }

        #progress-panel .panel-card::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 90%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }

        #current-world-info-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 10px;
            grid-column: 1 / 2;
            min-width: 80px;
            min-height: 55px;
            box-sizing: border-box;
            text-align: center;
            cursor: pointer;
        }
         #current-world-info-group .info-label { 
            font-size: 0.65em; 
            color: #a0aec0; 
            margin-bottom: 4px; 
            display: block; 
            line-height: 1.1;
        }
        #current-world-info-group .info-value {
            font-size: 0.85em;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
        }
        #progress-panel.classification-mode #current-world-info-group .info-value {
            margin-top: 4px;  
            font-size: 0.7em;
        }

        #star-progress-wrapper {
            grid-column: 2 / 3;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px 10px;
            min-height: 55px;
            box-sizing: border-box;
            text-align: center;
        }

        #star-progress-wrapper .value-box {
            background-color: #422E58;
            border-radius: 8px;
            padding: 6px 8px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #progress-panel.classification-mode #star-progress-wrapper .value-box {
            width: 97%;
        }

        #progress-lives-info-group {
            grid-column: 1 / 2;
        }

        #progress-lives-info-group .info-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            min-width: 90px;
            min-height: 48px;
            box-sizing: border-box;
            width: 100%;
        }

        #progress-lives-info-group .value-box {
            background-color: #422E58;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            width: 100%;
            text-align: center;
        }

        #progress-lives-info-group .info-icon-wrapper {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translate(15%, -50%);
            width: 40px;
            height: 40px;
        }

        #progress-lives-info-group .info-icon-wrapper img {
            width: 100%;
            height: 100%;
            display: block;
        }

        #progress-lives-info-group .life-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-45%, -50%);
            font-size: 0.9em;
            color: #f5f5f5;
        }

        #progress-lives-info-group .info-value {
            font-size: 0.85em;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            line-height: 1.3;
        }

        #star-progress-container {
            display: grid;
            grid-template-columns: repeat(5, auto);
            gap: 25px;
            justify-items: center;
            align-items: center;
            width: 100%;
            margin: 0;
        }
        .progress-star {
            width: 38px;
            height: 38px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .progress-star.full {
            background-image: url('https://i.imgur.com/mJU2iIm.png');
        }
        .progress-star.empty {
            background-image: url('https://i.imgur.com/M4FDVgp.png');
        }

        /* --- INICIO DE CSS CORREGIDO PARA #high-score-display --- */
        #high-score-display {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            padding: 6px 0 4px 22px;
            min-height: 48px; /* Igual altura que el temporizador de vidas */
        }
        #high-score-display .info-icon-wrapper {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translate(15%, -50%);
            width: 40px;
            height: 40px;
        }
        #high-score-display .info-icon-wrapper img {
            width: 100%;
            height: 100%;
            display: block;
        }
        #high-score-display .max-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -30%);
            font-size: 0.55em;
            color: #FFD700;
            font-family: 'Press Start 2P', sans-serif;
        }
        #high-score-display .value-box {
            background-color: #422E58;
            border-radius: 8px;
            padding: 6px 8px 6px 22px;
            min-height: 36px; /* Mantener misma altura visual que otros paneles */
            width: 100%;
            text-align: center;
        }
        #hs-values-container {
            display: flex;
            flex-direction: row;
            align-items: baseline;
            justify-content: center;
            gap: 2px;
            white-space: nowrap;
            width: 100%;
        }
        #high-score-display .hs-value {
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            font-size: 0.75rem;
        }
        #high-score-display .hs-label-unit {
            color: #f5f5f5;
            font-size: 0.7rem;
            margin-left: 2px;
            margin-right: 4px;
        }
        #high-score-display .hs-separator {
            margin-right: 3px;
            color: #f5f5f5;
            font-size: 0.7rem;
        }
        #high-score-display #hs-skin-value.hs-value {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: baseline;
        }


        canvas {
            background-color: #374151; 
            border: 4px solid #422E58; 
            display: block; 
            margin: 0 auto 5px auto; 
            max-width: 100%; 
            border-radius: 8px; 
            aspect-ratio: 1 / 1; 
        }

        #mobile-controls {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            margin: 0 auto;
            padding: 0 0px;
            box-sizing: border-box;
            flex-direction: column;
            flex-grow: 1;
        }


@media (hover: hover) and (pointer: fine) {
    #mobile-controls { display: none; }
    #play-area {
        display: grid;
        grid-template-rows: auto 1fr auto;
        flex-grow: 1;
        position: relative;
    }
            #gameCanvas {
                justify-self: center;
                align-self: center;
                margin-bottom: 0;
            }
            #setup-controls { margin-top: 5px; }
        }

        #d-pad-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; 
            grid-template-rows: 1fr 1fr;   
            gap: 8px; 
            width: 100%;
            min-height: 120px; 
            height: 100%; 
        }

        .control-button {
            position: relative;
            background: none;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            color: #4E3967;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2px;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            box-shadow: 0 2px 0 #422E58;
            overflow: hidden;
            z-index: 0;
        }
        .control-button::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        .control-button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 90%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        .d-pad-button-pressed {
            transform: scale(0.90) translateY(2px);
            filter: brightness(0.7);
        }
        
        #up-button    { 
            grid-column: 2; 
            grid-row: 1; 
        } 
        #left-button  { 
            grid-column: 1; 
            grid-row: 1 / span 2; 
        } 
        #right-button { 
            grid-column: 3; 
            grid-row: 1 / span 2; 
        } 
        #down-button  {
            grid-column: 2;
            grid-row: 2;
        }

        #left-button::after,
        #right-button::after {
            height: 95%;
        }

        .control-button:hover { filter: brightness(0.95); }
        
        .arrow-svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .control-button .arrow-svg path {
            fill: #4E3967;
            stroke: #D0B5E2;
            stroke-width: .3;
            stroke-linejoin: round;
        }
        .arrow-icon {
            width: 100%;
            height: 100%;
            display: block;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .mode-nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: transparent;
            border: none;
            padding: 0;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff3e1;
            cursor: pointer;
            z-index: 20;
        }
        #mode-left-button { left: 10px; }
        #mode-right-button { right: 10px; }
        
        #setup-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-top: 5px;
            margin-top: auto;
            margin-bottom: 0px;
            position: relative;
            width: 100%;
        }
        
        .control-row { 
            display: flex;
            align-items: stretch; 
            gap: 8px; 
            width: 100%;
            flex-wrap: wrap; 
            justify-content: center; 
        }
        
        .control-group {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 12px;
            flex: 1;
            min-width: 100px;
            box-sizing: border-box;
            transition: background-color 0.2s ease;
            min-height: 50px;
        }

        /* Extra space below the music and SFX volume sliders */
        #music-volume-control-group,
        #sfx-volume-control-group {
            padding-bottom: 12px;
        }

        .control-label-icon-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-top: 4px;
            margin-bottom: 6px;
        }

        .control-label {
            font-size: 0.7em;
            color: #a0aec0;
            display: block;
            line-height: 1.1;
            text-align: left;
            flex-grow: 1;
            margin-right: 0;
        }
        
        .setting-info-button {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            background-color: #384152;
            border: none;
            border-radius: 8px;
            padding: 0;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 38px;
            box-sizing: border-box;
        }
        .setting-info-icon {
            width: 24px;
            height: 24px;
            fill: #f5f5f5;
        }

        .setting-info-button[data-setting] .setting-info-icon {
            height: 70%;
            width: auto;
            display: block;
            fill: initial;
        }

        .setting-info-button:disabled .setting-info-icon {
            filter: brightness(0.4);
        }

        /* Semi-transparent navigation arrows */
        .mode-nav-button .arrow-icon {
            opacity: 0.6;
        }

        .coin-icon {
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }


        #earnedCoinsMessage {
            position: absolute;
            top: 50%;
            left: 100%;
            transform: translateX(-20px) translateY(-50%);
            color: #4ade80;
            font-size: 1em;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
            pointer-events: none;
            z-index: 20;
        }

        #earnedCoinsMessage.show {
            opacity: 1;
            transform: translateX(-45px) translateY(-50%);
        }

        #earnedCoinsMessage.hide {
            opacity: 0;
            transform: translateX(-100px) translateY(-50%);
        }

        #livesValue {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-45%, -50%);
            font-size: 0.9em;
            color: #f5f5f5;
        }
        #lifeTimerValue {
            position: static;
            transform: none;
        }

        #selectorLivesValue,
        #selectorLifeTimerValue {
            position: static;
            transform: none;
        }
        /* Align recovery timer like in free mode */
        #selectorLifeTimerValue {
            margin-left: 0;
        }


        #difficultySelector, #worldsSelector, #audioToggleSelector, #skinSelector, #foodSelector, #playerNameSelector, #free-difficulty-selector {
            padding: 4px 6px;
            width: calc(100% - 50px);
            font-size: 0.75em;
            border: none;
            border-radius: 4px;
            background-color: transparent;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            text-align: left;
            height: 38px;
            box-sizing: border-box;
            -moz-appearance: none;
            -webkit-appearance: none;
            appearance: none;
            margin-top: 4px;
            margin-bottom: 0;
        }
        
        #difficultySelector option, #worldsSelector option, #audioToggleSelector option, #skinSelector option, #foodSelector option, #playerNameSelector option, #free-difficulty-selector option {
            background-color: #374151;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            text-align: left; 
        }
        
        #difficultySelector, #worldsSelector, #audioToggleSelector, #skinSelector, #foodSelector, #playerNameSelector, #free-difficulty-selector {
            text-align-last: left;
        }
        select option {
            direction: ltr; 
        }


        #difficultySelector:focus, #worldsSelector:focus, #audioToggleSelector:focus, #skinSelector:focus, #foodSelector:focus, #playerNameSelector:focus, #free-difficulty-selector:focus {
            outline: 1px solid #8f66af; 
            box-shadow: none; 
        }
        #difficultySelector:disabled, #worldsSelector:disabled, #audioToggleSelector:disabled, #skinSelector:disabled, #foodSelector:disabled, #playerNameSelector:disabled, #free-difficulty-selector:disabled, #musicVolumeSlider:disabled, #sfxVolumeSlider:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        #newPlayerNameInput {
            padding: 4px 6px;
            width: calc(100% - 50px);
            font-size: 0.75em;
            border: 1px solid #8f66af;
            border-radius: 4px;
            background-color: transparent;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            box-sizing: border-box;
            height: 38px;
            margin-top: 4px;
            margin-bottom: 0;
        }
        #newPlayerNameInput:focus {
            outline: 1px solid #8f66af;
            box-shadow: none;
        }

        #free-settings-panel input[type="number"] {
            padding: 4px 6px;
            width: 100%;
            font-size: 0.75em;
            border: none;
            border-radius: 4px;
            background-color: transparent;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            box-sizing: border-box;
            margin-top: 4px;
            margin-bottom: 0;
        }

        #free-settings-panel input[type="number"]:focus {
            outline: 1px solid #8f66af;
            box-shadow: none;
        }

        .range-inputs {
            display: flex;
            gap: 8px;
        }
        .range-inputs input[type="number"] {
            flex: 1;
        }
        
        .control-group.interactive-mode { 
            background-color: #4A5568; 
        }
        .control-group.interactive-mode:hover {
            background-color: #5A6578; 
            cursor: pointer;
        }
        .control-group.interactive-mode:hover #difficultySelector,
        .control-group.interactive-mode:hover #worldsSelector,
        .control-group.interactive-mode:hover #audioToggleSelector,
        .control-group.interactive-mode:hover #skinSelector,
        .control-group.interactive-mode:hover #foodSelector,
        .control-group.interactive-mode:hover #musicVolumeSlider,
        .control-group.interactive-mode:hover #sfxVolumeSlider {
            cursor: pointer;
        }

        .control-group.dimmed {
            filter: brightness(0.6);
        }

        #musicVolumeSlider {
            -webkit-appearance: none;
            appearance: none;
            width: calc(100% - 50px);
            height: 8px;
            background: #4B5563;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-top: 4px;
            margin-bottom: 0;
        }
        #sfxVolumeSlider {
            -webkit-appearance: none;
            appearance: none;
            width: calc(100% - 50px);
            height: 8px;
            background: #4B5563;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-top: 4px;
            margin-bottom: 0;
        }
        #musicVolumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
        }
        #sfxVolumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
        }
        #musicVolumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        #sfxVolumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        .settings-range {
            -webkit-appearance: none;
            appearance: none;
            width: calc(100% - 50px);
            height: 8px;
            background: #4B5563;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-top: 15px;
            margin-bottom: 5px;
        }
        .control-group .settings-range:not(:last-of-type) {
            margin-bottom: 15px;
        }
        .settings-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
        }
        .settings-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        #classification-ranking-group {
            /* allow panel to expand with ranking */
        }
        #classification-ranking-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.6rem;
            color: #f5f5f5;
            border-radius: 8px;
            overflow: hidden;
        }
        #classification-ranking-table th,
        #classification-ranking-table td {
            padding: 10px 4px;
            border: 1px solid #5F3F79;
            text-align: center;
        }
        #classification-ranking-table th {
            background-color: #ba9bc9;
        }
        #classification-ranking-table .title-row th {
            background-color: #A366C4;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4B5563;
            transition: .4s;
            border-radius: 24px;
        }
        .slider.round:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        .switch input:checked + .slider.round {
            background-color: #8f66af;
        }
        .switch input:checked + .slider.round:before {
            transform: translateX(16px);
        }

        #action-buttons-row {
            justify-content: center; 
            min-height: 65px; 
        }
        .action-button-wrapper { 
            background-color: transparent !important; 
            padding: 0 !important; 
            min-height: auto !important;
            min-width: auto; 
            display: flex; 
        }
        #back-button-wrapper { display: none; }
        #start-button-wrapper {
            flex-grow: 1;
            display: flex;
            gap: 4px;
        }
        #start-button-wrapper.split #startButton { flex-grow: 2; }
        #start-button-wrapper.split #restartMazeButton { flex-grow: 1; }
        #config-button-wrapper { display: none; }


        #startButton, #restartMazeButton, #configButton, #backButton {
            padding: 0 15px;
            font-size: 0.85em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            height: 65px;
            font-family: 'Press Start 2P', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            color: #f5f5f5;
        }
        #startButton {
            position: relative;
            padding: 0 6px;
            font-size: 1.1em;
            color: #4E3967;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            text-shadow:
                0px 0px 1px #422E58,
                -1px -1px 0 #D0B5E2,
                1px -1px 0 #D0B5E2,
                -1px  1px 0 #D0B5E2,
                1px  1px 0 #D0B5E2;
            overflow: hidden;
            background: none;
            z-index: 0;
        }
        #startButton::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #startButton::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 80%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        #restartMazeButton {
            padding: 0;
            background-color: transparent;
            flex: 0 0 auto;
            width: auto;
            min-width: 0;
        }
        #configButton, #backButton {
            background-color: #384152;
            min-width: 65px;
        }

        #startButton:hover {
            filter: brightness(0.95);
        }

        #startButton:disabled {
            filter: brightness(0.6);
            cursor: not-allowed;
        }
        #restartMazeButton:disabled,
        #configButton:disabled,
        #backButton:disabled {
            cursor: not-allowed;
        }
        #configButton:disabled #configButtonIcon,
        #backButton:disabled #backButtonIcon,
        #restartMazeButton:disabled #restartMazeButtonIcon {
            filter: brightness(0.7);
        }
        #backButton { padding: 0; background-color: transparent; flex: 0 0 auto; width: auto; min-width: 0; }
        #backButtonIcon { height: 100%; width: auto; display: block; transition: transform 0.05s ease-out, filter 0.05s ease-out; }
        #restartMazeButtonIcon { height: 100%; width: auto; display: block; transition: transform 0.05s ease-out, filter 0.05s ease-out; }
        #configButton { padding: 0; background-color: transparent; flex: 0 0 auto; width: auto; min-width: 0; }
        #configButtonIcon { height: 100%; width: auto; display: block; transition: transform 0.05s ease-out, filter 0.05s ease-out; }
        .icon-button-pressed {
            transform: scale(0.90) translateY(2px);
            filter: brightness(0.7);
        }
        #startButton.icon-button-pressed,
        #resetDataButton.icon-button-pressed,
        #confirmResetYes.icon-button-pressed,
        #confirmResetNo.icon-button-pressed,
        #confirmPurchaseYes.icon-button-pressed,
        #confirmPurchaseNo.icon-button-pressed,
        #confirmSelectYes.icon-button-pressed,
        #confirmSelectNo.icon-button-pressed {
            filter: brightness(0.5);
        }
        .menu-option-button {
            position: relative;
            padding: 0 6px;
            font-size: 1em;
            color: #4E3967;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            text-shadow:
                0px 0px 1px #422E58,
                -1px -1px 0 #D0B5E2,
                1px -1px 0 #D0B5E2,
                -1px  1px 0 #D0B5E2,
                1px  1px 0 #D0B5E2;
            overflow: hidden;
            background: none;
            z-index: 0;
            width: 100%;
            height: 65px;
            font-family: 'Press Start 2P', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            color: #4E3967;
        }
        .menu-option-button::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        .menu-option-button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 80%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        .menu-option-button:hover { filter: brightness(0.95); }
        .menu-option-button:disabled { filter: brightness(0.6); cursor: not-allowed; }
        .menu-option-button.icon-button-pressed { filter: brightness(0.5); }
        .config-svg,
        .info-svg {
            height: 100%;
            width: auto;
            fill: currentColor;
            display: block;
        }

        .settings-panel-hidden, .info-panel-hidden, .specific-info-panel-hidden, .free-settings-panel-hidden, .reset-panel-hidden, .config-menu-panel-hidden, .generic-menu-panel-hidden, .store-panel-hidden, .profile-panel-hidden, .purchase-confirmation-panel-hidden, .delete-confirmation-panel-hidden, .out-of-lives-panel-hidden, .select-confirmation-panel-hidden {
            display: none !important;
        }
        #settings-panel, #info-panel, #specific-info-panel, #free-settings-panel, #reset-confirmation-panel, #config-menu-panel, #generic-menu-panel, #store-panel, #profile-panel, #purchase-confirmation-panel, #delete-confirmation-panel, #out-of-lives-panel, #select-confirmation-panel {
            position: fixed;
            left: 0;
            transform: scale(0);
            background-color: #1F2937;
            padding: 15px;
            border-radius: 12px;
            box-shadow:
                inset 0 0 0 4px #8f66af,
                inset 0 4px 6px #D6BCE9,
                0 2px 0 #422E58;
            z-index: 2100;
            width: 100%;
            max-width: var(--game-max-width);
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 2px solid #2d1d3a;
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

.panel-content {
            overflow-y: auto;
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding-right: 0;
        }
        .scroll-padding { padding-right: 4px; }

        #store-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }
        #store-panel .panel-content {
            padding-right: 10px;
        }
        #profile-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }
        #profile-panel .panel-content {
            padding-right: 10px;
        }

        #info-panel,
        #specific-info-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }
        #maze-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 28px;
            height: 28px;
            margin: 0 6px;
        }
        #maze-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #world-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 28px;
            height: 28px;
            margin: 0 6px;
        }
        #world-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #classification-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 28px;
            height: 28px;
            margin: 0 6px;
        }
        #classification-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #free-mode-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 28px;
            height: 28px;
            margin: 0 6px;
        }
        #free-mode-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #profile-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 28px;
            height: 28px;
            margin: 0 6px;
        }
        #profile-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #free-settings-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }
        #settings-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }

        .centered-panel {
            top: 50%;
        }
        #settings-panel.centered-panel,
        #info-panel.centered-panel,
        #specific-info-panel.centered-panel,
        #free-settings-panel.centered-panel,
        #reset-confirmation-panel.centered-panel,
        #config-menu-panel.centered-panel,
        #generic-menu-panel.centered-panel,
        #store-panel.centered-panel,
        #profile-panel.centered-panel,
        #purchase-confirmation-panel.centered-panel,
        #delete-confirmation-panel.centered-panel,
        #out-of-lives-panel.centered-panel,
        #select-confirmation-panel.centered-panel {
            transform: translate(-50%, -50%) scale(0);
        }
        #settings-panel.centered-panel.panel-visible,
        #info-panel.centered-panel.panel-visible,
        #specific-info-panel.centered-panel.panel-visible,
        #free-settings-panel.centered-panel.panel-visible,
        #reset-confirmation-panel.centered-panel.panel-visible,
        #config-menu-panel.centered-panel.panel-visible,
        #generic-menu-panel.centered-panel.panel-visible,
        #store-panel.centered-panel.panel-visible,
        #profile-panel.centered-panel.panel-visible,
        #purchase-confirmation-panel.centered-panel.panel-visible,
        #delete-confirmation-panel.centered-panel.panel-visible,
        #out-of-lives-panel.centered-panel.panel-visible,
        #select-confirmation-panel.centered-panel.panel-visible {
            transform: translate(-50%, -50%) scale(1);
        }
        #settings-panel.panel-visible,
        #info-panel.panel-visible,
        #specific-info-panel.panel-visible,
        #free-settings-panel.panel-visible,
        #reset-confirmation-panel.panel-visible,
        #config-menu-panel.panel-visible,
        #generic-menu-panel.panel-visible,
        #store-panel.panel-visible,
        #profile-panel.panel-visible,
        #purchase-confirmation-panel.panel-visible,
        #delete-confirmation-panel.panel-visible,
        #out-of-lives-panel.panel-visible,
        #select-confirmation-panel.panel-visible {
            opacity: 1;
            transform: scale(1);
        }

         #specific-info-panel {
            z-index: 2103;
        }
        .settings-header, .info-header, .specific-info-header, .reset-header {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #f3f3f3;
            margin-bottom: 3px;
        }
        .settings-header h2, .info-header h2, .specific-info-header h2, .reset-header h2 {
            font-size: 1.4em;
            margin: 0;
            font-family: 'Press Start 2P', sans-serif;
            color: #f3f3f3;
            letter-spacing: 1px;
            text-shadow:
                0px 0px 2px #422E58,
                -2px -2px 0 #422E58,
                2px -2px 0 #422E58,
                -2px  2px 0 #422E58,
                2px  2px 0 #422E58;
        }
        .settings-header .header-title-group {
            display: flex;
            align-items: center;
            gap: 0;
        }
        #free-settings-panel .settings-header h2 {
            font-size: 1.1em;
        }
        #out-of-lives-panel .settings-header {
            justify-content: flex-end;
        }
        .close-button {
            position: absolute;
            top: 0;
            right: 0;
            transform: translate(75%, -75%);
            background: none;
            border: none;
            padding: 0;
            width: 36px;
            height: 36px;
            cursor: pointer;
            line-height: 0;
        }
        .close-button img {
            width: 100%;
            height: 100%;
            display: block;
        }
        #settings-panel .control-group {
            background-color: #374151;
            min-width: unset;
            width:100%;
        }
        #settings-panel #classification-ranking-group {
            background-color: transparent;
        }
        #free-settings-panel .control-group {
            flex: none;
            width: 100%;
        }

        #free-settings-panel .panel-content {
            padding-right: 10px;
        }

        /* Primer título/texto en cada contenedor del modo libre */
        #free-settings-panel .control-group > label.control-label:first-child,
        #free-settings-panel .control-group > .control-label-icon-row:first-child > label.control-label {
            font-size: 0.85em;
            color: #F3F3F3;
        }

        /* Estilos para el contenido del panel de información */
        #info-panel-content {
            line-height: 1.6;
            overflow-y: auto;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-right: 10px;
        }
        #specific-info-content {
            line-height: 1.6;
            overflow-y: auto;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-right: 0;
        }
        .info-header h2#main-info-title {
            font-size: 1.4em;
            color: #f3f3f3;
        }
        #info-panel-content h4,
        #specific-info-content h4 {
            font-size: 1em;
            color: #8C64AF;
            margin-top: 6px;
            margin-bottom: 3px;
            text-align: left;
        }
         #specific-info-content h3 {
            font-size: 0.8em;
            color: #8C64AF;
            margin-bottom: 6px;
            text-align: center;
        }
        #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul {
            font-size: 0.8em;
            margin-bottom: 6px;
            text-align: justify;
        }
        #info-panel-content ul, #specific-info-content ul {
            list-style-type: disc; 
            list-style-position: inside;
            padding-left: 5px;
        }
        #info-panel-content li, #specific-info-content li {
            margin-bottom: 6px;
        }
        /* Estilos de scroll unificados para todos los paneles */
        #info-panel-content::-webkit-scrollbar,
        #specific-info-content::-webkit-scrollbar,
        #settings-panel .panel-content::-webkit-scrollbar,
        #info-panel .panel-content::-webkit-scrollbar,
        #specific-info-panel .panel-content::-webkit-scrollbar,
        #free-settings-panel .panel-content::-webkit-scrollbar,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar,
        #store-panel .panel-content::-webkit-scrollbar,
        #profile-panel .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        #info-panel-content::-webkit-scrollbar-track,
        #specific-info-content::-webkit-scrollbar-track,
        #settings-panel .panel-content::-webkit-scrollbar-track,
        #info-panel .panel-content::-webkit-scrollbar-track,
        #specific-info-panel .panel-content::-webkit-scrollbar-track,
        #free-settings-panel .panel-content::-webkit-scrollbar-track,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-track,
        #store-panel .panel-content::-webkit-scrollbar-track,
        #profile-panel .panel-content::-webkit-scrollbar-track {
            background: #2d1d3a;
            border-radius: 4px;
        }
        #info-panel-content::-webkit-scrollbar-thumb,
        #specific-info-content::-webkit-scrollbar-thumb,
        #settings-panel .panel-content::-webkit-scrollbar-thumb,
        #info-panel .panel-content::-webkit-scrollbar-thumb,
        #specific-info-panel .panel-content::-webkit-scrollbar-thumb,
        #free-settings-panel .panel-content::-webkit-scrollbar-thumb,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-thumb,
        #store-panel .panel-content::-webkit-scrollbar-thumb,
        #profile-panel .panel-content::-webkit-scrollbar-thumb {
            background: #442F58;
            border-radius: 4px;
        }
        #info-panel-content::-webkit-scrollbar-thumb:hover,
        #info-panel-content::-webkit-scrollbar-thumb:active,
        #specific-info-content::-webkit-scrollbar-thumb:hover,
        #specific-info-content::-webkit-scrollbar-thumb:active,
        #settings-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #settings-panel .panel-content::-webkit-scrollbar-thumb:active,
        #info-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #info-panel .panel-content::-webkit-scrollbar-thumb:active,
        #specific-info-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #specific-info-panel .panel-content::-webkit-scrollbar-thumb:active,
        #free-settings-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #free-settings-panel .panel-content::-webkit-scrollbar-thumb:active,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-thumb:active,
        #store-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #store-panel .panel-content::-webkit-scrollbar-thumb:active,
        #profile-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #profile-panel .panel-content::-webkit-scrollbar-thumb:active {
            background: #8f66af;
        }


        @media screen and (max-width: 600px) {
            /* --- INICIO DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */
            /* Ya no necesitamos reducir el font-size base del contenedor #high-score-display */
            
            #hs-values-container { gap: 3px; }
            #high-score-display .hs-value { font-size: 0.7rem; }
            #high-score-display .hs-label-unit { font-size: 0.65rem; }
            #high-score-display .hs-separator { font-size: 0.65rem; }
            #high-score-display #hs-skin-value.hs-value { max-width: 85px; }
            #high-score-display { min-height: 24px; }
            #high-score-display .info-icon-wrapper { width: 26px; height: 26px; transform: translate(10%, -50%); }
            #high-score-display .value-box {
                padding: 0 4px 0 10px;
                min-height: 24px;
            }
            /* --- FIN DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */

            /* Ajustes para mensaje de monedas ganadas en móviles */
            #earnedCoinsMessage {
                font-size: 0.8em;
                transform: translateX(-30px) translateY(-50%);
            }
            #earnedCoinsMessage.show {
                transform: translateX(-25px) translateY(-50%);
            }
            #earnedCoinsMessage.hide {
                transform: translateX(-70px) translateY(-50%);
            }


            #top-info-bar { gap: 0px; margin: 0 auto 6px auto; }
            #top-info-bar .info-group { min-height: 30px; padding: 1px 4px 1px 14px; min-width: 80px; }
            #top-info-bar .value-box { padding: 1px 6px 1px 14px; }
            #top-info-bar .info-label { font-size: 0.6em; }
            #top-info-bar .info-value { font-size: 0.8em; }
            #points-info-group .info-value { font-size: 0.7em; }
            #top-info-bar .info-icon-wrapper { width: 26px; height: 26px; transform: translate(10%, -50%); }
            #selector-info-bar { gap: 0px; margin: 0 auto 6px auto; }
            #selector-info-bar .info-group { min-height: 30px; padding: 1px 4px 1px 14px; min-width: 80px; }
            #selector-info-bar .value-box { padding: 1px 6px 1px 14px; }
            #selector-info-bar .info-label { font-size: 0.6em; }
            #selector-info-bar .info-value { font-size: 0.8em; }
            #selector-info-bar .info-icon-wrapper { width: 26px; height: 26px; transform: translate(10%, -50%); }



            /* Shift coin and gem values slightly left */
            #selectorCoinValue,
            #selectorGemsValue {
                margin-left: 0;
            }
            /* Reset desktop offset for recovery timer */
            #selectorLifeTimerValue {
                margin-left: 0;
            }
          
            #title-panel { min-height: 30px; padding: 6px; }
            #title-image,
            #settings-title,
            #main-info-title,
            #specific-info-title { font-size: 0.9em; }

            #current-world-info-group { min-height: 30px; padding: 1px 4px 1px 14px; min-width: 70px; cursor: pointer;}
            #current-world-info-group .info-label { font-size: 0.6em; }
            #current-world-info-group .info-value { font-size: 0.8em; }
            #progress-panel.classification-mode #current-world-info-group .info-value { font-size: 0.7em; }
            #star-progress-wrapper { min-height: 28px; padding: 1px 2px; }
            #star-progress-wrapper .value-box {
                padding: 1px 2px;
                min-height: 24px;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            #progress-lives-info-group .info-group { min-height: 30px; padding: 1px 4px 1px 14px; }
            #progress-lives-info-group .value-box { padding: 1px 6px 1px 14px; }
            #progress-lives-info-group .info-value { font-size: 0.8em; }
            #progress-lives-info-group .info-icon-wrapper { width: 26px; height: 26px; transform: translate(10%, -50%); }
            .progress-star { width: 30px; height: 30px; }
            #star-progress-container { width: 100%; gap: 19px; }


            #d-pad-container {
                min-height: 110px; 
                gap: 6px;
            }
            .arrow-svg { width: 70%; height: 70%; }
            .arrow-icon { width: 100%; height: 100%; }
            
            #startButton, #restartMazeButton, #configButton, #backButton {
                font-size: 0.75em;
                height: 55px;
            }
            #startButton {
                font-size: 1em;
            }
            #restartMazeButton, #configButton, #backButton {
                min-width: 55px;
            }

            #settings-panel, #info-panel, #specific-info-panel, #free-settings-panel {
                width: calc(100% - 10px);
                padding: 10px;
            }
            .settings-header h2, .info-header h2, .specific-info-header h2 {
                font-size: 1.1em;
            }
            #free-settings-panel .settings-header h2 {
                font-size: 0.90em;
                text-align: left;
                white-space: nowrap;
            }
             #settings-panel .control-group {
                min-height: 50px;
                justify-content: space-between;
                padding-top: 6px;
                padding-bottom: 6px;
            }
             #settings-panel #difficultySelector,
             #settings-panel #worldsSelector,
             #settings-panel #audioToggleSelector,
             #settings-panel #skinSelector,
             #settings-panel #foodSelector,
             #settings-panel #playerNameSelector,
             #settings-panel #musicVolumeSlider {
                font-size: 0.65em;
                margin-top: 2px;
                margin-bottom: 0;
             }
             #settings-panel .control-label-icon-row {
                margin-top: 4px;
                margin-bottom: 0;
             }
             .setting-info-button {
                width: 36px;
                height: 32px;
             }
             .setting-info-button[data-setting] .setting-info-icon {
                height: 100%;
                width: auto;
             }


            .info-header h2#main-info-title, #specific-info-content h3 { font-size: 1.1em; }
            #info-panel-content h4, #specific-info-content h4 { font-size: 0.95em; }
            #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul { font-size: 0.75em; }
        }
        @media screen and (max-width: 400px) {
            /* --- INICIO DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */
            /* Tampoco necesitamos tocar el font-size del contenedor */

            #hs-values-container { gap: 2px; }
            #high-score-display .hs-value { font-size: 0.6rem; }
            #high-score-display .hs-label-unit { font-size: 0.4rem; }
            #high-score-display .hs-separator { font-size: 0.45rem; }
            #high-score-display #hs-skin-value.hs-value { max-width: 70px; }
            #high-score-display { min-height: 28px; }
            #high-score-display .info-icon-wrapper { width: 32px; height: 32px; transform: translate(12%, -50%); }
            #high-score-display .value-box {
                padding: 1px 3px 1px 12px;
                min-height: 28px;
            }
            /* --- FIN DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */

            /* Ajustes para mensaje de monedas ganadas en móviles extra-pequeños */
            #earnedCoinsMessage {
                font-size: 0.75em;
                transform: translateX(-25px) translateY(-40%);
            }
            #earnedCoinsMessage.show {
                transform: translateX(-22px) translateY(-40%);
            }
            #earnedCoinsMessage.hide {
                transform: translateX(-60px) translateY(-40%);
            }

            #title-panel { min-height: 36px; padding: 6px; }
            #title-image,
            #settings-title,
            #main-info-title,
            #specific-info-title { font-size: 1em; }


             #top-info-bar .info-label { font-size: 0.55em; }
             #top-info-bar .info-value { font-size: 0.7em; }
             #points-info-group .info-value { font-size: 0.6em; }
             #top-info-bar .info-group { min-width: 80px; min-height: 34px; padding: 2px 4px 2px 20px; }
             #top-info-bar .value-box { padding: 2px 5px 2px 20px; }
             #top-info-bar .info-icon-wrapper { width: 32px; height: 32px; transform: translate(12%, -50%); }
             #selector-info-bar { gap: 0px; margin: 0 auto 6px auto; }
             #selector-info-bar .info-label { font-size: 0.55em; }
             #selector-info-bar .info-value { font-size: 0.7em; }
             #selector-info-bar .info-group { min-width: 80px; min-height: 34px; padding: 2px 4px 2px 20px; }
             #selector-info-bar .value-box { padding: 2px 5px 2px 20px; }
             #selector-info-bar .info-icon-wrapper { width: 32px; height: 32px; transform: translate(12%, -50%); }

            /* Adjust value positioning on smaller screens */
            #selectorCoinValue,
            #selectorGemsValue {
                margin-left: 0;
            }
            #selectorLifeTimerValue {
                margin-left: 0;
            }

            #current-world-info-group .info-label { font-size: 0.55em; }
            #current-world-info-group .info-value { font-size: 0.7em; }
            #progress-panel.classification-mode #current-world-info-group .info-value { font-size: 0.6em; }
            #current-world-info-group { min-width: 60px; min-height: 34px; padding: 2px 4px 2px 20px; cursor: pointer;}
            #star-progress-wrapper { min-height: 30px; padding: 2px 2px; }
            #star-progress-wrapper .value-box {
                padding: 5px 5px;
                min-height: 26px;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            #progress-lives-info-group .info-group { min-height: 36px; padding: 2px 4px 2px 20px; }
            #progress-lives-info-group .value-box { padding: 2px 5px 2px 20px; }
            #progress-lives-info-group .info-value { font-size: 0.7em; }
            #progress-lives-info-group .info-icon-wrapper { width: 32px; height: 32px; transform: translate(12%, -50%); }
            .progress-star { width: 24px; height: 24px; }
            #star-progress-container { width: 100%; gap: 16px; }


            #d-pad-container {
                min-height: 100px; 
                gap: 5px;
            }
            .arrow-svg { width: 70%; height: 70%; }
            .arrow-icon { width: 100%; height: 100%; }

            #startButton, #restartMazeButton, #configButton, #backButton {
                font-size: 0.7em;
                height: 50px;
            }
            #startButton {
                font-size: 0.9em;
            }
            #restartMazeButton, #configButton, #backButton {
                min-width: 50px;
            }
            .config-svg,
            .info-svg {
                height: 100%;
                width: auto;
            }
            #settings-panel, #info-panel, #specific-info-panel, #free-settings-panel {
                padding: 10px;
            }
            .info-header h2#main-info-title, #specific-info-content h3 { font-size: 1em; }
            #info-panel-content h4, #specific-info-content h4 { font-size: 0.85em; }
            #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul { font-size: 0.7em; }
        }

        @media screen and (min-width: 600px) {
            #settings-panel #difficultySelector,
            #settings-panel #worldsSelector,
            #settings-panel #audioToggleSelector,
            #settings-panel #skinSelector,
            #settings-panel #foodSelector {
            height: 30px;
            margin-top: 2px;
            margin-bottom: 0;
        }
        }

        #settings-panel #resetDataButton {
            background-color: #dc2626;
            color: #F3F3F3;
            border: 3px solid #7f1d1d;
            box-shadow:
                inset 0 10px 6px #f87171,
                4px 4px 6px #7f1d1d;
            text-shadow: -1px -1px 0 #7f1d1d,
                         1px -1px 0 #7f1d1d,
                        -1px 1px 0 #7f1d1d,
                         1px 1px 0 #7f1d1d;
            border-radius: 8px;
            padding: 10px 15px;
            font-family: "Press Start 2P", sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            text-align: center;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 65px;
            box-sizing: border-box;
        }

#settings-panel #resetDataButton:hover { filter: brightness(0.95); }

        #free-settings-panel #apply-free-settings-bottom {
            background-color: #8f66af;
            color: #F3F3F3;
            border: 3px solid #2d1d3a;
            box-shadow:
                inset 0 10px 6px #D6BCE9,
                4px 4px 6px #442F58;
            text-shadow: -1px -1px 0 #2d1d3a,
                         1px -1px 0 #2d1d3a,
                        -1px 1px 0 #2d1d3a,
                         1px 1px 0 #2d1d3a;
            border-radius: 8px;
            padding: 10px 15px;
            font-family: 'Press Start 2P', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            text-align: center;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 65px;
            box-sizing: border-box;
        }
        #free-settings-panel #apply-free-settings-bottom:hover { filter: brightness(0.95); }
        #free-settings-panel #apply-free-settings-bottom:disabled {
            filter: brightness(0.6);
            cursor: not-allowed;
        }
        #free-settings-panel #apply-free-settings-bottom.icon-button-pressed {
            filter: brightness(0.5);
        }

        #reset-confirmation-panel { z-index: 2102; }
        #settings-panel { z-index: 2101; }
        #generic-menu-panel { z-index: 2101; }
        #store-panel { z-index: 2101; }
        #profile-panel { z-index: 2101; }
        #purchase-confirmation-panel { z-index: 2103; }
        #delete-confirmation-panel { z-index: 2103; }
        #select-confirmation-panel { z-index: 2103; }
        #out-of-lives-panel {
            z-index: 2103;
            max-height: 90vh;
            box-sizing: border-box;
        }
        #out-of-lives-panel .panel-content {
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        #out-of-lives-panel p {
            margin: 0;
        }
        #out-of-lives-panel .out-of-lives-heart {
            width: 100%;
            max-width: 140px;
            height: auto;
        }
        #out-of-lives-panel .get-lives-button {
            max-width: min(30vw, 110px);
        }
        @media screen and (max-width: 600px) {
            #out-of-lives-panel .get-lives-button { max-width: min(25vw, 60px); }
            #out-of-lives-panel .out-of-lives-heart { max-width: 130px; }
            #out-of-lives-panel p { font-size: 0.85em; }
        }
        @media screen and (max-width: 400px) {
            #out-of-lives-panel .get-lives-button { max-width: min(30vw, 60px); }
            #out-of-lives-panel .out-of-lives-heart { max-width: 130px; }
            #out-of-lives-panel p { font-size: 0.75em; }
        }
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2102;
        }

        .reset-panel-hidden { display: none !important; }

        #reset-confirmation-panel p { text-align: center; margin: 0 0 10px 0; }
        #reset-confirmation-panel .reset-buttons,
        #purchase-confirmation-panel .reset-buttons,
        #delete-confirmation-panel .reset-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        #out-of-lives-panel .reset-buttons {
            display: flex;
            gap: 25px;
            justify-content: center;
        }
        #reset-confirmation-panel .reset-buttons button {
            flex: 0 0 auto;
            min-width: 130px;
            position: relative;
            padding: 0 6px;
            font-size: 1em;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            overflow: hidden;
            background: none;
            color: #ffffff;
            font-family: "Press Start 2P", sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            height: 65px;
            box-sizing: border-box;
        }
        #confirmResetYes::before,
        #confirmResetNo::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #confirmResetYes::after,
        #confirmResetNo::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 80%;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        #confirmResetYes {
            border: 2px solid #7f1d1d;
            text-shadow: -1px -1px 0 #7f1d1d,
                         1px -1px 0 #7f1d1d,
                        -1px 1px 0 #7f1d1d,
                         1px 1px 0 #7f1d1d;
        }
        #confirmResetYes::before {
            background: linear-gradient(
                #fecaca 0%,
                #fecaca 50%,
                #b91c1c 50%,
                #b91c1c 100%
            );
        }
        #confirmResetYes::after {
            background-color: #f87171;
        }
        #confirmResetNo {
            border: 2px solid #1b5e20;
            text-shadow: -1px -1px 0 #1b5e20,
                         1px -1px 0 #1b5e20,
                        -1px 1px 0 #1b5e20,
                         1px 1px 0 #1b5e20;
        }
        #confirmResetNo::before {
            background: linear-gradient(
                #d1fae5 0%,
                #d1fae5 50%,
                #4CAF50 50%,
                #4CAF50 100%
            );
        }
        #confirmResetNo::after {
            background-color: #81c784;
        }
        #confirmResetYes:hover,
        #confirmResetNo:hover { filter: brightness(0.95); }

        /* Estilos de botones para confirmar compra */
        #confirmPurchaseYes,
        #confirmPurchaseNo {
            flex: 0 0 auto;
            min-width: 130px;
            position: relative;
            padding: 0 6px;
            font-size: 1em;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            overflow: hidden;
            background: none;
            color: #ffffff;
            font-family: 'Press Start 2P', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            height: 65px;
            box-sizing: border-box;
        }
        #confirmPurchaseYes::before,
        #confirmPurchaseNo::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #confirmPurchaseYes::after,
        #confirmPurchaseNo::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 80%;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        #confirmPurchaseYes {
            border: 2px solid #1b5e20;
            text-shadow: 0px 0px 1px #422E58,
                         -1px -1px 0 #1b5e20,
                          1px -1px 0 #1b5e20,
                         -1px 1px 0 #1b5e20,
                          1px 1px 0 #1b5e20;
        }
        #confirmPurchaseYes::before {
            background: linear-gradient(
                #d1fae5 0%,
                #d1fae5 50%,
                #4CAF50 50%,
                #4CAF50 100%
            );
        }
        #confirmPurchaseYes::after {
            background-color: #81c784;
        }
        #confirmPurchaseNo {
            border: 2px solid #7f1d1d;
            text-shadow: 0px 0px 1px #422E58,
                         -1px -1px 0 #7f1d1d,
                          1px -1px 0 #7f1d1d,
                         -1px 1px 0 #7f1d1d,
                          1px 1px 0 #7f1d1d;
        }
        #confirmPurchaseNo::before {
            background: linear-gradient(
                #fecaca 0%,
                #fecaca 50%,
                #b91c1c 50%,
                #b91c1c 100%
            );
        }
        #confirmPurchaseNo::after {
            background-color: #f87171;
        }
        #confirmPurchaseYes:hover,
        #confirmPurchaseNo:hover { filter: brightness(0.95); }
        #confirmPurchaseYes:disabled,
        #confirmPurchaseNo:disabled { filter: brightness(0.6); cursor: not-allowed; }

        /* Estilos de botones para confirmación de selección o ir a tienda */
        #confirmSelectYes,
        #confirmSelectNo {
            flex: 0 0 auto;
            min-width: 130px;
            position: relative;
            padding: 0 6px;
            font-size: 1em;
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            overflow: hidden;
            background: none;
            color: #ffffff;
            font-family: 'Press Start 2P', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            height: 65px;
            box-sizing: border-box;
        }
        #confirmSelectYes::before,
        #confirmSelectNo::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #confirmSelectYes::after,
        #confirmSelectNo::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 80%;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        #confirmSelectYes {
            border: 2px solid #1b5e20;
            text-shadow: 0px 0px 1px #422E58,
                         -1px -1px 0 #1b5e20,
                          1px -1px 0 #1b5e20,
                         -1px 1px 0 #1b5e20,
                          1px 1px 0 #1b5e20;
        }
        #confirmSelectYes::before {
            background: linear-gradient(
                #d1fae5 0%,
                #d1fae5 50%,
                #4CAF50 50%,
                #4CAF50 100%
            );
        }
        #confirmSelectYes::after {
            background-color: #81c784;
        }
        #confirmSelectNo {
            border: 2px solid #7f1d1d;
            text-shadow: 0px 0px 1px #422E58,
                         -1px -1px 0 #7f1d1d,
                          1px -1px 0 #7f1d1d,
                         -1px 1px 0 #7f1d1d,
                          1px 1px 0 #7f1d1d;
        }
        #confirmSelectNo::before {
            background: linear-gradient(
                #fecaca 0%,
                #fecaca 50%,
                #b91c1c 50%,
                #b91c1c 100%
            );
        }
        #confirmSelectNo::after {
            background-color: #f87171;
        }
        #confirmSelectYes:hover,
        #confirmSelectNo:hover { filter: brightness(0.95); }

        /* Estilos de botones para confirmar eliminación de jugador */
        #confirmDeleteYes,
        #confirmDeleteNo {
            flex: 0 0 auto;
            min-width: 130px;
            position: relative;
            padding: 0 6px;
            font-size: 1em;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            overflow: hidden;
            background: none;
            color: #ffffff;
            font-family: 'Press Start 2P', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            height: 65px;
            box-sizing: border-box;
        }
        #confirmDeleteYes::before,
        #confirmDeleteNo::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: calc(100% + 4px);
            height: calc(100% + 4px);
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }
        #confirmDeleteYes::after,
        #confirmDeleteNo::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 80%;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }
        #confirmDeleteYes {
            border: 2px solid #7f1d1d;
            text-shadow: -1px -1px 0 #7f1d1d,
                         1px -1px 0 #7f1d1d,
                        -1px 1px 0 #7f1d1d,
                         1px 1px 0 #7f1d1d;
        }
        #confirmDeleteYes::before {
            background: linear-gradient(
                #fecaca 0%,
                #fecaca 50%,
                #b91c1c 50%,
                #b91c1c 100%
            );
        }
        #confirmDeleteYes::after {
            background-color: #f87171;
        }
        #confirmDeleteNo {
            border: 2px solid #1b5e20;
            text-shadow: -1px -1px 0 #1b5e20,
                         1px -1px 0 #1b5e20,
                        -1px 1px 0 #1b5e20,
                         1px 1px 0 #1b5e20;
        }
        #confirmDeleteNo::before {
            background: linear-gradient(
                #d1fae5 0%,
                #d1fae5 50%,
                #4CAF50 50%,
                #4CAF50 100%
            );
        }
        #confirmDeleteNo::after {
            background-color: #81c784;
        }
        #confirmDeleteYes:hover,
        #confirmDeleteNo:hover { filter: brightness(0.95); }
        #confirmDeleteYes:disabled,
        #confirmDeleteNo:disabled { filter: brightness(0.6); cursor: not-allowed; }

        /* --- Estilo de botones para selección de niveles en modo laberinto --- */
        .maze-level-button {
          width: 100px;
          height: 100px;
          background-image: url('https://i.imgur.com/XVbQCVX.png');
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center;
          position: relative;
          cursor: pointer;
          transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .maze-level-button:hover {
          filter: brightness(0.95);
        }

        .maze-level-button.icon-button-pressed {
          filter: brightness(0.5);
        }

        .maze-level-button.disabled {
          pointer-events: none;
          opacity: 0.7;
          filter: grayscale(100%);
        }

        /* --- Estilo de botones para selección de mundos en modo aventura --- */
        .world-button {
          width: 150px;
          height: 150px;
          background-image: url('https://i.imgur.com/8Gp9hfW.png');
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center;
          position: relative;
          cursor: pointer;
          transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .world-button:hover { filter: brightness(0.95); }
        .world-button.icon-button-pressed { filter: brightness(0.5); }
        .world-button.disabled {
          pointer-events: none;
          opacity: 0.7;
          filter: grayscale(100%);
        }

        /* --- Estilo de celdas de la tienda --- */
        .store-item {
          width: 100%;
          aspect-ratio: 1 / 1;
          position: relative;
          cursor: pointer;
          transition: transform 0.05s ease-out;
        }

        .store-item::before {
          content: '';
          position: absolute;
          inset: 0;
          background-image: url('https://i.imgur.com/NNbtyMH.png');
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center;
          transition: filter 0.05s ease-out;
          pointer-events: none;
        }
        .store-item.scene-item::before {
          background-image: url('https://i.imgur.com/YKjPhxX.png');
          z-index: 1;
        }
        .store-item:hover::before { filter: brightness(0.95); }
        .store-item.icon-button-pressed::before { filter: brightness(0.5); }
        .store-item.locked {
          /* keep text sharp while dimming the icon */
        }
        .store-item.locked::before {
          filter: grayscale(100%);
          opacity: 0.7;
        }
        .store-item.locked .store-item-img {
          filter: grayscale(100%);
          opacity: 0.7;
        }
        .store-item.purchased {
          pointer-events: none;
        }
        .profile-clickable {
          pointer-events: auto !important;
          cursor: pointer;
        }
        .store-item-img {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 60%;
          height: 60%;
          object-fit: contain;
          pointer-events: none;
        }
        .scene-item .store-item-img {
          z-index: 0;
        }
        .store-item-img.scene-img-full {
          width: 90%;
          height: 90%;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          object-fit: cover;
        }
        .store-item-status {
          position: absolute;
          bottom: 16px;
          left: 0;
          right: 0;
          text-align: center;
          font-size: 0.7rem;
          color: #C084FC;
          text-shadow: 1px 1px 2px black;
          font-family: 'Press Start 2P', sans-serif;
        }

        .store-tab {
          font-family: 'Press Start 2P', sans-serif;
          font-size: 0.7rem;
          padding: 4px 6px;
          border: 2px solid #8f66af;
          border-radius: 6px;
          background-color: #1F2937;
          color: #C084FC;
        }

        .store-tab.active {
          background-color: #8f66af;
          color: #1F2937;
        }

        #purchase-item-preview {
          margin: 0 auto 8px;
        }
        #purchase-item-preview.store-item {
          width: 140px;
          height: 140px;
        }

        #mazeLevelButtonsContainer.disabled {
          pointer-events: none;
          opacity: 0.7;
        }

        #worldButtonsContainer.disabled {
          pointer-events: none;
          opacity: 0.7;
        }

        .maze-level-number {
          position: absolute;
          top: 42%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 1.4rem;
          color: #C084FC;
          text-shadow: 1px 1px 2px black;
          font-family: 'Press Start 2P', sans-serif;
        }

        .maze-stars {
          position: absolute;
          bottom: 11px;
          left: 0;
          right: 0;
          display: flex;
          justify-content: center;
          gap: 2px;
        }

        .world-button .maze-stars {
          bottom: 11px;
          gap: 5px;
        }

        .maze-stars .star {
          width: 14px;
          height: 14px;
          background-size: cover;
        }

        .world-button .maze-stars .star {
          width: 18px;
          height: 18px;
        }

        .maze-stars .star.full {
          background-image: url('https://i.imgur.com/mJU2iIm.png');
        }

        .maze-stars .star.empty {
          background-image: url('https://i.imgur.com/M4FDVgp.png');
        }

        @media screen and (min-width: 800px) {
            #splash-content { padding: 0px 0; }
            #splash-top-image { max-height: 50vh; }
            #splash-start-button {
                max-height: 20vh;
            }
            #splash-info-button, #splash-settings-button {
                max-height: 12vh;
            }
            #splash-bottom-image {
                max-height: 100vh;
                padding-top: 30px;
                padding-bottom: 20px;
            }
            #out-of-lives-panel .out-of-lives-heart {
                max-width: 220px;
            }
        }

        /* Toast message for insufficient funds */
        #insufficient-funds-toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 4px;
            font-size: 0.85em;
            color: #ffffff;
            pointer-events: none;
            z-index: 2205;
            opacity: 0;
            transition: opacity 0.3s ease;

            /* Visual style matching the progress stars panel */
            border: 2px solid #2B1D3A;
            border-radius: 10px;
            box-shadow: 0 2px 0 #422E58;
            box-sizing: border-box;
        }

        #insufficient-funds-toast::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                #D3BAE8 0%,
                #D3BAE8 50%,
                #583F7D 50%,
                #583F7D 100%
            );
            border-radius: 10px;
            pointer-events: none;
            z-index: -2;
        }

        #insufficient-funds-toast::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 90%;
            background-color: #8C64AF;
            border-radius: 10px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: -1;
        }

        #insufficient-funds-toast .value-box {
            background-color: #422E58;
            border-radius: 8px;
            padding: 6px 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #insufficient-funds-toast.show {
            opacity: 1;
        }

    </style>
</head>
<body>
        <div id="splash-screen">
            <div id="splash-content">
                <img id="splash-top-image" src="https://i.imgur.com/ao3aUtk.png" alt="Logotipo superior del splash" onerror="this.src='https://placehold.co/600x200/02030D/FFFFFF?text=Splash+Top+Error'; console.error('Error loading splash-top-image');">
                <div id="splash-button-row">
                    <img id="splash-info-button" src="https://i.imgur.com/rWe7Ylp.png" alt="Información inicial" onerror="this.src='https://placehold.co/80x80/02030D/FFFFFF?text=Info+Error'; console.error('Error loading splash-info-button');">
                    <img id="splash-start-button" src="https://i.imgur.com/HqNpn3w.png" alt="Botón de iniciar juego" onerror="this.src='https://placehold.co/300x100/02030D/FFFFFF?text=Start+Error'; console.error('Error loading splash-start-button');">
                    <img id="splash-settings-button" src="https://i.imgur.com/YIBroBG.png" alt="Ajustes generales" onerror="this.src='https://placehold.co/80x80/02030D/FFFFFF?text=Settings+Error'; console.error('Error loading splash-settings-button');">
                </div>
                <img id="splash-bottom-image" src="https://i.imgur.com/YJ1xHZO.png" alt="Imagen inferior del splash" onerror="this.src='https://placehold.co/600x150/02030D/FFFFFF?text=Splash+Bottom+Error'; console.error('Error loading splash-bottom-image');">
            </div>
        </div>

    <div class="game-container hidden">
        <div id="title-panel" class="hidden"><img id="title-image" src="https://i.imgur.com/CZa88Hk.png" alt="Snake Mobile" onerror="this.src='https://placehold.co/300x80/02030D/FFFFFF?text=Title+Error'; console.error('Error loading title-image');"></div>
        <div id="progress-panel" class="hidden">
            <div id="current-world-info-group">
                <span id="progress-panel-left-label" class="info-label">Nivel:</span>
                <span id="progress-panel-left-value" class="info-value">1</span>
            </div>
            <div id="progress-lives-info-group" class="panel-card hidden">
                <div class="info-group">
                    <div class="info-icon-wrapper">
                        <img src="https://i.imgur.com/WrI2XXx.png" alt="Vidas" class="info-icon">
                        <span id="progressLivesValue" class="life-number">5</span>
                    </div>
                    <div class="value-box">
                        <span id="progressLifeTimerValue" class="info-value">Lleno</span>
                    </div>
                </div>
            </div>
            <div id="star-progress-wrapper" class="panel-card">
                <div id="star-progress-container" class="value-box hidden">
                </div>
                <div id="high-score-display" class="info-group hidden">
                    <div class="info-icon-wrapper">
                        <img src="https://i.imgur.com/COqXj9s.png" alt="Puntos" class="info-icon">
                        <span id="hs-max-label" class="max-label">MAX</span>
                    </div>
                    <div class="value-box">
                        <div id="hs-values-container">
                            <span id="hs-score-value" class="hs-value">-</span>
                            <span class="hs-label-unit">Puntos</span>
                            <span class="hs-separator hs-value">|</span>
                            <span id="hs-skin-value" class="hs-value">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="play-area">

        <div id="selector-info-bar" class="hidden">
            <div id="selector-coins-info" class="info-group">
                <div class="info-icon-wrapper">
                    <img src="https://i.imgur.com/lnc1Mwu.png" alt="Monedas" class="info-icon">
                </div>
                <div class="value-box">
                    <span id="selectorCoinValue" class="info-value">0</span>
                </div>
            </div>
            <div id="selector-lives-info" class="info-group">
                <div class="info-icon-wrapper">
                    <img src="https://i.imgur.com/WrI2XXx.png" alt="Vidas" class="info-icon">
                    <span id="selectorLivesValue" class="life-number">5</span>
                </div>
                <div class="value-box">
                    <span id="selectorLifeTimerValue" class="info-value">Lleno</span>
                </div>
            </div>
            <div id="selector-gems-info" class="info-group">
                <div class="info-icon-wrapper">
                    <img src="https://i.imgur.com/gPGsaCO.png" alt="Gemas" class="info-icon">
                </div>
                <div class="value-box">
                    <span id="selectorGemsValue" class="info-value">0</span>
                </div>
            </div>
        </div>

        <div id="top-info-bar">
            <div id="coins-info-group" class="info-group">
                <div class="info-icon-wrapper">
                    <img src="https://i.imgur.com/lnc1Mwu.png" alt="Monedas" class="info-icon">
                </div>
                <div class="value-box">
                    <span id="coinValue" class="info-value">0</span>
                    <span id="earnedCoinsMessage" class="earned-coins-msg hidden">+0</span>
                </div>
            </div>
            <div id="points-info-group" class="info-group">
                <div class="info-icon-wrapper">
                    <img id="points-icon-img" src="https://i.imgur.com/COqXj9s.png" alt="Puntos" class="info-icon">
                    <span id="livesValue" class="life-number hidden">5</span>
                </div>
                <div class="value-box">
                    <span id="lifeTimerValue" class="info-value hidden">Lleno</span>
                    <span id="scoreValue" class="info-value">0</span><span id="target-score-divider" class="info-value mx-1 hidden">/</span><span id="targetScoreValue" class="info-value hidden">0</span>
                </div>
            </div>
            <div id="time-info-group" class="info-group">
                <div class="info-icon-wrapper">
                    <img src="https://i.imgur.com/s0pteDj.png" alt="Tiempo" class="info-icon">
                </div>
                <div class="value-box">
                    <span id="timeLengthLabel" class="info-label hidden">Tiempo:</span>
                    <span id="timeLengthValue" class="info-value">60</span>
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        <button id="mode-left-button" class="mode-nav-button hidden" aria-label="Modo anterior">
            <img id="mode-left-button-icon" class="arrow-icon" src="https://i.imgur.com/pDjzolV.png" alt="Anterior" onerror="this.src='https://placehold.co/50x50/02030D/FFFFFF?text=Err';">
        </button>
        <button id="mode-right-button" class="mode-nav-button hidden" aria-label="Modo siguiente">
            <img id="mode-right-button-icon" class="arrow-icon" src="https://i.imgur.com/kwtquW9.png" alt="Siguiente" onerror="this.src='https://placehold.co/50x50/02030D/FFFFFF?text=Err';">
        </button>

        <div id="setup-controls"> 
        <div id="settings-panel" class="settings-panel-hidden">
                <div class="settings-header">
                    <div class="header-title-group">
                        <h2 id="settings-title">CONFIGURACION</h2>
                        <button id="maze-info-button" class="setting-info-button hidden" data-setting="mazeLevel" aria-label="Información del modo laberinto">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                        <button id="world-info-button" class="setting-info-button hidden" aria-label="Información del mundo">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                        <button id="classification-info-button" class="setting-info-button hidden" aria-label="Información del modo clasificación" data-setting="difficulty">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <button id="close-settings-button" class="close-button" aria-label="Cerrar configuración">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div class="panel-content">
                <div id="worldButtonsContainer" class="hidden flex flex-wrap justify-center gap-4"></div>
                <div id="mazeLevelButtonsContainer" class="hidden flex flex-wrap justify-center gap-4"></div>
                <div class="control-row" id="classification-select-row">
                    <div class="control-group" id="player-name-control-group">
                        <div class="control-label-icon-row">
                            <label class="control-label" for="playerNameSelector">Jugador:</label>
                            <button id="player-name-info-button" class="setting-info-button" data-setting="playerName" aria-label="Información sobre nombre del jugador">
                                <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                            </button>
                        </div>
                        <select id="playerNameSelector"></select>
                    </div>
                    <div class="control-group" id="difficulty-control-group">
                        <div class="control-label-icon-row">
                            <label class="control-label" id="difficulty-label" for="difficultySelector">Dificultad:</label>
                            <button id="difficulty-info-button" class="setting-info-button" data-setting="difficulty" aria-label="Información sobre dificultad">
                                <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                            </button>
                        </div>
                        <select id="difficultySelector">
                            <option value="principiante" selected>Novato</option>
                            <option value="explorador">Explorador</option>
                            <option value="veterano">Veterano</option>
                            <option value="legendario">Legendario</option>
                        </select>
                        <select id="worldsSelector" class="hidden">
                        </select>
                    </div>
                </div>
                <div class="control-group hidden" id="classification-ranking-group">
                    <table id="classification-ranking-table">
                        <thead>
                            <tr class="title-row">
                                <th colspan="4">CLASIFICACION</th>
                            </tr>
                            <tr>
                                <th>Nº</th>
                                <th>PUNTOS</th>
                                <th>TIEMPO</th>
                                <th>JUGADOR</th>
                            </tr>
                        </thead>
                        <tbody id="classification-ranking-list"></tbody>
                    </table>
                </div>

                <div class="control-group" id="skin-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="skinSelector">Disfraz:</label>
                        <button class="setting-info-button" data-setting="skin" aria-label="Información sobre disfraces">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="skinSelector">
                        <option value="snake" selected>Snake</option>
                        <option value="rubiSnake">RubiSnake</option>
                        <option value="aitorSnake">AitorSnake</option>
                        <option value="noemiSnake">NoemiSnake</option>
                        <option value="maraSnake">MaraSnake</option>
                        <option value="almuSnake">AlmuSnake</option>
                        <option value="mimiSnake">MimiSnake</option>
                        <option value="blackCat">Gato Negro</option>
                        <option value="orangeCat">Gato Naranja</option>
                    </select>
                </div>
                <div class="control-group" id="food-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="foodSelector">Comestible:</label>
                        <button class="setting-info-button" data-setting="food" aria-label="Información sobre comestibles">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="foodSelector"></select>
                </div>
                <div class="control-group" id="audio-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="audioToggleSelector">Audio General:</label>
                        <button class="setting-info-button" data-setting="audioGeneral" aria-label="Información sobre audio general">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="audioToggleSelector">
                        <option value="all" selected>Activado</option>
                        <option value="music_only">Sólo Música</option>
                        <option value="sfx_only">Sólo Efectos</option>
                        <option value="off">Desactivado</option>
                    </select>
                </div>
                <div class="control-group" id="music-volume-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="musicVolumeSlider">Volumen Musica: <span id="musicVolumeValue">50</span>%</label>
                        <button class="setting-info-button" data-setting="musicVolume" aria-label="Información sobre volumen de música">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <input type="range" id="musicVolumeSlider" min="0" max="100" value="50">
                </div>
                <div class="control-group" id="sfx-volume-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="sfxVolumeSlider">Volumen Efectos: <span id="sfxVolumeValue">75</span>%</label>
                        <button class="setting-info-button" data-setting="sfxVolume" aria-label="Información sobre volumen de efectos">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <input type="range" id="sfxVolumeSlider" min="0" max="100" value="75">
                </div>
                <div class="control-group" id="resetDataButton">REINICIAR DATOS</div>
                </div>
            </div>

            <div id="free-settings-panel" class="free-settings-panel-hidden">
                <div class="settings-header">
                    <div class="header-title-group">
                        <h2>PERSONALIZA TU JUEGO</h2>
                        <button id="free-mode-info-button" class="setting-info-button" data-setting="freeDifficulty" aria-label="Información sobre modo libre">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <button id="close-free-settings-button" class="close-button" aria-label="Cerrar ajustes">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div class="panel-content">
                <div class="control-group" id="free-difficulty-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="free-difficulty-selector">Configuración:</label>
                        <button id="free-difficulty-info-button" class="setting-info-button" data-setting="freeDifficulty" aria-label="Información sobre dificultad libre">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="free-difficulty-selector">
                        <option value="personalizado" selected>Personalizado</option>
                        <option value="principiante">Novato</option>
                        <option value="explorador">Explorador</option>
                        <option value="veterano">Veterano</option>
                        <option value="legendario">Legendario</option>
                    </select>
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="playerNameSelector">Jugador:</label>
                        <button class="setting-info-button" data-setting="playerName" aria-label="Información sobre nombre del jugador">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="playerNameSelector"></select>
                </div>
                <div class="control-group">
                    <label class="control-label" for="free-speed-input">Velocidad: <span id="free-speed-value">67</span>%</label>
                    <input type="range" class="settings-range" id="free-speed-input" min="0" max="100" step="5" value="67">
                </div>
                <div class="control-group">
                    <label class="control-label" for="free-length-input">Tamaño inicial: <span id="free-length-value">10</span></label>
                    <input type="range" class="settings-range" id="free-length-input" min="3" max="50" value="10">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Comida dorada (x2)</label>
                        <label class="switch"><input type="checkbox" id="free-golden-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-golden-chance-input">Probabilidad: <span id="free-golden-chance-value">10</span>%</label>
                    <input type="range" class="settings-range" id="free-golden-chance-input" min="5" max="100" step="5" value="10">
                    <label class="control-label" for="free-golden-lifespan-input">Duración(s): <span id="free-golden-lifespan-value">4</span></label>
                    <input type="range" class="settings-range" id="free-golden-lifespan-input" min="4" max="8" step="0.5" value="4">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Rayos (+Velocidad)</label>
                        <label class="switch"><input type="checkbox" id="free-lightning-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-lightning-range">Intervalo(s): <span id="free-lightning-range-display">4 - 8</span></label>
                    <input type="range" class="settings-range" id="free-lightning-range" min="0" max="16" step="0.5" value="4">
                    <label class="control-label" for="free-lightning-lifespan">Duración(s): <span id="free-lightning-lifespan-value">5</span></label>
                    <input type="range" class="settings-range" id="free-lightning-lifespan" min="4" max="10" step="0.5" value="5">
                    <label class="control-label" for="free-red-chance">Probabilidad SuperRayo: <span id="free-red-chance-value">25</span>%</label>
                    <input type="range" class="settings-range" id="free-red-chance" min="0" max="100" step="5" value="25">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Desaparición comida</label>
                        <label class="switch"><input type="checkbox" id="free-lifespan-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-lifespan-input">Tiempo(s): <span id="free-lifespan-value">7.5</span></label>
                    <input type="range" class="settings-range" id="free-lifespan-input" min="4" max="8" step="0.5" value="7.5">
                </div>
                <div class="control-group" id="streak-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Racha (x1 - x5)</label>
                        <label class="switch"><input type="checkbox" id="free-streak-toggle" checked><span class="slider round"></span></label>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Comida falsa</label>
                        <label class="switch"><input type="checkbox" id="free-false-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-false-range">Intervalo(s): <span id="free-false-range-display">4 - 8</span></label>
                    <input type="range" class="settings-range" id="free-false-range" min="0" max="16" step="0.5" value="4">
                    <label class="control-label" for="free-false-lifespan">Duración(s): <span id="free-false-lifespan-value">5</span></label>
                    <input type="range" class="settings-range" id="free-false-lifespan" min="4" max="10" step="0.5" value="5">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Espejos</label>
                        <label class="switch"><input type="checkbox" id="free-mirror-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-mirror-range">Intervalo(s): <span id="free-mirror-range-display">4 - 8</span></label>
                    <input type="range" class="settings-range" id="free-mirror-range" min="0" max="16" step="0.5" value="4">
                    <label class="control-label" for="free-mirror-lifespan">Duración(s): <span id="free-mirror-lifespan-value">5</span></label>
                    <input type="range" class="settings-range" id="free-mirror-lifespan" min="4" max="10" step="0.5" value="5">
                    <label class="control-label" for="free-mirror-effect">Duración efecto(s): <span id="free-mirror-effect-value">3</span></label>
                    <input type="range" class="settings-range" id="free-mirror-effect" min="3" max="10" step="0.5" value="3">
                </div>
                <div class="control-group">
                    <label class="control-label" for="free-obstacle-count">Obstáculos: <span id="free-obstacle-count-value">5</span></label>
                    <input type="range" class="settings-range" id="free-obstacle-count" min="0" max="50" value="5">
                </div>
                <div class="control-group" id="apply-free-settings-bottom">Guardar</div>
                </div>
            </div>

            <div id="info-panel" class="info-panel-hidden">
                <div class="info-header">
                    <h2 id="main-info-title">INFORMACION</h2>
                    <button id="close-info-button" class="close-button" aria-label="Cerrar información">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div id="info-panel-content">
                    <p>¡Prepárate para la clásica diversión de la serpiente con un toque moderno y desafiante!¡Cada partida es una nueva oportunidad para superarte!</p>

                    <h4>Cómo Jugar</h4>
                    <p>Tan fácil como utilizar los controles en pantalla (En PC las flechas de dirección o "WASD") para guiar a tu serpiente. Devora comida, crece lo máximo posible, suma puntos y acumula monedas que te permitirán desbloquear increíbles recompensas. ¡Pero cuidado! No choques contra tu propio cuerpo o la partida terminará. </p>

                    <h4>Tipos de juego</h4>
                    <p>Accede a la pantalla principal para conocer los diferentes tipos de juego: <strong>Aventura</strong>, <strong>Laberinto</strong>, <strong>Clasificación</strong> y <strong>Libre</strong>. Para más información, puedes pulsar sobre los iconos que te irás encontrando durante el juego.</p>
                    <p style="text-align: center; margin-top: 6px;"><strong>¡Diviértete y que crezca la serpiente!</strong></p>
                </div>
            </div>

            <div id="specific-info-panel" class="specific-info-panel-hidden">
                <div class="specific-info-header">
                    <h2 id="specific-info-title">DETALLE DEL AJUSTE</h2>
                    <button id="close-specific-info-button" class="close-button" aria-label="Cerrar detalle">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div id="specific-info-content">
                 </div>
            </div>
            <div id="reset-confirmation-panel" class="reset-panel-hidden">
                <div class="reset-header">
                    <h2>REINICIAR</h2>
                </div>
                <div class="panel-content">
                    <p>Esta decisión eliminará todos tus progresos y puntuaciones</p>
                    <p>¿Estás seguro de que deseas eliminar todos los datos del juego?</p>
                    <div class="reset-buttons">
                        <button id="confirmResetYes">Sí</button>
                        <button id="confirmResetNo">No</button>
                    </div>
                </div>
            </div>
            <div id="config-menu-panel" class="config-menu-panel-hidden">
                <div class="settings-header">
                    <h2>MENU</h2>
                    <button id="close-config-menu-button" class="close-button" aria-label="Cerrar menú">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div class="panel-content">
                    <button class="menu-option-button" id="profile-menu-button">PERFIL</button>
                    <button class="menu-option-button" id="store-menu-button">TIENDA</button>
                    <button class="menu-option-button" id="achievements-menu-button">LOGROS</button>
                    <button class="menu-option-button" id="bonuses-menu-button">BONIFICACIONES</button>
                    <button class="menu-option-button" id="daily-menu-button">PREMIOS DIARIOS</button>
                    <button class="menu-option-button" id="wheel-menu-button">RULETA DE PREMIOS</button>
                </div>
            </div>
            <div id="generic-menu-panel" class="generic-menu-panel-hidden">
                <div class="settings-header">
                    <h2 id="generic-menu-title"></h2>
                    <button id="close-generic-menu-button" class="close-button" aria-label="Cerrar">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div class="panel-content">
                    <p>Contenido no disponible todavía</p>
                </div>
            </div>
<div id="profile-panel" class="profile-panel-hidden">
    <div class="settings-header">
        <div class="header-title-group">
            <h2>PERFIL</h2>
            <button id="profile-info-button" class="setting-info-button" aria-label="Información sobre perfil">
                <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
            </button>
        </div>
        <button id="close-profile-panel" class="close-button" aria-label="Cerrar">
            <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
        </button>
    </div>
    <div class="panel-content">
        <div id="profile-tabs" class="flex justify-center gap-2 mb-2">
            <button data-tab="general" id="profile-tab-general" class="store-tab active">PERFIL</button>
            <button data-tab="comida" id="profile-tab-comida" class="store-tab">COMIDA</button>
            <button data-tab="disfraces" id="profile-tab-disfraces" class="store-tab">DISFRACES</button>
            <button data-tab="escenarios" id="profile-tab-escenarios" class="store-tab">ESCENARIOS</button>
        </div>

        <div id="profile-general-content">
        <div class="control-row" id="player-manage-row">
            <div class="control-group" id="player-select-control-group">
                <div class="control-label-icon-row">
                    <label class="control-label" for="playerNameSelector">Jugador:</label>
                    <button id="delete-player-name-button" class="setting-info-button" aria-label="Eliminar jugador">
                        <img class="setting-info-icon" src="https://i.imgur.com/w5E6xdU.png" alt="Eliminar" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                    </button>
                </div>
                <select id="playerNameSelector"></select>
            </div>
            <div class="control-group hidden" id="add-player-control-group">
                <div class="control-label-icon-row">
                    <label class="control-label" for="newPlayerNameInput">Añadir</label>
                    <button id="confirm-add-player-button" class="setting-info-button" aria-label="Confirmar nuevo jugador">
                        <img class="setting-info-icon" src="https://i.imgur.com/ZGgSVye.png" alt="Añadir" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                    </button>
                </div>
                <input type="text" id="newPlayerNameInput" maxlength="10">
            </div>
        </div>
        <div id="selected-items-row" class="grid grid-cols-3 gap-2 mb-2 mt-2 w-full">
            <div id="selected-skin-item" class="store-item"></div>
            <div id="selected-food-item" class="store-item"></div>
            <div id="selected-scene-item" class="store-item scene-item"></div>
        </div>

        <div class="control-group hidden" id="skin-control-group">
            <div class="control-label-icon-row">
                <label class="control-label" for="skinSelector">Disfraz:</label>
                <button class="setting-info-button" data-setting="skin" aria-label="Información sobre disfraces">
                    <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                </button>
            </div>
            <select id="skinSelector">
                <option value="snake" selected>Snake</option>
                <option value="rubiSnake">RubiSnake</option>
                <option value="aitorSnake">AitorSnake</option>
                <option value="noemiSnake">NoemiSnake</option>
                <option value="maraSnake">MaraSnake</option>
                <option value="almuSnake">AlmuSnake</option>
                <option value="mimiSnake">MimiSnake</option>
                <option value="blackCat">Gato Negro</option>
                <option value="orangeCat">Gato Naranja</option>
            </select>
        </div>
        <div class="control-group hidden" id="food-control-group">
            <div class="control-label-icon-row">
                <label class="control-label" for="foodSelector">Comestible:</label>
                <button class="setting-info-button" data-setting="food" aria-label="Información sobre comestibles">
                    <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                </button>
            </div>
            <select id="foodSelector"></select>
        </div>
        <div class="control-group hidden" id="scene-control-group">
            <div class="control-label-icon-row">
                <label class="control-label" for="sceneSelector">Escenario:</label>
                <button class="setting-info-button" data-setting="scene" aria-label="Información sobre escenarios">
                    <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                </button>
            </div>
            <select id="sceneSelector"></select>
        </div>
        </div> <!-- end general content -->

        <div id="profile-food-content" class="hidden">
            <h4>COLECCION</h4>
            <div id="profile-food-unlocked" class="grid grid-cols-3 gap-4 w-full mb-2"></div>
            <h4>SIN DESBLOQUEAR</h4>
            <div id="profile-food-locked" class="grid grid-cols-3 gap-4 w-full"></div>
        </div>

        <div id="profile-skin-content" class="hidden">
            <h4>COLECCION</h4>
            <div id="profile-skin-unlocked" class="grid grid-cols-3 gap-4 w-full mb-2"></div>
            <h4>SIN DESBLOQUEAR</h4>
            <div id="profile-skin-locked" class="grid grid-cols-3 gap-4 w-full"></div>
        </div>

        <div id="profile-scene-content" class="hidden">
            <h4>COLECCION</h4>
            <div id="profile-scene-unlocked" class="grid grid-cols-3 gap-4 w-full mb-2"></div>
            <h4>SIN DESBLOQUEAR</h4>
            <div id="profile-scene-locked" class="grid grid-cols-3 gap-4 w-full"></div>
        </div>

    </div>
</div>
</div>
            <div id="store-panel" class="store-panel-hidden">
                <div class="settings-header">
                    <h2>TIENDA</h2>
                    <button id="close-store-panel" class="close-button" aria-label="Cerrar">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div class="panel-content">
                    <div id="store-tabs" class="flex justify-center gap-2 mb-2">
                        <button data-tab="general" id="store-tab-general" class="store-tab active">GENERAL</button>
                        <button data-tab="comida" id="store-tab-comida" class="store-tab">COMIDA</button>
                        <button data-tab="disfraces" id="store-tab-disfraces" class="store-tab">DISFRACES</button>
                        <button data-tab="escenarios" id="store-tab-escenarios" class="store-tab">ESCENARIOS</button>
                    </div>
                    <div id="store-items-container" class="grid grid-cols-3 gap-4 w-full"></div>
                </div>
            </div>
            <div id="modal-overlay" class="hidden"></div>
            <div id="purchase-confirmation-panel" class="purchase-confirmation-panel-hidden">
                <div class="reset-header">
                    <h2>CONFIRMAR COMPRA</h2>
                </div>
                <div class="panel-content">
                    <div id="purchase-item-preview" class="store-item locked"></div>
                    <p id="purchase-confirmation-text">¿Comprar por <strong>0</strong> monedas?</p>
                    <div class="reset-buttons">
                        <button id="confirmPurchaseYes">SI</button>
                        <button id="confirmPurchaseNo">NO</button>
                    </div>
                </div>
            </div>

            <div id="delete-confirmation-panel" class="delete-confirmation-panel-hidden">
                <div class="panel-content">
                    <p id="delete-confirmation-text">¿Eliminar jugador?</p>
                    <div class="reset-buttons">
                        <button id="confirmDeleteYes">SI</button>
                        <button id="confirmDeleteNo">NO</button>
                    </div>
                </div>
            </div>

            <div id="select-confirmation-panel" class="select-confirmation-panel-hidden">
                <div class="panel-content">
                    <p id="select-confirmation-text"></p>
                    <div class="reset-buttons">
                        <button id="confirmSelectYes">SI</button>
                        <button id="confirmSelectNo">NO</button>
                    </div>
                </div>
            </div>

            <div id="insufficient-funds-toast" class="panel-card hidden">
                <div class="value-box">Monedas insuficientes</div>
            </div>

            <div id="out-of-lives-panel" class="out-of-lives-panel-hidden">
                <div class="settings-header">
                    <button id="close-out-of-lives-panel" class="close-button" aria-label="Cerrar">
                        <img src="https://i.imgur.com/w5E6xdU.png" alt="Cerrar">
                    </button>
                </div>
                <div class="panel-content">
                    <p>¡Te has quedado sin vidas!</p>
                    <img src="https://i.imgur.com/SKWBRG7.png" alt="Corazón roto" class="mx-auto out-of-lives-heart">
                    <p>¿Quieres conseguir más?</p>
                    <div class="reset-buttons">
                        <img id="get-lives-store-button" class="get-lives-button" src="https://i.imgur.com/9HHOgFe.png" alt="Tienda">
                        <img id="get-lives-bonuses-button" class="get-lives-button" src="https://i.imgur.com/3dvvN2k.png" alt="Bonificaciones">
                    </div>
                </div>
            </div>

            <div class="control-row" id="action-buttons-row">
                    <button id="backButton" aria-label="Volver">
                        <img id="backButtonIcon" src="https://i.imgur.com/1WrBpTQ.png" alt="Volver" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                    </button>
                <div class="action-button-wrapper" id="start-button-wrapper">
                    <button id="startButton">Empezar</button>
                    <button id="restartMazeButton" class="hidden" aria-label="REINICIAR">
                        <img id="restartMazeButtonIcon" src="https://i.imgur.com/i4m4tSV.png" alt="REINICIAR"
                             onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                    </button>
                </div>
                <button id="configButton" aria-label="Configuración">
                    <img id="configButtonIcon" src="https://i.imgur.com/jekDmyV.png" alt="Configuración" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                </button>
            </div>
        </div>
        <div id="mobile-controls">
            <div id="d-pad-container">
                <button id="up-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
                </button>
                <button id="left-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M15.41 7.41L10.83 12l4.58 4.59L14 18l-6-6 6-6z"/></svg>
                </button>
                <button id="right-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                </button>
                <button id="down-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </button>
            </div>
        </div>

        </div>

    <script>
        // Helper function to adjust hex color by a percentage (lighten)
        function adjustColor(hex, percent) {
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);

            // Add white (lighten)
            r = Math.round(r + (255 - r) * percent);
            g = Math.round(g + (255 - g) * percent);
            b = Math.round(b + (255 - b) * percent);

            r = Math.min(255, Math.max(0, r));
            g = Math.min(255, Math.max(0, g));
            b = Math.min(255, Math.max(0, b));

            const toHex = (c) => {
                const hexVal = c.toString(16);
                return hexVal.length === 1 ? "0" + hexVal : hexVal;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // Draws an image tinted with a given color onto the main context
        function drawImageWithTint(ctx, img, x, y, w, h, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tctx = tempCanvas.getContext('2d');
            tctx.drawImage(img, 0, 0, w, h);
            tctx.globalCompositeOperation = 'source-atop';
            tctx.fillStyle = color;
            tctx.fillRect(0, 0, w, h);
            tctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(tempCanvas, x, y);
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Normalize the difference between two coordinates when the snake wraps
        // around the grid so that it is always -1, 0 or 1. This ensures texture
        // orientation behaves correctly near the canvas edges.
        function normalizedDiff(a, b, max) {
            let diff = a - b;
            if (diff === max - 1) return -1;
            if (diff === -(max - 1)) return 1;
            if (diff > 1) return -1;
            if (diff < -1) return 1;
            return diff;
        }

        // Selección de elementos del DOM
        const splashScreen = document.getElementById("splash-screen"); 
        const canvasEl = document.getElementById("gameCanvas"); 
        let ctx; 
        const gameContainer = document.querySelector('.game-container'); 
        const coinValueDisplay = document.getElementById("coinValue");
        const selectorCoinValueDisplay = document.getElementById("selectorCoinValue");
        const earnedCoinsMessage = document.getElementById("earnedCoinsMessage");
        const scoreValueDisplay = document.getElementById("scoreValue");
        const livesValueDisplay = document.getElementById("livesValue");
        const pointsIconImg = document.getElementById("points-icon-img");
        const selectorLivesValueDisplay = document.getElementById("selectorLivesValue");
        const lifeTimerValueDisplay = document.getElementById("lifeTimerValue");
        const selectorLifeTimerValueDisplay = document.getElementById("selectorLifeTimerValue");
        const selectorGemsValueDisplay = document.getElementById("selectorGemsValue");
        const targetScoreDivider = document.getElementById("target-score-divider");
        const targetScoreValueDisplay = document.getElementById("targetScoreValue");
        const timeLengthLabelEl = document.getElementById("timeLengthLabel");
        const timeLengthValueEl = document.getElementById("timeLengthValue");
        const startButton = document.getElementById("startButton");
        const restartMazeButton = document.getElementById("restartMazeButton");
        const restartMazeButtonIcon = document.getElementById("restartMazeButtonIcon");
        const startButtonWrapperEl = document.getElementById("start-button-wrapper");
        const difficultySelector = document.getElementById("difficultySelector");
        const worldsSelector = document.getElementById("worldsSelector");
        const worldButtonsContainer = document.getElementById("worldButtonsContainer");
        const mazeLevelButtonsContainer = document.getElementById("mazeLevelButtonsContainer");
        const difficultyLabel = document.getElementById("difficulty-label");
        const settingsTitle = document.getElementById("settings-title");
        const audioToggleSelector = document.getElementById("audioToggleSelector");
        const skinSelectors = document.querySelectorAll("#skinSelector");
        const foodSelectors = document.querySelectorAll("#foodSelector");
        const sceneSelectors = document.querySelectorAll("#sceneSelector");
        const playerNameSelectors = document.querySelectorAll("#playerNameSelector");
        const confirmAddPlayerButton = document.getElementById("confirm-add-player-button");
        const deletePlayerNameButton = document.getElementById("delete-player-name-button");
        const newPlayerNameInput = document.getElementById("newPlayerNameInput");
        const playerSelectControlGroup = document.getElementById("player-select-control-group");
        const playerNameControlGroup = document.getElementById("player-name-control-group");
        const addPlayerControlGroup = document.getElementById("add-player-control-group");
        const difficultyControlGroup = document.getElementById("difficulty-control-group");
        const audioControlGroup = document.getElementById("audio-control-group");
        const skinControlGroups = document.querySelectorAll("#skin-control-group");
        const foodControlGroups = document.querySelectorAll("#food-control-group");
        const sceneControlGroups = document.querySelectorAll("#scene-control-group");
        const sfxVolumeSlider = document.getElementById("sfxVolumeSlider");
        const sfxVolumeValue = document.getElementById("sfxVolumeValue");
        const sfxVolumeControlGroup = document.getElementById("sfx-volume-control-group");
        const musicVolumeSlider = document.getElementById("musicVolumeSlider");
        const musicVolumeValue = document.getElementById("musicVolumeValue");
        const musicVolumeControlGroup = document.getElementById("music-volume-control-group");
        const classificationRankingGroup = document.getElementById("classification-ranking-group");
        const classificationRankingList = document.getElementById("classification-ranking-list");

        const difficultyInfoButton = document.getElementById("difficulty-info-button");
        const worldInfoButton = document.getElementById("world-info-button");
        if (worldInfoButton) worldInfoButton.removeAttribute('data-setting');
        const mazeInfoButton = document.getElementById("maze-info-button");
        const classificationInfoButton = document.getElementById("classification-info-button");
        const freeModeInfoButton = document.getElementById("free-mode-info-button");
        const profileInfoButton = document.getElementById("profile-info-button");
        if (profileInfoButton) profileInfoButton.removeAttribute('data-setting');
        const playerNameInfoButton = document.getElementById("player-name-info-button");
        
        const progressPanel = document.getElementById("progress-panel");
        const titlePanel = document.getElementById("title-panel"); 
        const progressPanelLeftLabel = document.getElementById("progress-panel-left-label");
        const progressPanelLeftValue = document.getElementById("progress-panel-left-value");
        const progressLivesValueDisplay = document.getElementById("progressLivesValue");
        const progressLifeTimerValueDisplay = document.getElementById("progressLifeTimerValue");
        const progressLivesInfoGroup = document.getElementById("progress-lives-info-group");
        const starProgressContainer = document.getElementById("star-progress-container");
        const highScoreDisplay = document.getElementById("high-score-display");
        const hsScoreValue = document.getElementById("hs-score-value");
        // Se obtendrá hsSkinValue dentro de la función displayHighScoreInPanel

        const currentWorldInfoGroup = document.getElementById("current-world-info-group");


        const upButton = document.getElementById("up-button");
        const leftButton = document.getElementById("left-button");
        const downButton = document.getElementById("down-button");
        const rightButton = document.getElementById("right-button");
        const settingsPanel = document.getElementById("settings-panel");
        const freeSettingsPanel = document.getElementById("free-settings-panel");
        const configButton = document.getElementById("configButton");
        const configButtonIcon = document.getElementById("configButtonIcon");
        const closeSettingsButton = document.getElementById("close-settings-button");
        const closeFreeSettingsButton = document.getElementById("close-free-settings-button");
        const applyFreeSettingsBottomButton = document.getElementById("apply-free-settings-bottom");
        const freeDifficultySelector = document.getElementById("free-difficulty-selector");

        const backButton = document.getElementById("backButton");
        const backButtonIcon = document.getElementById("backButtonIcon");
        const infoPanel = document.getElementById("info-panel");
        const infoPanelContent = document.getElementById("info-panel-content");
        const closeInfoButton = document.getElementById("close-info-button");
        const topInfoBar = document.getElementById('top-info-bar');
        const selectorInfoBar = document.getElementById('selector-info-bar');
        const setupControls = document.getElementById('setup-controls');
        const actionButtonsRow = document.getElementById('action-buttons-row');

        const resetDataButton = document.getElementById("resetDataButton");
        const resetConfirmPanel = document.getElementById("reset-confirmation-panel");
        const confirmResetYesButton = document.getElementById("confirmResetYes");
        const confirmResetNoButton = document.getElementById("confirmResetNo");

        const configMenuPanel = document.getElementById("config-menu-panel");
        const genericMenuPanel = document.getElementById("generic-menu-panel");
        const genericMenuTitle = document.getElementById("generic-menu-title");
        const closeConfigMenuButton = document.getElementById("close-config-menu-button");
        const closeGenericMenuButton = document.getElementById("close-generic-menu-button");
        const profileMenuButton = document.getElementById("profile-menu-button");
        const storeMenuButton = document.getElementById("store-menu-button");
        const achievementsMenuButton = document.getElementById("achievements-menu-button");
        const bonusesMenuButton = document.getElementById("bonuses-menu-button");
        const dailyMenuButton = document.getElementById("daily-menu-button");
        const wheelMenuButton = document.getElementById("wheel-menu-button");

        const storePanel = document.getElementById("store-panel");
        const profilePanel = document.getElementById("profile-panel");
        const closeProfilePanelButton = document.getElementById("close-profile-panel");
        const storeItemsContainer = document.getElementById("store-items-container");
        const storeTabButtons = document.querySelectorAll('#store-tabs .store-tab');
        const closeStorePanelButton = document.getElementById("close-store-panel");
        const purchaseConfirmationPanel = document.getElementById("purchase-confirmation-panel");
        const purchaseItemPreview = document.getElementById("purchase-item-preview");
        const purchaseConfirmationText = document.getElementById("purchase-confirmation-text");
        const confirmPurchaseYesButton = document.getElementById("confirmPurchaseYes");
        const confirmPurchaseNoButton = document.getElementById("confirmPurchaseNo");
        const deleteConfirmationPanel = document.getElementById("delete-confirmation-panel");
        const deleteConfirmationText = document.getElementById("delete-confirmation-text");
        const confirmDeleteYesButton = document.getElementById("confirmDeleteYes");
        const confirmDeleteNoButton = document.getElementById("confirmDeleteNo");
        const modalOverlay = document.getElementById("modal-overlay");
        const insufficientFundsToast = document.getElementById("insufficient-funds-toast");
        const outOfLivesPanel = document.getElementById("out-of-lives-panel");
        const closeOutOfLivesPanelButton = document.getElementById("close-out-of-lives-panel");
        const getLivesStoreButton = document.getElementById("get-lives-store-button");
        const getLivesBonusesButton = document.getElementById("get-lives-bonuses-button");

        const profileTabButtons = document.querySelectorAll('#profile-tabs .store-tab');
        const profileGeneralContent = document.getElementById('profile-general-content');
        const profileFoodContent = document.getElementById('profile-food-content');
        const profileSkinContent = document.getElementById('profile-skin-content');
        const profileSceneContent = document.getElementById('profile-scene-content');
        const profileSelectedSkin = document.getElementById('selected-skin-item');
        const profileSelectedFood = document.getElementById('selected-food-item');
        const profileSelectedScene = document.getElementById('selected-scene-item');
        const profileFoodUnlocked = document.getElementById('profile-food-unlocked');
        const profileFoodLocked = document.getElementById('profile-food-locked');
        const profileSkinUnlocked = document.getElementById('profile-skin-unlocked');
        const profileSkinLocked = document.getElementById('profile-skin-locked');
        const profileSceneUnlocked = document.getElementById('profile-scene-unlocked');
        const profileSceneLocked = document.getElementById('profile-scene-locked');
        const selectConfirmationPanel = document.getElementById('select-confirmation-panel');
        const selectConfirmationText = document.getElementById('select-confirmation-text');
        const confirmSelectYesButton = document.getElementById('confirmSelectYes');
        const confirmSelectNoButton = document.getElementById('confirmSelectNo');

        const settingsPanelContent = settingsPanel.querySelector('.panel-content');
        const freeSettingsPanelContent = freeSettingsPanel.querySelector('.panel-content');
        const resetConfirmPanelContent = resetConfirmPanel.querySelector('.panel-content');

        const modeLeftButton = document.getElementById("mode-left-button");
        const modeRightButton = document.getElementById("mode-right-button");
        const modeLeftButtonIcon = document.getElementById("mode-left-button-icon");
        const modeRightButtonIcon = document.getElementById("mode-right-button-icon");

        // New DOM elements for specific info panel
        const specificInfoPanel = document.getElementById("specific-info-panel");
        const specificInfoTitle = document.getElementById("specific-info-title");
        const specificInfoContent = document.getElementById("specific-info-content");
        const closeSpecificInfoButton = document.getElementById("close-specific-info-button");

        const freeSpeedInput = document.getElementById("free-speed-input");
        const freeSpeedValue = document.getElementById("free-speed-value");
        const freeLifespanInput = document.getElementById("free-lifespan-input");
        const freeLifespanValue = document.getElementById("free-lifespan-value");
        const freeLifespanToggle = document.getElementById("free-lifespan-toggle");
        const freeLengthInput = document.getElementById("free-length-input");
        const freeLengthValue = document.getElementById("free-length-value");
        const freeGoldenChanceInput = document.getElementById("free-golden-chance-input");
        const freeGoldenChanceValue = document.getElementById("free-golden-chance-value");
        const freeGoldenLifespanInput = document.getElementById("free-golden-lifespan-input");
        const freeGoldenLifespanValue = document.getElementById("free-golden-lifespan-value");
        const freeGoldenToggle = document.getElementById("free-golden-toggle");
        const freeLightningRange = document.getElementById("free-lightning-range");
        const freeLightningRangeDisplay = document.getElementById("free-lightning-range-display");
        const freeLightningLifespan = document.getElementById("free-lightning-lifespan");
        const freeLightningLifespanValue = document.getElementById("free-lightning-lifespan-value");
        const freeRedChance = document.getElementById("free-red-chance");
        const freeRedChanceValue = document.getElementById("free-red-chance-value");
        const freeLightningToggle = document.getElementById("free-lightning-toggle");
        const freeStreakToggle = document.getElementById("free-streak-toggle");
        const freeFalseRange = document.getElementById("free-false-range");
        const freeFalseRangeDisplay = document.getElementById("free-false-range-display");
        const freeFalseLifespan = document.getElementById("free-false-lifespan");
        const freeFalseLifespanValue = document.getElementById("free-false-lifespan-value");
        const freeFalseToggle = document.getElementById("free-false-toggle");
        const freeMirrorRange = document.getElementById("free-mirror-range");
        const freeMirrorRangeDisplay = document.getElementById("free-mirror-range-display");
        const freeMirrorLifespan = document.getElementById("free-mirror-lifespan");
        const freeMirrorLifespanValue = document.getElementById("free-mirror-lifespan-value");
        const freeMirrorEffect = document.getElementById("free-mirror-effect");
        const freeMirrorEffectValue = document.getElementById("free-mirror-effect-value");
        const freeMirrorToggle = document.getElementById("free-mirror-toggle");
        const freeObstacleCount = document.getElementById("free-obstacle-count");
        const freeObstacleCountValue = document.getElementById("free-obstacle-count-value");
        const freeObstacleGroup = freeObstacleCount ? freeObstacleCount.closest('.control-group') : null;

function setupSlider(slider, display) {
    if (slider && display) {
        slider.addEventListener('input', () => { display.textContent = slider.value; });
        display.textContent = slider.value;
    }
}

        function setupRangeSlider(slider, display) {
            if (slider && display) {
                const update = () => {
                    const val = parseFloat(slider.value);
                    display.textContent = `${val} - ${val + 4}`;
                };
                slider.addEventListener('input', update);
                update();
            }
        }

        function setupToggle(toggle, inputs) {
            if (!toggle) return;
            const arr = Array.isArray(inputs) ? inputs : [inputs];
            const container = toggle.closest('.control-group');
            const update = () => {
                arr.forEach(inp => { if (inp) inp.disabled = !toggle.checked; });
                if (container) {
                    container.classList.toggle('dimmed', !toggle.checked);
                }
            };
            toggle.addEventListener('change', update);
            update();
        }

        setupSlider(freeSpeedInput, freeSpeedValue);
        setupSlider(freeLifespanInput, freeLifespanValue);
        setupSlider(freeLengthInput, freeLengthValue);
        setupSlider(freeGoldenChanceInput, freeGoldenChanceValue);
        setupSlider(freeGoldenLifespanInput, freeGoldenLifespanValue);
        setupRangeSlider(freeLightningRange, freeLightningRangeDisplay);
        setupSlider(freeLightningLifespan, freeLightningLifespanValue);
        setupSlider(freeRedChance, freeRedChanceValue);
        setupRangeSlider(freeFalseRange, freeFalseRangeDisplay);
        setupSlider(freeFalseLifespan, freeFalseLifespanValue);
        setupRangeSlider(freeMirrorRange, freeMirrorRangeDisplay);
        setupSlider(freeMirrorLifespan, freeMirrorLifespanValue);
        setupSlider(freeMirrorEffect, freeMirrorEffectValue);
        setupSlider(freeObstacleCount, freeObstacleCountValue);
        if (freeObstacleCount && freeObstacleGroup) {
            const updateObstacleGroup = () => {
                if (freeObstacleGroup) {
                    freeObstacleGroup.classList.toggle('dimmed', parseInt(freeObstacleCount.value, 10) === 0);
                }
            };
            freeObstacleCount.addEventListener('input', updateObstacleGroup);
            updateObstacleGroup();
        }

        setupToggle(freeLifespanToggle, freeLifespanInput);
        setupToggle(freeGoldenToggle, [freeGoldenChanceInput, freeGoldenLifespanInput]);
        setupToggle(freeLightningToggle, [freeLightningRange, freeLightningLifespan, freeRedChance]);
        setupToggle(freeStreakToggle);
        setupToggle(freeFalseToggle, [freeFalseRange, freeFalseLifespan]);
        setupToggle(freeMirrorToggle, [freeMirrorRange, freeMirrorLifespan, freeMirrorEffect]);


        function updateFreeSettingsLockState() {
            if (!freeSettingsPanelContent) return;
            const isCustom = freeDifficulty === 'personalizado';
            const groups = freeSettingsPanelContent.querySelectorAll('.control-group');
            groups.forEach(g => {
                if (g.id === 'free-difficulty-control-group') return;
                g.classList.toggle('dimmed', !isCustom);
                g.querySelectorAll('input, select, button.setting-info-button').forEach(el => {
                    if (el.classList.contains("setting-info-button") && el.dataset.setting === "playerName") return;
                    el.disabled = !isCustom;
                });
            });
            if (applyFreeSettingsBottomButton) {
                applyFreeSettingsBottomButton.classList.toggle('dimmed', !isCustom);
                applyFreeSettingsBottomButton.disabled = !isCustom;
            }
        }


        // --- INICIO: Declaración de Objetos Image ---
        const classicSnakeHeadLeftImg = new Image();
        const classicSnakeHeadDownImg = new Image();
        const classicFoodImg = new Image();
        const snakeBodyTexture = new Image();
        const snakeBodyTextureVertical = new Image();
        const snakeTailTexture = new Image();
        const snakeTailTextureUp = new Image();
        const catTailTextureUp = new Image();
        const orangeCatTailTextureUp = new Image();
        const snakeCornerTextureA = new Image();
        const snakeCornerTextureB = new Image();

        const sceneGrassBgImg = new Image();
        const sceneGrassBorderImg = new Image();
        const sceneVolcanoBgImg = new Image();
        const sceneVolcanoBorderImg = new Image();
        const sceneAceraGrandeBgImg = new Image();
        const sceneAceraPequenaBgImg = new Image();
        const sceneAguaBgImg = new Image();
        const sceneBaldosaColoresBgImg = new Image();
        const sceneCaminoPiedraBgImg = new Image();
        const sceneCaminoPiedraMusgoBgImg = new Image();
        const sceneCaminoHierbaPiedraBgImg = new Image();
        const sceneCebraBgImg = new Image();
        const sceneHalloweenBgImg = new Image();
        const sceneHieloBgImg = new Image();
        const sceneLadrilloBgImg = new Image();
        const sceneMaderaBgImg = new Image();
        const sceneBaldosaBlancaBgImg = new Image();
        const sceneBaldosaBeigeBgImg = new Image();
        const sceneRocasBgImg = new Image();
        const sceneTejadoBgImg = new Image();
        const sceneTierraBgImg = new Image();
        const sceneTribalBgImg = new Image();
        const sceneDesiertoBgImg = new Image();
        const scenePlayaBgImg = new Image();
        const sceneEspacioBgImg = new Image();
        const sceneCarreteraBgImg = new Image();
        const sceneEstrellaNeonBgImg = new Image();
        const sceneSerpientesNeonBgImg = new Image();
        const sceneFormasNeonBgImg = new Image();
        const sceneCuadradosNeonBgImg = new Image();
        const sceneXNeonBgImg = new Image();

        const catHeadLeftImg = new Image();
        const catHeadDownImg = new Image();
        const catBodyTexture = new Image();
        const catBodyTextureVertical = new Image();
        const catTailTexture = new Image();

        const orangeCatHeadLeftImg = new Image();
        const orangeCatHeadDownImg = new Image();
        const orangeCatBodyTexture = new Image();
        const orangeCatBodyTextureVertical = new Image();
        const orangeCatTailTexture = new Image();
        const orangeCatCornerTextureA = new Image();
        const orangeCatCornerTextureB = new Image();

        const orangeCatReactionPreEatLeftImg = new Image();
        const orangeCatReactionPreEatDownImg = new Image();
        const orangeCatReactionEatLeftImg = new Image();
        const orangeCatReactionEatDownImg = new Image();
        const orangeCatReactionEatGoldenLeftImg = new Image();
        const orangeCatReactionEatGoldenDownImg = new Image();
        const orangeCatReactionEatSpeedLeftImg = new Image();
        const orangeCatReactionEatSpeedDownImg = new Image();
        const orangeCatReactionEatFalseLeftImg = new Image();
        const orangeCatReactionEatFalseDownImg = new Image();
        const orangeCatReactionEatMirrorLeftImg = new Image();
        const orangeCatReactionEatMirrorDownImg = new Image();

        const blackCatHeadLeftImg = new Image();
        const blackCatHeadDownImg = new Image();
        const blackCatBodyTexture = new Image();
        const blackCatBodyTextureVertical = new Image();
        const blackCatTailTexture = new Image();
        const blackCatTailTextureUp = new Image();
        const blackCatCornerTextureA = new Image();
        const blackCatCornerTextureB = new Image();

        const blackCatReactionPreEatLeftImg = new Image();
        const blackCatReactionPreEatDownImg = new Image();
        const blackCatReactionEatLeftImg = new Image();
        const blackCatReactionEatDownImg = new Image();
        const blackCatReactionEatGoldenLeftImg = new Image();
        const blackCatReactionEatGoldenDownImg = new Image();
        const blackCatReactionEatSpeedLeftImg = new Image();
        const blackCatReactionEatSpeedDownImg = new Image();
        const blackCatReactionEatFalseLeftImg = new Image();
        const blackCatReactionEatFalseDownImg = new Image();
        const blackCatReactionEatMirrorLeftImg = new Image();
        const blackCatReactionEatMirrorDownImg = new Image();

        const rubiSnakeHeadUpDownImg = new Image();
        const rubiSnakeHeadLeftImg = new Image();
        const rubiSnakeFoodImg = new Image();

        const aitorSnakeHeadUpDownImg = new Image();
        const aitorSnakeHeadLeftImg = new Image();
        const aitorSnakeFoodImg = new Image();

        const noemiSnakeHeadUpDownImg = new Image();
        const noemiSnakeHeadLeftImg = new Image();
        const noemiSnakeFoodImg = new Image();

        const maraSnakeHeadUpDownImg = new Image();
        const maraSnakeHeadLeftImg = new Image();
        const maraSnakeFoodImg = new Image();

        const almuSnakeHeadUpDownImg = new Image(); 
        const almuSnakeHeadLeftImg = new Image();   
        const almuSnakeFoodImg = new Image();   

        const mimiSnakeHeadUpDownImg = new Image();
        const mimiSnakeHeadLeftImg = new Image();
        const mimiSnakeFoodImg = new Image();
        const reactionPreEatLeftImg = new Image();
        const reactionPreEatDownImg = new Image();
        const reactionEatLeftImg = new Image();
        const reactionEatDownImg = new Image();
        const reactionEatGoldenLeftImg = new Image();
        const reactionEatGoldenDownImg = new Image();
        const reactionEatSpeedLeftImg = new Image();
        const reactionEatSpeedDownImg = new Image();
        const reactionEatFalseLeftImg = new Image();
        const reactionEatFalseDownImg = new Image();
        const reactionEatMirrorLeftImg = new Image();
        const reactionEatMirrorDownImg = new Image();
        const obstacleImg = new Image();
        const lightningYellowImg = new Image();
        const lightningRedImg = new Image();

        const mazeModeCoverImg = new Image();
        const mazeLevelCoverImg = new Image();
        const mazeFailImg = new Image();
        const mazePartialImg = new Image();
        const mazePerfectImg = new Image();
        const mazeCompleteImg = new Image();
        const mazeFinalImg = new Image();
        const mazeAllStarsImg = new Image();
        const timeoutImg = new Image();
        const starFullImg = new Image();
        const starEmptyImg = new Image();

        const worldCoverImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const worldCompleteImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const levelCompleteImg = new Image();
        const defeatImg = new Image();
        const freeModeCoverImg = new Image();
        const freeModeEndImg = new Image();
        const freeModeInactivityImg = new Image();
        const classificationModeCoverImg = new Image();
        const classificationDifficultyImages = {
            principiante: new Image(),
            explorador: new Image(),
            veterano: new Image(),
            legendario: new Image()
        };
        const modeSelectIntroImg = new Image();
        const modeSelectLevelsImg = new Image();
        const modeSelectFreeImg = new Image();
        const modeSelectClassificationImg = new Image();
        const modeSelectMazeImg = new Image();

        const worldImagesConfig = {
            1: { cover: 'https://i.imgur.com/aZygoxI.png', complete: 'https://i.imgur.com/Fltk8Vy.png' },
            2: { cover: 'https://i.imgur.com/u9P2UbG.png', complete: 'https://i.imgur.com/IBMU24f.png' },
            3: { cover: 'https://i.imgur.com/VvjTffg.png', complete: 'https://i.imgur.com/SgoZBJ5.png' },
            4: { cover: 'https://i.imgur.com/17yQbLk.png', complete: 'https://i.imgur.com/yqJtLHZ.png' },
            5: { cover: 'https://i.imgur.com/eve92Ap.png', complete: 'https://i.imgur.com/5ClclJK.png' },
            6: { cover: 'https://i.imgur.com/QaqKAcn.png', complete: 'https://i.imgur.com/xsShnmX.png' },
            7: { cover: 'https://i.imgur.com/DcT65N5.png', complete: 'https://i.imgur.com/xSCMXXp.png' },
            8: { cover: 'https://i.imgur.com/eTDOF8T.png', complete: 'https://i.imgur.com/vqPvQnL.png' },
            9: { cover: 'https://i.imgur.com/XpYeLDi.png', complete: 'https://i.imgur.com/BFZwRsR.png' },
            10: { cover: 'https://i.imgur.com/j0UyWzJ.png', complete: 'https://i.imgur.com/YFoeeoF.png' }
        };

        let worldImagesLoaded = 0;
        const totalWorldImagesToLoad = Object.keys(worldImagesConfig).length * 2 + 19;
        // --- FIN: Declaración de Objetos Image ---

        // --- Música de fondo y SFX ---
        let generalBackgroundMusic; 
        let inGameBackgroundMusic;  
        const generalBackgroundMusicURL = 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/1ffc16f7db7280cf31d5e7209c5c23e7d533d1e3/Instrumental%20fondo%20-%20Recuerdos%20Pixelados%20(1).mp3';
        const inGameBackgroundMusicURL = 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Valle%20del%20despertar%20-%20Serpiente%20de%20Ne%C3%B3n.mp3';

        const WORLD_MUSIC_URLS = {
            1: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Valle%20del%20despertar%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            2: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Cueva%20del%20crecimiento%20-%20La%20Serpiente%20de%20Ne%C3%B3n.mp3',
            3: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Templo%20de%20la%20Agilidad-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            4: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Hambre%20Voraz%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            5: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Doble%20o%20nada%2C%20comestibles%20dorados%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            6: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Racha%20demoledora%20-%20La%20serpiente%20de%20ne%C3%B3n.mp3',
            7: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Bosque%20de%20los%20enga%C3%B1os%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            8: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Jard%C3%ADn%20de%20los%20Peligros%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            9: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Lago%20del%20Reflejo%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            10:'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Final%20Inesperado%20-%20serpiente%20de%20ne%C3%B3n.mp3'
        };

        const MODE_MUSIC_URLS = {
            maze: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/9705ce5b286f197add7dd7f2bb767edf09594ef9/Serpiente%20de%20Ne%C3%B3n%20(3).mp3',
            freeMode: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/bc07b0e83b7df448cb82a9a6b8a5ae4196d06758/Modo%20libre%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            classification: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/ecfea23c17b11d743d5bade6b5ef8e025ea1fff6/Modo%20clasificaci%C3%B3n%20-%20Serpiente%20de%20Ne%C3%B3n.mp3'
        };
        let synthSplashStart; 
        const MAX_ACTUAL_SLIDER_MAPPED_VOLUME = 0.5;


        // Configuración del juego
        let GRID_SIZE = 15;
        const TILE_COUNT = 15;
        let tileCountX = TILE_COUNT;
        let tileCountY = TILE_COUNT;
        const DEFAULT_INITIAL_SNAKE_LENGTH = 3; // Used for free mode
        let initialSnakeLength = DEFAULT_INITIAL_SNAKE_LENGTH;
        const MAX_STREAK = 5;
        const STREAK_ANIMATION_DURATION = 1000; // ms that streak value is shown above head
        const SCENE_CONTRAST = 0.6; // Reduction factor applied to scene backgrounds
        
        // Mapping for difficulty display names
        const DIFFICULTY_DISPLAY_NAMES = {
            personalizado: "Personalizado",
            principiante: "Novato",
            explorador: "Explorador",
            veterano: "Veterano",
            legendario: "Legendario"
        };

        // Mapping para nombres de jugadores en el ranking
        const SKIN_DISPLAY_NAMES = {
            snake: "Snake",
            Snake: "Snake",
            rubiSnake: "RubiSnake",
            aitorSnake: "AitorSnake",
            noemiSnake: "NoemiSnake",
            maraSnake: "MaraSnake",
            almuSnake: "AlmuSnake",
            mimiSnake: "MimiSnake",
            blackCat: "Gato Negro",
            orangeCat: "Gato Naranja"
        };

        const SKIN_ORDER = ['snake','rubiSnake','aitorSnake','noemiSnake','maraSnake','almuSnake','mimiSnake','blackCat','orangeCat'];
        const SKIN_PRICES = {
            snake: 0,
            rubiSnake: 1000,
            aitorSnake: 1000,
            noemiSnake: 1000,
            maraSnake: 1000,
            almuSnake: 1000,
            mimiSnake: 1000,
            blackCat: 1000,
            orangeCat: 1000
        };

        const SCENE_DISPLAY_NAMES = {
            classic: 'Clásico',
            hierba: 'Hierba',
            volcan: 'Volcán',
            aceraGrande: 'Acera grande',
            aceraPequena: 'Acera pequeña',
            agua: 'Agua',
            baldosaColores: 'Baldosa Colores',
            caminoPiedra: 'Camino de Piedra',
            caminoPiedraMusgo: 'Camino de Piedra y Musgo',
            caminoHierbaPiedra: 'Camino de Hierba y Piedra',
            cebra: 'Cebra',
            halloween: 'Halloween',
            hielo: 'Hielo',
            ladrillo: 'Ladrillo',
            madera: 'Madera',
            baldosaBlanca: 'Baldosa Blanca',
            baldosaBeige: 'Baldosa Beige',
            rocas: 'Rocas',
            tejado: 'Tejado',
            tierra: 'Tierra',
            tribal: 'Tribal',
            desierto: 'Desierto',
            playa: 'Playa',
            espacio: 'Espacio',
            carretera: 'Carretera',
            estrellaNeon: 'Estrella de Neón',
            serpientesNeon: 'Serpientes de Neón',
            formasNeon: 'Formas de Neón',
            cuadradosNeon: 'Cuadrados de Neón',
            xNeon: 'X de Neón'
        };

        const SCENE_ORDER = ['classic', 'hierba', 'volcan',
            'aceraGrande','aceraPequena','agua','baldosaColores','caminoPiedra','caminoPiedraMusgo','caminoHierbaPiedra','cebra','halloween','hielo','ladrillo','madera','baldosaBlanca','baldosaBeige','rocas','tejado','tierra','tribal','desierto','playa','espacio','carretera','estrellaNeon','serpientesNeon','formasNeon','cuadradosNeon','xNeon'];
        const SCENE_PRICES = {
            classic: 0,
            hierba: 1000,
            volcan: 1000,
            aceraGrande: 1000,
            aceraPequena: 1000,
            agua: 1000,
            baldosaColores: 1000,
            caminoPiedra: 1000,
            caminoPiedraMusgo: 1000,
            caminoHierbaPiedra: 1000,
            cebra: 1000,
            halloween: 1000,
            hielo: 1000,
            ladrillo: 1000,
            madera: 1000,
            baldosaBlanca: 1000,
            baldosaBeige: 1000,
            rocas: 1000,
            tejado: 1000,
            tierra: 1000,
            tribal: 1000,
            desierto: 1000,
            playa: 1000,
            espacio: 1000,
            carretera: 1000,
            estrellaNeon: 1000,
            serpientesNeon: 1000,
            formasNeon: 1000,
            cuadradosNeon: 1000,
            xNeon: 1000
        };

        const SCENES = {
            classic: {
                icon: 'https://i.imgur.com/5h4MBe4.png',
                bgImg: null,
                borderImg: null,
                bgColor: '#374151'
            },
            hierba: {
                icon: 'https://i.imgur.com/DPBCWp1.png',
                bgImg: sceneGrassBgImg,
                borderImg: null,
                bgColor: '#1b5e20'
            },
            volcan: {
                icon: 'https://i.imgur.com/lGxjqbV.png',
                bgImg: sceneVolcanoBgImg,
                borderImg: null,
                bgColor: '#7f1d1d'
            },
            aceraGrande: {
                icon: 'https://i.imgur.com/WOVZvPK.png',
                bgImg: sceneAceraGrandeBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            aceraPequena: {
                icon: 'https://i.imgur.com/2ac9Tnk.png',
                bgImg: sceneAceraPequenaBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            agua: {
                icon: 'https://i.imgur.com/uM0IkxC.png',
                bgImg: sceneAguaBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            baldosaColores: {
                icon: 'https://i.imgur.com/q0x4GiW.png',
                bgImg: sceneBaldosaColoresBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            caminoPiedra: {
                icon: 'https://i.imgur.com/Xkq8aTf.png',
                bgImg: sceneCaminoPiedraBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            caminoPiedraMusgo: {
                icon: 'https://i.imgur.com/X9RuEBp.png',
                bgImg: sceneCaminoPiedraMusgoBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            caminoHierbaPiedra: {
                icon: 'https://i.imgur.com/yVHyjAt.png',
                bgImg: sceneCaminoHierbaPiedraBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            cebra: {
                icon: 'https://i.imgur.com/qTYu0bA.png',
                bgImg: sceneCebraBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            halloween: {
                icon: 'https://i.imgur.com/T4qwjxj.png',
                bgImg: sceneHalloweenBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            hielo: {
                icon: 'https://i.imgur.com/m2vwtBN.png',
                bgImg: sceneHieloBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            ladrillo: {
                icon: 'https://i.imgur.com/2DuLbzT.png',
                bgImg: sceneLadrilloBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            madera: {
                icon: 'https://i.imgur.com/RNXAoEZ.png',
                bgImg: sceneMaderaBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            baldosaBlanca: {
                icon: 'https://i.imgur.com/ShzWBiX.png',
                bgImg: sceneBaldosaBlancaBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            baldosaBeige: {
                icon: 'https://i.imgur.com/Qm3W9er.png',
                bgImg: sceneBaldosaBeigeBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            rocas: {
                icon: 'https://i.imgur.com/XCZ7Z6h.png',
                bgImg: sceneRocasBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            tejado: {
                icon: 'https://i.imgur.com/takLFr9.png',
                bgImg: sceneTejadoBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            tierra: {
                icon: 'https://i.imgur.com/UJUSLTz.png',
                bgImg: sceneTierraBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            tribal: {
                icon: 'https://i.imgur.com/X9l4k2m.png',
                bgImg: sceneTribalBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            desierto: {
                icon: 'https://i.imgur.com/22F9XHL.png',
                bgImg: sceneDesiertoBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            playa: {
                icon: 'https://i.imgur.com/TIOY4Ae.png',
                bgImg: scenePlayaBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            espacio: {
                icon: 'https://i.imgur.com/OV74OfK.png',
                bgImg: sceneEspacioBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            carretera: {
                icon: 'https://i.imgur.com/9jDsM11.png',
                bgImg: sceneCarreteraBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            estrellaNeon: {
                icon: 'https://i.imgur.com/OAXNslj.png',
                bgImg: sceneEstrellaNeonBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            serpientesNeon: {
                icon: 'https://i.imgur.com/B60wRhn.png',
                bgImg: sceneSerpientesNeonBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            formasNeon: {
                icon: 'https://i.imgur.com/cuJd24Z.png',
                bgImg: sceneFormasNeonBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            cuadradosNeon: {
                icon: 'https://i.imgur.com/mQRM5QL.png',
                bgImg: sceneCuadradosNeonBgImg,
                borderImg: null,
                bgColor: '#374151'
            },
            xNeon: {
                icon: 'https://i.imgur.com/v4tEMkn.png',
                bgImg: sceneXNeonBgImg,
                borderImg: null,
                bgColor: '#374151'
            }
        };

        function getSceneBgPattern(sceneKey) {
            const data = SCENES[sceneKey] || {};
            const img = data.bgImg;
            if (!img || !img.complete || img.naturalHeight === 0 || !ctx) return null;
            return img;
        }

        // Nombres descriptivos de cada mundo
        const WORLD_DISPLAY_NAMES = [
            "Valle del Despertar",
            "Cueva del Crecimiento",
            "Templo de la Agilidad",
            "Hambre Voraz",
            "Doble o nada",
            "Racha demoledora",
            "Bosque de los Engaños",
            "Jardín de los Peligros",
            "Lago del Reflejo",
            "Final Inesperado"
        ];


        // --- LEVELS MODE CONFIG ---
        const LEVELS_PER_WORLD = 5;
        const TOTAL_WORLDS = 10;
        const LEVEL_TIME_LIMIT = 60000;

        // Star thresholds for Maze Mode (puntos objetivo para cada estrella)
        const MAZE_STAR_TARGETS = [25, 50, 100, 150, 200];
        let mazeStarsEarned = 0;

        const MAZE_LEVELS_PER_DIFFICULTY = 10;
        const MAZE_LEVEL_COUNT = MAZE_LEVELS_PER_DIFFICULTY * 4;
        function getMazeDifficultyForLevel(level) {
            if (level <= MAZE_LEVELS_PER_DIFFICULTY) return 'principiante';
            if (level <= MAZE_LEVELS_PER_DIFFICULTY * 2) return 'explorador';
            if (level <= MAZE_LEVELS_PER_DIFFICULTY * 3) return 'veterano';
            return 'legendario';
        }
        let currentMazeLevel = 1;
        let mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
        let mazePreviousStars = 0; // Stars achieved before starting the current run

        const MAZE_LAYOUTS = {
            // Nivel 1 - bloques en las esquinas
            1: [
                { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 },
                { x: 13, y: 0 }, { x: 14, y: 0 }, { x: 14, y: 1 },
                { x: 0, y: 13 }, { x: 0, y: 14 }, { x: 1, y: 14 },
                { x: 14, y: 13 }, { x: 14, y: 14 }, { x: 13, y: 14 }
            ],
            // Nivel 2 - cuatro bloques centrales de 2x2
            2: [
                { x: 3, y: 3 }, { x: 4, y: 3 }, { x: 3, y: 4 }, { x: 4, y: 4 },
                { x: 10, y: 3 }, { x: 11, y: 3 }, { x: 10, y: 4 }, { x: 11, y: 4 },
                { x: 3, y: 10 }, { x: 4, y: 10 }, { x: 3, y: 11 }, { x: 4, y: 11 },
                { x: 10, y: 10 }, { x: 11, y: 10 }, { x: 10, y: 11 }, { x: 11, y: 11 }
            ],
            // Nivel 3 - cruz que divide en cuadrantes
            3: (() => {
                const res = [];
                for (let i = 0; i < 9; i++) res.push({ x: i + 3, y: 7 });
                for (let i = 0; i < 9; i++) res.push({ x: 7, y: i + 3 });
                return res;
            })(),
            // Nivel 4 - dos muros verticales con hueco central
            4: (() => {
                const res = [];
                for (let y = 1; y < 14; y++) { if (y !== 7) res.push({ x: 4, y }); }
                for (let y = 1; y < 14; y++) { if (y !== 7) res.push({ x: 10, y }); }
                return res;
            })(),
            // Nivel 5 - rectángulo interior con aperturas en cruz
            5: (() => {
                const res = [];
                for (let i = 0; i < 8; i++) { const x = 3 + i; if (x !== 7) res.push({ x, y: 3 }); }
                for (let i = 0; i < 8; i++) { const x = 3 + i; if (x !== 7) res.push({ x, y: 11 }); }
                for (let i = 0; i < 7; i++) { const y = 4 + i; if (y !== 7) res.push({ x: 3, y }); }
                for (let i = 0; i < 9; i++) { const y = 3 + i; if (y !== 7) res.push({ x: 11, y }); }
                return res;
            })(),
            // Nivel 6 - muro vertical con bordes izquierdo e inferior
            6: (() => {
                const res = [];
                for (let x = 0; x < 15; x++) {
    if (x !== 7) res.push({ x, y: 14 });
};
                for (let y = 0; y < 15; y++) {
    if (y !== 7) res.push({ x: 0, y });
};
                for (let y = 2; y <= 6; y++) res.push({ x: 7, y });
                for (let y = 8; y <= 11; y++) res.push({ x: 7, y });
                return res;
            })(),
            // Nivel 7 - marco alrededor de los bordes con dos líneas horizontales
            7: (() => {
                const res = [];
                for (let i = 0; i < 15; i++) {
                    if (i !== 7) {
                        res.push({ x: i, y: 0 });
                        res.push({ x: i, y: 14 });
                    }
                }
                for (let i = 1; i < 14; i++) {
                    if (i !== 7) { res.push({ x: 0, y: i }); res.push({ x: 14, y: i }); }
                }
                for (let i = 0; i < 9; i++) { const x = i + 3; if (x !== 7) res.push({ x, y: 5 }); }
                for (let i = 0; i < 9; i++) { const x = i + 3; if (x !== 7) res.push({ x, y: 9 }); }
                return res;
            })(),
            // Nivel 8 - líneas horizontales y verticales desplazadas
            8: (() => {
                const res = [];
                for (let y = 0; y <= 7; y++) res.push({ x: 3, y });
                for (let y = 8; y <= 14; y++) res.push({ x: 11, y });
                for (let x = 0; x <= 7; x++) res.push({ x, y: 10 });
                for (let x = 7; x <= 14; x++) res.push({ x, y: 5 });
                return res;
            })(),
            // Nivel 9 - franjas horizontales
            9: (() => {
                const res = [];
                for (let i = 0; i < 11; i++) res.push({ x: i + 2, y: 2 });
                for (let i = 0; i < 11; i++) res.push({ x: i + 2, y: 5 });
                for (let i = 0; i < 11; i++) res.push({ x: i + 2, y: 9 });
                for (let i = 0; i < 11; i++) res.push({ x: i + 2, y: 12 });
                for (let y = 3; y <= 4; y++) res.push({ x: 0, y });
                for (let y = 3; y <= 4; y++) res.push({ x: 14, y });
                for (let y = 10; y <= 11; y++) res.push({ x: 0, y });
                for (let y = 10; y <= 11; y++) res.push({ x: 14, y });
                return res;
            })(),
            // Nivel 10 - franjas horizontales con Marco exterior con huecos
            10: (() => {
                const res = [];
                for (let i = 1; i < 12; i++) res.push({ x: i + 1, y: 3 });
                for (let i = 1; i < 12; i++) res.push({ x: i + 1, y: 6 });
                for (let i = 1; i < 12; i++) res.push({ x: i + 1, y: 8 });
                for (let i = 1; i < 12; i++) res.push({ x: i + 1, y: 11 });
            // Marco exterior con huecos
                for (let i = 0; i < 15; i++) { if (i !== 1 && i !== 13) res.push({ x: i, y: 0 }); }
                for (let i = 0; i < 15; i++) { if (i !== 1 && i !== 13) res.push({ x: i, y: 14 }); }
                for (let i = 1; i < 14; i++) { if (i !== 7) res.push({ x: 0, y: i }); }
                for (let i = 1; i < 14; i++) { if (i !== 7) res.push({ x: 14, y: i }); }
                return res;
            })()
        };
        // Configuración base equivalente al Mundo 1 (Valle del Despertar)
        const BASE_LEVEL_SETTINGS = {
            speed: 200,
            initialLength: 4,
            initialLifespan: 0,
            goldenFoodChance: 0,
            goldenFoodLifespan: 0,
            lightningSpawnRange: null,
            lightningLifespan: 0,
            redLightningChance: 0,
            streakReduction: 0,
            falseFoodSpawnRange: null,
            falseFoodLifespan: 0,
            mirrorSpawnRange: null,
            mirrorLifespan: 0,
            mirrorEffectDuration: 0,
            obstacleCount: 0,
            targetScore: 0
        };

        const WORLD_DEFAULTS = [
            // Mundo 1 - Valle del Despertar
            {},
            // Mundo 2 - Cueva del Crecimiento
            { speed: 195 },
            // Mundo 3 - Templo de la Agilidad
            { speed: 190, initialLength: 7, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000] },
            // Mundo 4 - Hambre Voraz
            { speed: 185, initialLength: 9, lightningLifespan: 5750, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000] },
            // Mundo 5 - Doble o nada
            { speed: 180, initialLength: 11, lightningLifespan: 5500, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000], initialLifespan: 5750 },
            // Mundo 6 - Racha demoledora
            { speed: 175, initialLength: 13, lightningLifespan: 5250, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000], initialLifespan: 5500, goldenFoodChance: 0.15, goldenFoodLifespan: 4500, streakReduction: 250 },
            // Mundo 7 - Bosque de los Engaños
            { speed: 170, initialLength: 15, lightningLifespan: 5000, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000], initialLifespan: 5250, goldenFoodChance: 0.14, goldenFoodLifespan: 4250, streakReduction: 250, falseFoodLifespan: 5000 },
            // Mundo 8 - Jardín de los Peligros
            { speed: 165, initialLength: 17, lightningLifespan: 4750, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000], initialLifespan: 5000, goldenFoodChance: 0.13, goldenFoodLifespan: 4000, streakReduction: 250, falseFoodLifespan: 5000, falseFoodSpawnRange: [5000, 8000] },
            // Mundo 9 - Lago del Reflejo
            { speed: 160, initialLength: 19, lightningLifespan: 4500, redLightningChance: 0.25, lightningSpawnRange: [5000, 8000], initialLifespan: 4750, goldenFoodChance: 0.12, goldenFoodLifespan: 3750, streakReduction: 250, falseFoodLifespan: 5000, falseFoodSpawnRange: [4500, 7500], obstacleCount: 5, mirrorLifespan: 5000, mirrorEffectDuration: 3000 },
            // Mundo 10 - Final Inesperado
            { lightningSpawnRange: [5000, 8000], redLightningChance: 0.25, streakReduction: 250, falseFoodLifespan: 5000, mirrorLifespan: 5000, mirrorEffectDuration: 2250 }
        ];

        const LEVEL_OVERRIDES = [
            // Mundo 1 - Valle del Despertar
            [
                { targetScore: 100 },
                { targetScore: 120 },
                { targetScore: 140 },
                { targetScore: 160 },
                { targetScore: 180 }
            ],
            // Mundo 2 - Cueva del Crecimiento
            [
                { initialLength: 5, targetScore: 110 },
                { initialLength: 7, targetScore: 130 },
                { initialLength: 10, targetScore: 150 },
                { initialLength: 14, targetScore: 170 },
                { initialLength: 18, targetScore: 190 }
            ],
            // Mundo 3 - Templo de la Agilidad
            [
                { lightningLifespan: 6000, targetScore: 120 },
                { lightningLifespan: 5750, targetScore: 140 },
                { lightningLifespan: 5500, targetScore: 160 },
                { lightningLifespan: 5250, targetScore: 180 },
                { lightningLifespan: 5000, targetScore: 200 }
            ],
            // Mundo 4 - Hambre Voraz
            [
                { initialLifespan: 6000, targetScore: 130 },
                { initialLifespan: 5750, targetScore: 150 },
                { initialLifespan: 5500, targetScore: 170 },
                { initialLifespan: 5250, targetScore: 190 },
                { initialLifespan: 5000, targetScore: 210 }
            ],
            // Mundo 5 - Doble o nada
            [
                { goldenFoodLifespan: 4500, goldenFoodChance: 0.2, targetScore: 170 },
                { goldenFoodLifespan: 4250, goldenFoodChance: 0.18, targetScore: 190 },
                { goldenFoodLifespan: 4000, goldenFoodChance: 0.16, targetScore: 210 },
                { goldenFoodLifespan: 3750, goldenFoodChance: 0.14, targetScore: 230 },
                { goldenFoodLifespan: 3500, goldenFoodChance: 0.12, targetScore: 250 }
            ],
            // Mundo 6 - Racha demoledora
            [
                { targetScore: 500 },
                { targetScore: 550 },
                { targetScore: 600 },
                { targetScore: 650 },
                { targetScore: 700 }
            ],
            // Mundo 7 - Bosque de los Engaños
            [
                { falseFoodSpawnRange: [6000, 9000], targetScore: 550 },
                { falseFoodSpawnRange: [5000, 8000], targetScore: 600 },
                { falseFoodSpawnRange: [4000, 7000], targetScore: 650 },
                { falseFoodSpawnRange: [3000, 6000], targetScore: 700 },
                { falseFoodSpawnRange: [2000, 5000], targetScore: 750 }
            ],
            // Mundo 8 - Jardín de los Peligros
            [
                { obstacleCount: 3, targetScore: 600 },
                { obstacleCount: 5, targetScore: 650 },
                { obstacleCount: 8, targetScore: 700 },
                { obstacleCount: 11, targetScore: 750 },
                { obstacleCount: 15, targetScore: 800 }
            ],
            // Mundo 9 - Lago del Reflejo
            [
                { mirrorSpawnRange: [6000, 9000], targetScore: 700 },
                { mirrorSpawnRange: [5000, 8000], targetScore: 750 },
                { mirrorSpawnRange: [4000, 7000], targetScore: 800 },
                { mirrorSpawnRange: [3000, 6000], targetScore: 850 },
                { mirrorSpawnRange: [2000, 5000], targetScore: 900 }
            ],
            // Mundo 10 - Final Inesperado
            [
                { speed: 155, initialLength: 20, initialLifespan: 4650, lightningLifespan: 4400, goldenFoodChance: 0.11, goldenFoodLifespan: 3650, falseFoodSpawnRange: [4250, 7250], obstacleCount: 6, mirrorSpawnRange: [5000, 8000], targetScore: 800 },
                { speed: 150, initialLength: 21, initialLifespan: 4550, lightningLifespan: 4300, goldenFoodChance: 0.1, goldenFoodLifespan: 3550, falseFoodSpawnRange: [4000, 7000], obstacleCount: 8, mirrorSpawnRange: [4750, 7750], targetScore: 850 },
                { speed: 145, initialLength: 22, initialLifespan: 4450, lightningLifespan: 4200, goldenFoodChance: 0.09, goldenFoodLifespan: 3450, falseFoodSpawnRange: [3750, 6750], obstacleCount: 10, mirrorSpawnRange: [4500, 7500], targetScore: 900 },
                { speed: 140, initialLength: 23, initialLifespan: 4350, lightningLifespan: 4100, goldenFoodChance: 0.08, goldenFoodLifespan: 3350, falseFoodSpawnRange: [3500, 6500], obstacleCount: 12, mirrorSpawnRange: [4250, 7250], targetScore: 950 },
                { speed: 130, initialLength: 25, initialLifespan: 4250, lightningLifespan: 4000, goldenFoodChance: 0.07, goldenFoodLifespan: 3250, falseFoodSpawnRange: [3000, 6000], obstacleCount: 15, mirrorSpawnRange: [4000, 7000], targetScore: 1000 }
            ]
        ];

        const LEVEL_SETTINGS = WORLD_DEFAULTS.map((worldDefaults, wi) =>
            LEVEL_OVERRIDES[wi].map(override => ({
                ...BASE_LEVEL_SETTINGS,
                ...worldDefaults,
                ...override
            }))
        );
        let currentWorld = 1;
        let currentLevelInWorld = 1;
        let maxUnlockedWorld = 1;
        let levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
        let worldCurrentLevels = Array(TOTAL_WORLDS).fill(1);

        // --- Variables de visualización para UI ---
        let displayWorld = 1;
        let displayLevelInWorld = 1;
        let displayMazeLevel = 1;
        let displayTargetScore = LEVEL_SETTINGS[0][0].targetScore;

        const SNAKE_REACTION_IMAGES = {
            preEat: { left: reactionPreEatLeftImg, upDown: reactionPreEatDownImg },
            eat: { left: reactionEatLeftImg, upDown: reactionEatDownImg },
            eatGolden: { left: reactionEatGoldenLeftImg, upDown: reactionEatGoldenDownImg },
            eatSpeed: { left: reactionEatSpeedLeftImg, upDown: reactionEatSpeedDownImg },
            eatFalse: { left: reactionEatFalseLeftImg, upDown: reactionEatFalseDownImg },
            eatMirror: { left: reactionEatMirrorLeftImg, upDown: reactionEatMirrorDownImg }
        };

        const ORANGE_CAT_REACTION_IMAGES = {
            preEat: { left: orangeCatReactionPreEatLeftImg, upDown: orangeCatReactionPreEatDownImg },
            eat: { left: orangeCatReactionEatLeftImg, upDown: orangeCatReactionEatDownImg },
            eatGolden: { left: orangeCatReactionEatGoldenLeftImg, upDown: orangeCatReactionEatGoldenDownImg },
            eatSpeed: { left: orangeCatReactionEatSpeedLeftImg, upDown: orangeCatReactionEatSpeedDownImg },
            eatFalse: { left: orangeCatReactionEatFalseLeftImg, upDown: orangeCatReactionEatFalseDownImg },
            eatMirror: { left: orangeCatReactionEatMirrorLeftImg, upDown: orangeCatReactionEatMirrorDownImg }
        };

        const BLACK_CAT_REACTION_IMAGES = {
            preEat: { left: blackCatReactionPreEatLeftImg, upDown: blackCatReactionPreEatDownImg },
            eat: { left: blackCatReactionEatLeftImg, upDown: blackCatReactionEatDownImg },
            eatGolden: { left: blackCatReactionEatGoldenLeftImg, upDown: blackCatReactionEatGoldenDownImg },
            eatSpeed: { left: blackCatReactionEatSpeedLeftImg, upDown: blackCatReactionEatSpeedDownImg },
            eatFalse: { left: blackCatReactionEatFalseLeftImg, upDown: blackCatReactionEatFalseDownImg },
            eatMirror: { left: blackCatReactionEatMirrorLeftImg, upDown: blackCatReactionEatMirrorDownImg }
        };

        // --- Configuración de Jugadores (Skins) ---
        const SKINS = {
            snake: {
                snakeHeadAsset: {
                    upDown: classicSnakeHeadDownImg,
                    left: classicSnakeHeadLeftImg
                },
                foodAsset: classicFoodImg,
                snakeHeadScale: 1.6,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#90ff00', 0.30),
                tailTextureUp: snakeTailTextureUp,
                reactionAssets: SNAKE_REACTION_IMAGES,
            },
            rubiSnake: {
                snakeHeadAsset: {
                    upDown: rubiSnakeHeadUpDownImg,
                    left: rubiSnakeHeadLeftImg,
                },
                foodAsset: rubiSnakeFoodImg,
                snakeHeadScale: 1.7,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#E74C3C', 0.30),
                tailTextureUp: snakeTailTextureUp,
            },
            aitorSnake: {
                snakeHeadAsset: {
                    upDown: aitorSnakeHeadUpDownImg,
                    left: aitorSnakeHeadLeftImg,
                },
                foodAsset: aitorSnakeFoodImg,
                snakeHeadScale: 1.7,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#772CE8', 0.30),
                tailTextureUp: snakeTailTextureUp,
            },
            noemiSnake: {
                snakeHeadAsset: {
                    upDown: noemiSnakeHeadUpDownImg,
                    left: noemiSnakeHeadLeftImg,
                },
                foodAsset: noemiSnakeFoodImg,
                snakeHeadScale: 1.7,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#FFC0EB', 0.30),
                tailTextureUp: snakeTailTextureUp,
            },
            maraSnake: {
                snakeHeadAsset: {
                    upDown: maraSnakeHeadUpDownImg,
                    left: maraSnakeHeadLeftImg,
                },
                foodAsset: maraSnakeFoodImg,
                snakeHeadScale: 1.7,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#FCE9BC', 0.30),
                tailTextureUp: snakeTailTextureUp,
            },
            almuSnake: {
                snakeHeadAsset: {
                    upDown: almuSnakeHeadUpDownImg,
                    left: almuSnakeHeadLeftImg,
                },
                foodAsset: almuSnakeFoodImg,
                snakeHeadScale: 1.7,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#C96B20', 0.30),
                tailTextureUp: snakeTailTextureUp,
            },
            mimiSnake: {
                snakeHeadAsset: {
                    upDown: mimiSnakeHeadUpDownImg,
                    left: mimiSnakeHeadLeftImg,
                },
                foodAsset: mimiSnakeFoodImg,
                snakeHeadScale: 1.7,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#FFFFFF', 0.30),
                tailTextureUp: snakeTailTextureUp,
            },
            blackCat: {
                snakeHeadAsset: {
                    upDown: blackCatHeadDownImg,
                    left: blackCatHeadLeftImg,
                },
                foodAsset: classicFoodImg,
                snakeHeadScale: 1.6,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#000000', 0.30),
                bodyTexture: blackCatBodyTexture,
                bodyTextureVertical: blackCatBodyTextureVertical,
                tailTexture: blackCatTailTexture,
                tailTextureUp: blackCatTailTextureUp,
                cornerTextureA: blackCatCornerTextureA,
                cornerTextureB: blackCatCornerTextureB,
                reactionAssets: BLACK_CAT_REACTION_IMAGES,
            },
            orangeCat: {
                snakeHeadAsset: {
                    upDown: orangeCatHeadDownImg,
                    left: orangeCatHeadLeftImg,
                },
                foodAsset: classicFoodImg,
                snakeHeadScale: 1.6,
                foodScale: 1.25,
                bodyTintColor: null,
                bodyStrokeColor: adjustColor('#FFA500', 0.30),
                bodyTexture: orangeCatBodyTexture,
                bodyTextureVertical: orangeCatBodyTextureVertical,
                tailTexture: orangeCatTailTexture,
                tailTextureUp: orangeCatTailTextureUp,
                cornerTextureA: orangeCatCornerTextureA,
                cornerTextureB: orangeCatCornerTextureB,
                reactionAssets: ORANGE_CAT_REACTION_IMAGES,
            }
        };
        let currentSkin = 'snake';
        let playerProfiles = {};
        let playerNames = ['Snake', 'GamiSnake'];
        let currentPlayerName = 'Snake';

        function createDefaultProfile(name = '') {
            return {
                name: name,
                skin: 'snake',
                food: 'apple',
                scene: 'classic',
                difficulty: 'principiante',
                audioGeneral: 'all',
                musicVolume: 75,
                sfxVolume: 75,
                gameMode: '',
                currentWorld: 1,
                currentLevelInWorld: 1,
                maxUnlockedWorld: 1,
                levelsProgress: Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false),
                worldCurrentLevels: Array(TOTAL_WORLDS).fill(1),
                currentMazeLevel: 1,
                mazeLevelStars: Array(MAZE_LEVEL_COUNT).fill(0),
                freeModeSettings: { ...FREE_MODE_DEFAULTS }
            };
        }

        function loadPlayerProfiles() {
            const stored = localStorage.getItem('snakePlayerProfiles');
            if (stored) {
                try {
                    playerProfiles = JSON.parse(stored) || {};
                } catch (e) {
                    console.error('Error parsing player profiles', e);
                    playerProfiles = {};
                }
            }
            if (Object.keys(playerProfiles).length === 0) {
                playerProfiles['Snake'] = createDefaultProfile('Snake');
                playerProfiles['GamiSnake'] = createDefaultProfile('GamiSnake');
            }
            Object.keys(playerProfiles).forEach(name => {
                const profile = playerProfiles[name];
                if (!profile.name) profile.name = name;
                if (!Array.isArray(profile.levelsProgress)) {
                    profile.levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
                }
                if (!Array.isArray(profile.worldCurrentLevels)) {
                    profile.worldCurrentLevels = Array(TOTAL_WORLDS).fill(1);
                }
                if (!Array.isArray(profile.mazeLevelStars)) {
                    profile.mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
                }
                if (!profile.freeModeSettings) {
                    profile.freeModeSettings = { ...FREE_MODE_DEFAULTS };
                }
                if (!profile.scene) profile.scene = 'classic';
            });
        }

        function savePlayerProfiles() {
            localStorage.setItem('snakePlayerProfiles', JSON.stringify(playerProfiles));
        }

        function applyProfile(profile) {
            if (!profile) return;
            difficultySelector.value = profile.difficulty || 'principiante';
            classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(difficultySelector.value);
            skinSelectors.forEach(sel => sel.value = profile.skin || 'snake');
            currentSkin = skinSelectors.length ? skinSelectors[0].value : 'snake';
            applySkin(currentSkin);
            foodSelectors.forEach(sel => sel.value = profile.food || 'apple');
            if (foodSelectors.length && !unlockedFoods[foodSelectors[0].value]) {
                foodSelectors.forEach(sel => sel.value = 'apple');
            }
            currentFood = foodSelectors.length ? foodSelectors[0].value : 'apple';
            applyFood(currentFood);
            sceneSelectors.forEach(sel => sel.value = profile.scene || 'classic');
            if (sceneSelectors.length && !unlockedScenes[sceneSelectors[0].value]) {
                sceneSelectors.forEach(sel => sel.value = 'classic');
            }
            currentScene = sceneSelectors.length ? sceneSelectors[0].value : 'classic';
            applyScene(currentScene);
            updateProfileSelectedItems();
            updateFoodSelectorAvailability();
            audioToggleSelector.value = profile.audioGeneral || 'all';
            musicVolumeSlider.value = profile.musicVolume || 75;
            if (musicVolumeValue) musicVolumeValue.textContent = musicVolumeSlider.value;
            sfxVolumeSlider.value = profile.sfxVolume || 75;
            if (sfxVolumeValue) sfxVolumeValue.textContent = sfxVolumeSlider.value;
            currentWorld = profile.currentWorld || 1;
            currentLevelInWorld = profile.currentLevelInWorld || 1;
            maxUnlockedWorld = profile.maxUnlockedWorld || 1;
            levelsProgress = Array.isArray(profile.levelsProgress) ? profile.levelsProgress : Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
            worldCurrentLevels = Array.isArray(profile.worldCurrentLevels) ? profile.worldCurrentLevels : Array(TOTAL_WORLDS).fill(1);
            currentMazeLevel = profile.currentMazeLevel || 1;
            mazeLevelStars = Array.isArray(profile.mazeLevelStars) ? profile.mazeLevelStars : Array(MAZE_LEVEL_COUNT).fill(0);
            freeModeSettings = profile.freeModeSettings ? { ...FREE_MODE_DEFAULTS, ...profile.freeModeSettings } : { ...FREE_MODE_DEFAULTS };
            populateFreeSettingsInputs();
            updateFreeSettingsLockState();

            // Update display variables when applying profile so UI reflects new player state
            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            displayMazeLevel = currentMazeLevel;

            if (gameMode === 'levels') {
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TOTAL_WORLDS * LEVELS_PER_WORLD) {
                    displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1].targetScore;
                } else {
                    displayTargetScore = LEVEL_SETTINGS[TOTAL_WORLDS - 1][LEVELS_PER_WORLD - 1].targetScore;
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            }
        }
        function getSelectedPlayerName() {
            return playerNameSelectors.length ? playerNameSelectors[0].value : '';
        }
        function getSelectedSkin() {
            return skinSelectors.length ? skinSelectors[0].value : 'snake';
        }
        function getSelectedFood() {
            return foodSelectors.length ? foodSelectors[0].value : 'apple';
        }
        function getSelectedScene() {
            return sceneSelectors.length ? sceneSelectors[0].value : 'classic';
        }
        function updatePlayerNameSelectors(selectedName) {
            playerNames = Object.keys(playerProfiles);
            playerNameSelectors.forEach(sel => {
                sel.innerHTML = '';
                playerNames.forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    sel.appendChild(opt);
                });
                if (selectedName && playerNames.includes(selectedName)) sel.value = selectedName;
            });
        }

        function updateFoodSelectorOptions(selectedFood) {
            if (!foodSelectors.length) return;
            foodSelectors.forEach(sel => {
                sel.innerHTML = '';
                FOOD_ORDER.forEach(key => {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = FOOD_DISPLAY_NAMES[key];
                    sel.appendChild(opt);
                });
                if (selectedFood && FOOD_ORDER.includes(selectedFood)) sel.value = selectedFood;
            });
        }

        function updateSceneSelectorOptions(selectedScene) {
            if (!sceneSelectors.length) return;
            sceneSelectors.forEach(sel => {
                sel.innerHTML = '';
                SCENE_ORDER.forEach(key => {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = SCENE_DISPLAY_NAMES[key];
                    sel.appendChild(opt);
                });
                if (selectedScene && SCENE_ORDER.includes(selectedScene)) sel.value = selectedScene;
            });
        }
        // --- Fin Configuración de Jugadores ---

        // --- Configuración de Comestibles ---
        const FOODS = {
            apple: { asset: classicFoodImg, url: 'https://i.imgur.com/fOSSwUX.png', scale: 1.25, price: 0 },
            cereza: { asset: new Image(), url: 'https://i.imgur.com/s3WYriu.png', scale: 1.25, price: 100 },
            pera: { asset: new Image(), url: 'https://i.imgur.com/QwJzp1k.png', scale: 1.25, price: 100 },
            platano: { asset: new Image(), url: 'https://i.imgur.com/tYSI90u.png', scale: 1.25, price: 100 },
            pina: { asset: new Image(), url: 'https://i.imgur.com/udkmLUq.png', scale: 1.25, price: 100 },
            naranja: { asset: new Image(), url: 'https://i.imgur.com/W1WDTpC.png', scale: 1.25, price: 100 },
            kiwi: { asset: new Image(), url: 'https://i.imgur.com/ZixdENw.png', scale: 1.25, price: 200 },
            aguacate: { asset: new Image(), url: 'https://i.imgur.com/yEHqcAz.png', scale: 1.25, price: 200 },
            fresa: { asset: new Image(), url: 'https://i.imgur.com/I9jGTrT.png', scale: 1.25, price: 200 },
            sandia: { asset: new Image(), url: 'https://i.imgur.com/gYOUtji.png', scale: 1.25, price: 200 },
            cafe: { asset: new Image(), url: 'https://i.imgur.com/2iuZzZQ.png', scale: 1.25, price: 300 },
            batidoFresa: { asset: new Image(), url: 'https://i.imgur.com/AJf2LOK.png', scale: 1.25, price: 300 },
            soda: { asset: new Image(), url: 'https://i.imgur.com/PoEzKvA.png', scale: 1.25, price: 300 },
            zumoNaranja: { asset: new Image(), url: 'https://i.imgur.com/D1ZryCw.png', scale: 1.25, price: 300 },
            batidoChocolate: { asset: new Image(), url: 'https://i.imgur.com/uyBQXKX.png', scale: 1.25, price: 300 },
            chocolateCaliente: { asset: new Image(), url: 'https://i.imgur.com/QwHWdN9.png', scale: 1.25, price: 300 },
            cerveza: { asset: new Image(), url: 'https://i.imgur.com/LKcF2tT.png', scale: 1.25, price: 400 },
            vinoBlanco: { asset: new Image(), url: 'https://i.imgur.com/1S0Qvnn.png', scale: 1.25, price: 400 },
            vinoTinto: { asset: new Image(), url: 'https://i.imgur.com/FfXlbU8.png', scale: 1.25, price: 400 },
            kebap: { asset: new Image(), url: 'https://i.imgur.com/NpgCRUg.png', scale: 1.25, price: 500 },
            burrito: { asset: new Image(), url: 'https://i.imgur.com/dSa3rSL.png', scale: 1.25, price: 500 },
            patatas: { asset: new Image(), url: 'https://i.imgur.com/SCzeVKi.png', scale: 1.25, price: 500 },
            polloFrito: { asset: new Image(), url: 'https://i.imgur.com/0kfGi0C.png', scale: 1.25, price: 500 },
            salchicha: { asset: new Image(), url: 'https://i.imgur.com/wHPKEW4.png', scale: 1.25, price: 500 },
            huevoFrito: { asset: new Image(), url: 'https://i.imgur.com/UBMaN50.png', scale: 1.25, price: 500 },
            croqueta: { asset: new Image(), url: 'https://i.imgur.com/4psebHZ.png', scale: 1.25, price: 500 },
            hamburguesa: { asset: new Image(), url: 'https://i.imgur.com/oQVdXFq.png', scale: 1.25, price: 750 },
            pizza: { asset: new Image(), url: 'https://i.imgur.com/D7HV0O4.png', scale: 1.25, price: 750 },
            hotDog: { asset: new Image(), url: 'https://i.imgur.com/v8Tng9s.png', scale: 1.25, price: 750 },
            lasana: { asset: new Image(), url: 'https://i.imgur.com/uO5z1tZ.png', scale: 1.25, price: 750 },
            sushi: { asset: new Image(), url: 'https://i.imgur.com/uccnlBy.png', scale: 1.25, price: 750 },
            caramelo: { asset: new Image(), url: 'https://i.imgur.com/wg4aGv9.png', scale: 1.25, price: 1000 },
            ensaimada: { asset: new Image(), url: 'https://i.imgur.com/6CxTo6I.png', scale: 1.25, price: 1000 },
            muffin: { asset: new Image(), url: 'https://i.imgur.com/1qw2SLR.png', scale: 1.25, price: 1000 },
            croissant: { asset: new Image(), url: 'https://i.imgur.com/rTctItm.png', scale: 1.25, price: 1000 },
            macarrons: { asset: new Image(), url: 'https://i.imgur.com/eYb36j8.png', scale: 1.25, price: 1000 },
            heladoFresa: { asset: new Image(), url: 'https://i.imgur.com/DOYtVFR.png', scale: 1.25, price: 1000 },
            tartaFresa: { asset: new Image(), url: 'https://i.imgur.com/v95HG3r.png', scale: 1.25, price: 1000 },
            palomitas: { asset: new Image(), url: 'https://i.imgur.com/qiCsIkb.png', scale: 1.25, price: 3000 },
            algodonAzucar: { asset: new Image(), url: 'https://i.imgur.com/GSov6QD.png', scale: 1.25, price: 3000 },
            tortitas: { asset: new Image(), url: 'https://i.imgur.com/PGlpQBY.png', scale: 1.25, price: 3000 },
            helado: { asset: new Image(), url: 'https://i.imgur.com/f7VMyLh.png', scale: 1.25, price: 3000 },
            tartaFantasia: { asset: new Image(), url: 'https://i.imgur.com/a7uFEuY.png', scale: 1.25, price: 3000 },
            gofre: { asset: new Image(), url: 'https://i.imgur.com/PD05I19.png', scale: 1.25, price: 3000 },
            donutsGlaseado: { asset: new Image(), url: 'https://i.imgur.com/ZiGKtUq.png', scale: 1.25, price: 5000 },
            huevoYoshi: { asset: new Image(), url: 'https://i.imgur.com/Kx68UN2.png', scale: 1.25, price: 5000 },
            espadaLaser: { asset: new Image(), url: 'https://i.imgur.com/3XIKlOA.png', scale: 1.25, price: 5000 },
            cuernoUnicornio: { asset: new Image(), url: 'https://i.imgur.com/BFgtJCk.png', scale: 1.25, price: 5000 },
            cartuchoRetro: { asset: new Image(), url: 'https://i.imgur.com/mSlH5Go.png', scale: 1.25, price: 5000 },
            setaMario: { asset: new Image(), url: 'https://i.imgur.com/a41hS2U.png', scale: 1.25, price: 5000 },
            guanteInfinito: { asset: new Image(), url: 'https://i.imgur.com/RD42tWb.png', scale: 1.25, price: 5000 },
            gorroMagico: { asset: new Image(), url: 'https://i.imgur.com/1Y2w8KB.png', scale: 1.25, price: 5000 },
            bolaDragon: { asset: new Image(), url: 'https://i.imgur.com/MjDXSXh.png', scale: 1.25, price: 5000 }
        };
        const FOOD_ORDER = ['apple','cereza','pera','platano','pina','naranja','kiwi','aguacate','fresa','sandia','cafe','batidoFresa','soda','zumoNaranja','batidoChocolate','chocolateCaliente','cerveza','vinoBlanco','vinoTinto','kebap','burrito','patatas','polloFrito','salchicha','huevoFrito','croqueta','hamburguesa','pizza','hotDog','lasana','sushi','caramelo','ensaimada','muffin','croissant','macarrons','heladoFresa','tartaFresa','palomitas','algodonAzucar','tortitas','helado','tartaFantasia','gofre','donutsGlaseado','huevoYoshi','espadaLaser','cuernoUnicornio','cartuchoRetro','setaMario','guanteInfinito','gorroMagico','bolaDragon'];
        const FOOD_DISPLAY_NAMES = {
            apple: 'Manzana',
            cereza: 'Cereza',
            pera: 'Pera',
            platano: 'Plátano',
            pina: 'Piña',
            naranja: 'Naranja',
            kiwi: 'Kiwi',
            aguacate: 'Aguacate',
            fresa: 'Fresa',
            sandia: 'Sandía',
            cafe: 'Café',
            batidoFresa: 'Batido de fresa',
            soda: 'Soda',
            zumoNaranja: 'Zumo de naranja',
            batidoChocolate: 'Batido chocolate',
            chocolateCaliente: 'Chocolate caliente',
            cerveza: 'Cerveza',
            vinoBlanco: 'Vino blanco',
            vinoTinto: 'Vino tinto',
            kebap: 'Kebap',
            burrito: 'Burrito',
            patatas: 'Patatas',
            polloFrito: 'Pollo frito',
            salchicha: 'Salchicha',
            huevoFrito: 'Huevo frito',
            croqueta: 'Croqueta',
            hamburguesa: 'Hamburguesa',
            pizza: 'Pizza',
            hotDog: 'HotDog',
            lasana: 'Lasaña',
            sushi: 'Sushi',
            caramelo: 'Caramelo',
            ensaimada: 'Ensaimada',
            muffin: 'Muffin',
            croissant: 'Croissant',
            macarrons: 'Macarrons',
            heladoFresa: 'Helado de fresa',
            tartaFresa: 'Tarta de fresa',
            palomitas: 'Palomitas',
            algodonAzucar: 'Algodón de azúcar',
            tortitas: 'Tortitas',
            helado: 'Helado',
            tartaFantasia: 'Tarta fantasía',
            gofre: 'Gofre',
            donutsGlaseado: 'Donuts Glaseado',
            huevoYoshi: 'Huevo Yoshi',
            espadaLaser: 'Espada Láser',
            cuernoUnicornio: 'Cuerno de unicornio',
            cartuchoRetro: 'Cartucho retro',
            setaMario: 'Seta Mario',
            guanteInfinito: 'Guante del infinito',
            gorroMagico: 'Gorro mágico',
            bolaDragon: 'Bola de dragón'
        };
        let unlockedFoods = { apple: true };
        let unlockedSkins = { snake: true };
        let unlockedScenes = { classic: true };
        let currentFood = 'apple';
        let currentScene = 'classic';
        let totalGems = 0;
        const HEART_PRICE = 100;
        const GEM_PRICE = 1000;
        let storeTab = 'general';
        let profileTab = 'general';
        // --- Fin Configuración de Comestibles ---


        // Estado del juego
        let snake = []; 
        let direction = "right"; 
        let nextDirection = "right"; // Buffer para la siguiente dirección (MANTENIDO DE LA VERSIÓN ANTERIOR)
        let score = 0;
        let totalCoins = 0;
        const MAX_LIVES = 5;
        const LIFE_RECHARGE_TIME = 5 * 60 * 1000; // 5 minutes in ms
        let playerLives = MAX_LIVES;
        let lifeRestoreQueue = [];
        let gameOver = false;
        let gameOverByTimeout = false;
        let gameOverByInactivity = false;
        let gameIntervalId;
        let gameTimeRemaining = 0;
        let gameTimeElapsed = 0;
        let gameTimerIntervalId;
        let lastMovementTime;
        let inactivityIntervalId;
        let gameMode = ''; // No mode selected initially
        let isNewHighScore = false; // Flag for new high score
        
        let currentFoodItem = {}; 
        const FOOD_SHAPE_FALLBACK = { 
            name: 'Comida', 
            color: '#FF7043', 
            borderColor: '#E64A19', 
        };

        let difficulty = 'principiante';
        let freeDifficulty = 'personalizado';
        let currentMazeDifficulty = 'principiante';
        let snakeSpeed = 150; 
        let foodTimeRemaining = 0;
        let foodDisappearTimeoutId;
        let foodVisualTimerIntervalId;
        let eatReactionTimeoutId = null;
        let streakMultiplier = 1; 
        let lastWarningSoundSecond = -1; 

        // Game state variables for screen display
        let screenState = {
            showCoverForWorld: 0,
            showLevelCompleteCover: 0,
            showWorldCompleteCover: 0,
            showDefeatCoverForWorld: 0,
            showTimeoutCover: false,
            showFreeModeCover: false,
            showFreeModeEnd: false,
            showClassificationCover: false,
            showMazeCover: false,
            mazeResultType: '',
            gameActuallyStarted: false
        };
        let modeSelectIndex = 0;
        const MODE_SELECT_ORDER = ['intro', 'levels', 'maze', 'classification', 'freeMode'];
        let showModeSelect = false;
        let panelOpenedFromSplash = false;
        let introOptionAvailable = true; // controls visibility of the intro slide
        const MODE_TRANSITION_DURATION = 300; // ms
        let modeTransitionStart = null;
        let modeTransitionDir = 0;
        let modeTransitionFrom = 0;

        const CLASSIFICATION_DIFFICULTY_ORDER = ['principiante', 'explorador', 'veterano', 'legendario'];
        let classificationDifficultyIndex = 0;
        let classificationTransitionStart = null;
        let classificationTransitionDir = 0;
        let classificationTransitionFrom = 0;
        let worldTransitionStart = null;
        let worldTransitionDir = 0;
        let worldTransitionFrom = 1;
        let mazeTransitionStart = null;
        let mazeTransitionDir = 0;
        let mazeTransitionFrom = 1;


        const FREE_MODE_DEFAULTS = {
            speed: 187,
            initialLifespan: 5600,
            initialLength: 8,
            goldenFoodChance: 0.1,
            goldenFoodLifespan: 3000,
            lightningSpawnRange: [4500, 7500],
            lightningLifespan: 3750,
            redLightningChance: 0.25,
            streakReduction: 600,
            falseFoodSpawnRange: [4500, 7500],
            falseFoodLifespan: 3750,
            mirrorSpawnRange: [4500, 7500],
            mirrorLifespan: 3750,
            mirrorEffectDuration: 2250,
            obstacleCount: 3
        };
        let freeModeSettings = { ...FREE_MODE_DEFAULTS };


        const DIFFICULTY_SETTINGS = {
            principiante: {
                speed: 240,
                initialLifespan: 0,
                initialLength: 3,
                goldenFoodChance: 0,
                goldenFoodLifespan: 0,
                lightningSpawnRange: null,
                lightningLifespan: 0,
                redLightningChance: 0,
                streakReduction: 0,
                falseFoodSpawnRange: null,
                falseFoodLifespan: 0,
                mirrorSpawnRange: null,
                mirrorLifespan: 0,
                mirrorEffectDuration: 0,
                obstacleCount: 0
            },
            explorador:   {
                speed: 213,
                initialLifespan: 6000,
                initialLength: 5,
                goldenFoodChance: 0.15,
                goldenFoodLifespan: 2625,
                lightningSpawnRange: [4500, 7500],
                lightningLifespan: 3750,
                redLightningChance: 0.25,
                streakReduction: 600,
                falseFoodSpawnRange: null,
                falseFoodLifespan: 0,
                mirrorSpawnRange: null,
                mirrorLifespan: 0,
                mirrorEffectDuration: 0,
                obstacleCount: 0
            },
            veterano:     {
                speed: 187,
                initialLifespan: 5600,
                initialLength: 8,
                goldenFoodChance: 0.1,
                goldenFoodLifespan: 3000,
                lightningSpawnRange: [4500, 7500],
                lightningLifespan: 3750,
                redLightningChance: 0.25,
                streakReduction: 600,
                falseFoodSpawnRange: [4500, 7500],
                falseFoodLifespan: 3750,
                mirrorSpawnRange: [4500, 7500],
                mirrorLifespan: 3750,
                mirrorEffectDuration: 2250,
                obstacleCount: 3
            },
            legendario:   {
                speed: 160,
                initialLifespan: 5250,
                initialLength: 11,
                goldenFoodChance: 0.1,
                goldenFoodLifespan: 3000,
                lightningSpawnRange: [4500, 7500],
                lightningLifespan: 3750,
                redLightningChance: 0.25,
                streakReduction: 600,
                falseFoodSpawnRange: [3750, 5250],
                falseFoodLifespan: 4500,
                mirrorSpawnRange: [3750, 5250],
                mirrorLifespan: 4500,
                mirrorEffectDuration: 2250,
                obstacleCount: 6
            }
        };
        const CLASSIFICATION_RANKS = {
            principiante: 1,
            explorador: 2,
            veterano: 3,
            legendario: 4
        };
        const MIN_FOOD_LIFESPAN = 4000;
        const FOOD_WARNING_TIME = 3000; 
        const POINTS_PER_FOOD = 10;
        const POINTS_PER_COIN = 10;
        const POINTS_PER_MIRROR = 25;
        const WIN_SOUND_DURATION = 1300; // ms
        const GAME_OVER_SOUND_DURATION = 800; // ms
        const COIN_MESSAGE_DISPLAY_TIME = 1000; // ms
        const MAX_HIGH_SCORES = 10;
        const FREE_MODE_INACTIVITY_LIMIT = 30000; // ms without movement before game ends in free mode
        const FALSE_FOOD_LIFESPAN = 5000;
        const FALSE_FOOD_SPAWN_RANGES_WORLD4 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const FALSE_FOOD_SPAWN_RANGE_WORLD5 = [7000, 12000];
        const OBSTACLE_COUNTS_WORLD5 = [3, 5, 8, 11, 15];
        const OBSTACLE_COUNT_WORLD6 = 5;
        const GOLDEN_FOOD_CHANCE = 0.15;
        const GOLDEN_FOOD_LIFESPANS_WORLD5 = [4000, 3500, 3000, 2500, 2000];
        const GOLDEN_FOOD_LIFESPAN_CLASSIF_RANK1 = 4500;
        const FALSE_FOOD_SPAWN_RANGES_WORLD8 = [
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000]
        ];
        const OBSTACLE_COUNTS_WORLD8 = [5, 8, 11, 14, 17];
        const LIGHTNING_SPAWN_RANGES_WORLD6 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const LIGHTNING_SPAWN_RANGE_WORLD4 = [4000, 7000];
        const LIGHTNING_SPAWN_RANGE_WORLD7 = [7000, 12000];
        const LIGHTNING_SPAWN_RANGES_WORLD8 = [
            [7000, 9000],
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000]
        ];
        const MIRROR_SPAWN_RANGES_WORLD7 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const MIRROR_SPAWN_RANGES_WORLD8 = [
            [7000, 9000],
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000]
        ];
        const DEFAULT_MIRROR_EFFECT_DURATION = 3000;
        let MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
        const LIGHTNING_LIFESPAN = 5000;
        const SPEED_BOOST_DURATION = 3000;
        const REACTION_DISPLAY_TIME = 600;
        const PRE_EAT_DELAY_MS = 100;
        let obstacles = [];
        let snakeSpawnRow = 0;
        let falseFoodItems = [];
        let falseFoodSpawnTimeoutId;
        let lightningItems = [];
        let lightningSpawnTimeoutId;
        let mirrorItems = [];
        let mirrorSpawnTimeoutId;
        let controlsInverted = false;
        let mirrorEffect = { active: false, startTime: 0 };
        let currentReaction = null;
        let reactionEndTime = 0;
        
        function updateMirrorEffect() {
            if (!mirrorEffect.active) return;
            let duration = MIRROR_EFFECT_DURATION;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? DIFFICULTY_SETTINGS[difficultySelector.value]
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (typeof cfg.mirrorEffectDuration === 'number') {
                    duration = cfg.mirrorEffectDuration;
                }
            } else if (gameMode === 'levels') {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (typeof cfg.mirrorEffectDuration === 'number') {
                    duration = cfg.mirrorEffectDuration;
                }
            }
            const elapsed = Date.now() - mirrorEffect.startTime;
            if (elapsed >= duration) {
                mirrorEffect.active = false;
                controlsInverted = false;
            }
        }

        function setReaction(type, duration = REACTION_DISPLAY_TIME) {
            currentReaction = type;
            reactionEndTime = Date.now() + duration;
        }

        function scheduleEatReaction(type, duration = REACTION_DISPLAY_TIME) {
            if (eatReactionTimeoutId) clearTimeout(eatReactionTimeoutId);
            eatReactionTimeoutId = setTimeout(() => {
                setReaction(type, duration);
                eatReactionTimeoutId = null;
            }, PRE_EAT_DELAY_MS);
        }

        function refreshEffectReactions() {
            if (eatReactionTimeoutId) return;
            const now = Date.now();
            if (currentReaction && now < reactionEndTime) return;
            if (speedBoost.active) {
                const remaining = SPEED_BOOST_DURATION - (now - speedBoost.startTime);
                if (remaining > 0) {
                    setReaction('eatSpeed', remaining);
                    return;
                }
            }
            if (mirrorEffect.active) {
                let duration = MIRROR_EFFECT_DURATION;
                if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                    const cfg = gameMode === 'classification' ? DIFFICULTY_SETTINGS[difficultySelector.value]
                              : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                    if (typeof cfg.mirrorEffectDuration === 'number') {
                        duration = cfg.mirrorEffectDuration;
                    }
                }
                const remaining = duration - (now - mirrorEffect.startTime);
                if (remaining > 0) {
                    setReaction('eatMirror', remaining);
                }
            }
        }
        let speedBoost = { active: false, color: '', change: 0, startTime: 0 };


        // Nuevas variables para el estado del audio
        let isMusicEnabled = true; 
        let areSfxEnabled = true; 
        let synthsInitialized = false; // Flag to track synth initialization
        let synthEat, synthEatNoise, synthBadEat, synthWarning, synthTimeout, synthGameOver, synthStartGame, synthWin, synthCoinNoise, synthCoinChime;
        let synthModeSwitch, synthModeSelect;
        let sfxGain;


        // --- Configuración para la animación de parpadeo del high score ---
        let blinkAnimation = {
            active: false,
            startTime: 0,
            rowIndex: -1,
            duration: 2000,
            interval: 250
        };

        // Animation data for streak multiplier display
        let streakAnimation = {
            active: false,
            value: '',
            color: '',
            startTime: 0
        };

        function startStreakAnimation(multiplier) {
            const text = `x${Number.isInteger(multiplier) ? multiplier : multiplier.toFixed(1)}`;
            let color = '#FF0000';
            if (multiplier > 2 && multiplier <= 3.5) {
                color = '#FFFF00';
            } else if (multiplier > 3.5 && multiplier <= 4.5) {
                color = '#00FF00';
            } else if (multiplier > 4.5) {
                color = '#EE82EE';
            }
            streakAnimation = { active: true, value: text, color, startTime: Date.now() };
        }

        function drawStreakAnimation(head) {
            if (!streakAnimation.active) return;
            const elapsed = Date.now() - streakAnimation.startTime;
            if (elapsed >= STREAK_ANIMATION_DURATION) {
                streakAnimation.active = false;
                return;
            }
            const alpha = 1 - (elapsed / STREAK_ANIMATION_DURATION);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = streakAnimation.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `${Math.floor(GRID_SIZE * 0.5)}px 'Press Start 2P'`;
            const x = head.x * GRID_SIZE + GRID_SIZE / 2;
            const y = head.y * GRID_SIZE - 6;
            ctx.fillText(streakAnimation.value, x, y);
            ctx.restore();
        }
        
        // --- Funciones de Carga y Aplicación de Jugadores ---
        function loadWorldImages() {
            Object.entries(worldImagesConfig).forEach(([id, cfg]) => {
                worldCoverImages[id].src = cfg.cover;
                worldCompleteImages[id].src = cfg.complete;
            });

            levelCompleteImg.src = 'https://i.imgur.com/rxdqSm2.png';
            defeatImg.src = 'https://i.imgur.com/tRk0gWB.png';

            freeModeCoverImg.src = 'https://i.imgur.com/5WQnA4G.png';
            freeModeEndImg.src = 'https://i.imgur.com/ZtQwxXW.png';
            freeModeInactivityImg.src = 'https://i.imgur.com/TRKB4f3.png';
            classificationModeCoverImg.src = 'https://i.imgur.com/EaIYb0R.png';
            classificationDifficultyImages.principiante.src = 'https://i.imgur.com/1VU204A.png';
            classificationDifficultyImages.explorador.src = 'https://i.imgur.com/z1PMcIx.png';
            classificationDifficultyImages.veterano.src = 'https://i.imgur.com/YGLj8Ss.png';
            classificationDifficultyImages.legendario.src = 'https://i.imgur.com/OQw0DGB.png';

            mazeModeCoverImg.src = 'https://i.imgur.com/6zcf86e.png';
            mazeLevelCoverImg.src = 'https://i.imgur.com/az6r9zu.png';
            mazeFailImg.src = 'https://i.imgur.com/tRk0gWB.png';
            mazePartialImg.src = 'https://i.imgur.com/04vASxK.png';
            mazePerfectImg.src = 'https://i.imgur.com/YKVlhix.png';
            mazeCompleteImg.src = 'https://i.imgur.com/0s9b6JB.png';
            mazeFinalImg.src = 'https://i.imgur.com/dga8Z3q.png';
            mazeAllStarsImg.src = 'https://i.imgur.com/grMD2kr.png';
            timeoutImg.src = 'https://i.imgur.com/UdDDj2s.png';
            starFullImg.src = 'https://i.imgur.com/mJU2iIm.png';
            starEmptyImg.src = 'https://i.imgur.com/M4FDVgp.png';


            const allWorldImages = [
                ...Object.values(worldCoverImages),
                ...Object.values(worldCompleteImages),
                levelCompleteImg, defeatImg,
                freeModeCoverImg, freeModeEndImg, freeModeInactivityImg, classificationModeCoverImg,
                ...Object.values(classificationDifficultyImages),
                mazeModeCoverImg, mazeLevelCoverImg,
                mazeFailImg, mazePartialImg, mazePerfectImg,
                mazeCompleteImg, mazeFinalImg, mazeAllStarsImg, timeoutImg,
                starFullImg, starEmptyImg
            ];

            allWorldImages.forEach(img => {
                img.onload = () => {
                    worldImagesLoaded++;
                    if (worldImagesLoaded === totalWorldImagesToLoad) {
                        console.log("Todas las imágenes de mundo, completado de mundo, completado de nivel, derrota, modo libre, modo clasificación y modo laberinto cargadas.");
                        if (ctx && (
                            (gameMode === 'levels' && (screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0) && !screenState.gameActuallyStarted) || 
                            screenState.showWorldCompleteCover > 0 ||
                            (gameMode === 'freeMode' && screenState.showFreeModeCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'classification' && screenState.showClassificationCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'maze' && screenState.showMazeCover && !screenState.gameActuallyStarted)
                            )) {
                           requestAnimationFrame(draw);
                        }
                    }
                };
                 img.onerror = () => {
                    console.error(`Error al cargar imagen: ${img.src}`);
                    worldImagesLoaded++; 
                     if (worldImagesLoaded === totalWorldImagesToLoad) {
                        console.log("Proceso de carga de imágenes de mundo/nivel/derrota/modo libre/modo clasificación/modo laberinto finalizado (con errores).");
                         if (ctx && (
                            (gameMode === 'levels' && (screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0) && !screenState.gameActuallyStarted) || 
                            screenState.showWorldCompleteCover > 0 ||
                            (gameMode === 'freeMode' && screenState.showFreeModeCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'classification' && screenState.showClassificationCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'maze' && screenState.showMazeCover && !screenState.gameActuallyStarted)
                            )) {
                            requestAnimationFrame(draw);
                        }
                    }
                };
            });
        }

        function loadModeSelectionImages() {
            modeSelectIntroImg.src = 'https://i.imgur.com/xEJ0bgm.png';
            modeSelectLevelsImg.src = 'https://i.imgur.com/KxnNVqC.png';
            modeSelectFreeImg.src = 'https://i.imgur.com/5WQnA4G.png';
            modeSelectClassificationImg.src = 'https://i.imgur.com/EaIYb0R.png';
            modeSelectMazeImg.src = 'https://i.imgur.com/Gzw5WNt.png';

            [modeSelectIntroImg, modeSelectLevelsImg, modeSelectFreeImg, modeSelectClassificationImg, modeSelectMazeImg].forEach(img => {
                img.onload = () => { if (showModeSelect && ctx) requestAnimationFrame(draw); };
                img.onerror = () => { console.error(`Error al cargar imagen: ${img.src}`); if (showModeSelect && ctx) requestAnimationFrame(draw); };
            });
        }

        function loadSkinImages() {
            classicSnakeHeadLeftImg.src = 'https://i.imgur.com/fcZoVkW.png';
            classicSnakeHeadDownImg.src = 'https://i.imgur.com/kCgKrBZ.png';
            classicFoodImg.src = 'https://i.imgur.com/fOSSwUX.png';
            snakeBodyTexture.src = 'https://i.imgur.com/thcLCXi.png';
            snakeBodyTextureVertical.src = 'https://i.imgur.com/aDYe0ek.png';
            snakeTailTexture.src = 'https://i.imgur.com/3uFq8ID.png';
            snakeTailTextureUp.src = 'https://i.imgur.com/npkMGwK.png';
            catTailTextureUp.src = 'https://i.imgur.com/5RSk7Z5.png';
            orangeCatTailTextureUp.src = 'https://i.imgur.com/auo3BQl.png';
            orangeCatCornerTextureA.src = 'https://i.imgur.com/AncaSaL.png';
            orangeCatCornerTextureB.src = 'https://i.imgur.com/7BODiGZ.png';
            snakeCornerTextureA.src = 'https://i.imgur.com/fVJRbzv.png';
            snakeCornerTextureB.src = 'https://i.imgur.com/pvhD811.png';

            sceneGrassBgImg.src = 'https://i.imgur.com/DPBCWp1.png';
            sceneGrassBorderImg.src = '';
            sceneVolcanoBgImg.src = 'https://i.imgur.com/lGxjqbV.png';
            sceneVolcanoBorderImg.src = '';
            sceneAceraGrandeBgImg.src = 'https://i.imgur.com/WOVZvPK.png';
            sceneAceraPequenaBgImg.src = 'https://i.imgur.com/2ac9Tnk.png';
            sceneAguaBgImg.src = 'https://i.imgur.com/uM0IkxC.png';
            sceneBaldosaColoresBgImg.src = 'https://i.imgur.com/q0x4GiW.png';
            sceneCaminoPiedraBgImg.src = 'https://i.imgur.com/Xkq8aTf.png';
            sceneCaminoPiedraMusgoBgImg.src = 'https://i.imgur.com/X9RuEBp.png';
            sceneCaminoHierbaPiedraBgImg.src = 'https://i.imgur.com/yVHyjAt.png';
            sceneCebraBgImg.src = 'https://i.imgur.com/qTYu0bA.png';
            sceneHalloweenBgImg.src = 'https://i.imgur.com/T4qwjxj.png';
            sceneHieloBgImg.src = 'https://i.imgur.com/m2vwtBN.png';
            sceneLadrilloBgImg.src = 'https://i.imgur.com/2DuLbzT.png';
            sceneMaderaBgImg.src = 'https://i.imgur.com/RNXAoEZ.png';
            sceneBaldosaBlancaBgImg.src = 'https://i.imgur.com/ShzWBiX.png';
            sceneBaldosaBeigeBgImg.src = 'https://i.imgur.com/Qm3W9er.png';
            sceneRocasBgImg.src = 'https://i.imgur.com/XCZ7Z6h.png';
            sceneTejadoBgImg.src = 'https://i.imgur.com/takLFr9.png';
            sceneTierraBgImg.src = 'https://i.imgur.com/UJUSLTz.png';
            sceneTribalBgImg.src = 'https://i.imgur.com/X9l4k2m.png';
            sceneDesiertoBgImg.src = 'https://i.imgur.com/22F9XHL.png';
            scenePlayaBgImg.src = 'https://i.imgur.com/TIOY4Ae.png';
            sceneEspacioBgImg.src = 'https://i.imgur.com/OV74OfK.png';
            sceneCarreteraBgImg.src = 'https://i.imgur.com/9jDsM11.png';
            sceneEstrellaNeonBgImg.src = 'https://i.imgur.com/OAXNslj.png';
            sceneSerpientesNeonBgImg.src = 'https://i.imgur.com/B60wRhn.png';
            sceneFormasNeonBgImg.src = 'https://i.imgur.com/cuJd24Z.png';
            sceneCuadradosNeonBgImg.src = 'https://i.imgur.com/mQRM5QL.png';
            sceneXNeonBgImg.src = 'https://i.imgur.com/v4tEMkn.png';

            catHeadLeftImg.src = 'https://i.imgur.com/apghsdf.png';
            catHeadDownImg.src = 'https://i.imgur.com/41vw2Cl.png';
            catBodyTexture.src = 'https://i.imgur.com/uJQ5TXv.png';
            catBodyTextureVertical.src = 'https://i.imgur.com/xoDatQ4.png';
            catTailTexture.src = 'https://i.imgur.com/DFw5YoI.png';
            blackCatTailTextureUp.src = 'https://i.imgur.com/633xXuR.png';
            blackCatTailTexture.src = 'https://i.imgur.com/M9Wj2a9.png';
            blackCatCornerTextureA.src = 'https://i.imgur.com/uvYf3J7.png';
            blackCatCornerTextureB.src = 'https://i.imgur.com/xCaavi5.png';

            blackCatHeadLeftImg.src = 'https://i.imgur.com/SBD6RRR.png';
            blackCatHeadDownImg.src = 'https://i.imgur.com/LqfhRxT.png';
            blackCatBodyTexture.src = 'https://i.imgur.com/3JQwfCg.png';
            blackCatBodyTextureVertical.src = 'https://i.imgur.com/RnEdT45.png';

            blackCatReactionPreEatLeftImg.src = 'https://i.imgur.com/QK7DYU1.png';
            blackCatReactionPreEatDownImg.src = 'https://i.imgur.com/jsyAOEW.png';
            blackCatReactionEatLeftImg.src = 'https://i.imgur.com/P7GuD78.png';
            blackCatReactionEatDownImg.src = 'https://i.imgur.com/L3HDO7u.png';
            blackCatReactionEatGoldenLeftImg.src = 'https://i.imgur.com/jS6x1MR.png';
            blackCatReactionEatGoldenDownImg.src = 'https://i.imgur.com/LHXElRb.png';
            blackCatReactionEatSpeedLeftImg.src = 'https://i.imgur.com/Ofj3rve.png';
            blackCatReactionEatSpeedDownImg.src = 'https://i.imgur.com/gy2g1lL.png';
            blackCatReactionEatFalseLeftImg.src = 'https://i.imgur.com/RM92MFm.png';
            blackCatReactionEatFalseDownImg.src = 'https://i.imgur.com/8tGbhDb.png';
            blackCatReactionEatMirrorLeftImg.src = 'https://i.imgur.com/CiYmqiF.png';
            blackCatReactionEatMirrorDownImg.src = 'https://i.imgur.com/xd5gub1.png';

            orangeCatHeadLeftImg.src = 'https://i.imgur.com/XyBysQJ.png';
            orangeCatHeadDownImg.src = 'https://i.imgur.com/lI3mijf.png';
            orangeCatBodyTexture.src = 'https://i.imgur.com/SsaQis3.png';
            orangeCatBodyTextureVertical.src = 'https://i.imgur.com/XZBdrBs.png';
            orangeCatTailTexture.src = 'https://i.imgur.com/LH4XCsn.png';
            orangeCatReactionPreEatLeftImg.src = 'https://i.imgur.com/nvnGTuQ.png';
            orangeCatReactionPreEatDownImg.src = 'https://i.imgur.com/Wgms2iw.png';
            orangeCatReactionEatLeftImg.src = 'https://i.imgur.com/xxAur2G.png';
            orangeCatReactionEatDownImg.src = 'https://i.imgur.com/PThr1g7.png';
            orangeCatReactionEatGoldenLeftImg.src = 'https://i.imgur.com/RVTq3k5.png';
            orangeCatReactionEatGoldenDownImg.src = 'https://i.imgur.com/5dm93GG.png';
            orangeCatReactionEatSpeedLeftImg.src = 'https://i.imgur.com/UEqlf8J.png';
            orangeCatReactionEatSpeedDownImg.src = 'https://i.imgur.com/YTyByg9.png';
            orangeCatReactionEatFalseLeftImg.src = 'https://i.imgur.com/M10kEFU.png';
            orangeCatReactionEatFalseDownImg.src = 'https://i.imgur.com/UQ6Hsft.png';
            orangeCatReactionEatMirrorLeftImg.src = 'https://i.imgur.com/MCbxCCd.png';
            orangeCatReactionEatMirrorDownImg.src = 'https://i.imgur.com/wDELjYE.png';

            rubiSnakeHeadUpDownImg.src = 'https://i.imgur.com/XQzDVMk.png';
            rubiSnakeHeadLeftImg.src = 'https://i.imgur.com/XQzDVMk.png'; 
            rubiSnakeFoodImg.src = 'https://i.imgur.com/wXIXaQZ.png';

            aitorSnakeHeadUpDownImg.src = 'https://i.imgur.com/WBS3C4N.png';
            aitorSnakeHeadLeftImg.src = 'https://i.imgur.com/IfYIEkv.png';
            aitorSnakeFoodImg.src = 'https://i.imgur.com/rUCsqoq.png'; 

            noemiSnakeHeadUpDownImg.src = 'https://i.imgur.com/h84RIhq.png';
            noemiSnakeHeadLeftImg.src = 'https://i.imgur.com/TU4CgRq.png';
            noemiSnakeFoodImg.src = 'https://i.imgur.com/2bGXbM1.png';
            
            maraSnakeHeadUpDownImg.src = 'https://i.imgur.com/YvQ2uni.png';
            maraSnakeHeadLeftImg.src = 'https://i.imgur.com/oiBGoud.png';
            maraSnakeFoodImg.src = 'https://i.imgur.com/krE9lwu.png';

            almuSnakeHeadUpDownImg.src = 'https://i.imgur.com/2HqLxxp.png';
            almuSnakeHeadLeftImg.src = 'https://i.imgur.com/27Q7QvA.png';
            almuSnakeFoodImg.src = 'https://i.imgur.com/Lcurg08.png';

            mimiSnakeHeadUpDownImg.src = 'https://i.imgur.com/2UnTxTM.png';
            mimiSnakeHeadLeftImg.src = 'https://i.imgur.com/GjJrvUA.png';
            mimiSnakeFoodImg.src = 'https://i.imgur.com/kgOjgCI.png';
            reactionPreEatLeftImg.src = 'https://i.imgur.com/0FK1plF.png';
            reactionPreEatDownImg.src = 'https://i.imgur.com/dKMfnD6.png';
            reactionEatLeftImg.src = 'https://i.imgur.com/pzH12dx.png';
            reactionEatDownImg.src = 'https://i.imgur.com/zNHi8Ov.png';
            reactionEatGoldenLeftImg.src = 'https://i.imgur.com/RrRObU7.png';
            reactionEatGoldenDownImg.src = 'https://i.imgur.com/bI4HcjQ.png';
            reactionEatSpeedLeftImg.src = 'https://i.imgur.com/rNTNh6T.png';
            reactionEatSpeedDownImg.src = 'https://i.imgur.com/rA6clY3.png';
            reactionEatFalseLeftImg.src = 'https://i.imgur.com/4z2BzX0.png';
            reactionEatFalseDownImg.src = 'https://i.imgur.com/LxkP3jV.png';
            reactionEatMirrorLeftImg.src = 'https://i.imgur.com/X561Smv.png';
            reactionEatMirrorDownImg.src = 'https://i.imgur.com/0dWecr1.png';

            Object.values(FOODS).forEach(food => {
                if (food.url) food.asset.src = food.url;
            });
            obstacleImg.src = 'https://i.imgur.com/wk1u29m.png';
            lightningYellowImg.src = 'https://i.imgur.com/AJL2p3j.png';
            lightningRedImg.src = 'https://i.imgur.com/4sNOTpi.png';
            
                const allImageObjects = [
                    classicSnakeHeadLeftImg, classicSnakeHeadDownImg, classicFoodImg,
                    snakeBodyTexture, snakeBodyTextureVertical, snakeTailTexture, snakeTailTextureUp,
                    snakeCornerTextureA, snakeCornerTextureB,
                    rubiSnakeHeadUpDownImg, rubiSnakeHeadLeftImg, rubiSnakeFoodImg,
                    aitorSnakeHeadUpDownImg, aitorSnakeHeadLeftImg, aitorSnakeFoodImg,
                    noemiSnakeHeadUpDownImg, noemiSnakeHeadLeftImg, noemiSnakeFoodImg,
                    maraSnakeHeadUpDownImg, maraSnakeHeadLeftImg, maraSnakeFoodImg,
                    almuSnakeHeadUpDownImg, almuSnakeHeadLeftImg, almuSnakeFoodImg,
                    mimiSnakeHeadUpDownImg, mimiSnakeHeadLeftImg, mimiSnakeFoodImg,
                    catHeadLeftImg, catHeadDownImg, catBodyTexture, catBodyTextureVertical,
                    catTailTexture, catTailTextureUp,
                    blackCatHeadLeftImg, blackCatHeadDownImg, blackCatBodyTexture,
                    blackCatBodyTextureVertical, blackCatTailTexture, blackCatTailTextureUp,
                    blackCatCornerTextureA, blackCatCornerTextureB,
                    blackCatReactionPreEatLeftImg, blackCatReactionPreEatDownImg,
                    blackCatReactionEatLeftImg, blackCatReactionEatDownImg,
                    blackCatReactionEatGoldenLeftImg, blackCatReactionEatGoldenDownImg,
                    blackCatReactionEatSpeedLeftImg, blackCatReactionEatSpeedDownImg,
                    blackCatReactionEatFalseLeftImg, blackCatReactionEatFalseDownImg,
                    blackCatReactionEatMirrorLeftImg, blackCatReactionEatMirrorDownImg,
                    orangeCatHeadLeftImg, orangeCatHeadDownImg, orangeCatBodyTexture,
                    orangeCatBodyTextureVertical, orangeCatTailTexture, orangeCatTailTextureUp,
                    orangeCatCornerTextureA, orangeCatCornerTextureB,
                    reactionPreEatLeftImg, reactionPreEatDownImg,
                    orangeCatReactionPreEatLeftImg, orangeCatReactionPreEatDownImg,
                    reactionEatLeftImg, reactionEatDownImg,
                    reactionEatGoldenLeftImg, reactionEatGoldenDownImg,
                    reactionEatSpeedLeftImg, reactionEatSpeedDownImg,
                    reactionEatFalseLeftImg, reactionEatFalseDownImg,
                    reactionEatMirrorLeftImg, reactionEatMirrorDownImg,
                    orangeCatReactionEatLeftImg, orangeCatReactionEatDownImg,
                    orangeCatReactionEatGoldenLeftImg, orangeCatReactionEatGoldenDownImg,
                    orangeCatReactionEatSpeedLeftImg, orangeCatReactionEatSpeedDownImg,
                    orangeCatReactionEatFalseLeftImg, orangeCatReactionEatFalseDownImg,
                    orangeCatReactionEatMirrorLeftImg, orangeCatReactionEatMirrorDownImg,
                    sceneGrassBgImg, sceneVolcanoBgImg,
                    sceneAceraGrandeBgImg, sceneAceraPequenaBgImg,
                    sceneAguaBgImg, sceneBaldosaColoresBgImg,
                    sceneCaminoPiedraBgImg, sceneCaminoPiedraMusgoBgImg,
                    sceneCaminoHierbaPiedraBgImg, sceneCebraBgImg,
                    sceneHalloweenBgImg, sceneHieloBgImg,
                    sceneLadrilloBgImg, sceneMaderaBgImg,
                    sceneBaldosaBlancaBgImg, sceneBaldosaBeigeBgImg,
                    sceneRocasBgImg, sceneTejadoBgImg,
                    sceneTierraBgImg, sceneTribalBgImg,
                    sceneDesiertoBgImg, scenePlayaBgImg,
                    sceneEspacioBgImg, sceneCarreteraBgImg,
                    sceneEstrellaNeonBgImg, sceneSerpientesNeonBgImg,
                    sceneFormasNeonBgImg, sceneCuadradosNeonBgImg,
                    sceneXNeonBgImg,
                    obstacleImg, lightningYellowImg, lightningRedImg,
                    ...Object.values(FOODS).map(f => f.asset)
                ];

            allImageObjects.forEach(imgObj => {
                imgObj.onload = () => {
                    console.log(`Imagen ${imgObj.src.split('/').pop()} cargada.`);
                    if (ctx && (gameOver || !gameIntervalId || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                        requestAnimationFrame(draw);
                    }
                };
                imgObj.onerror = () => {
                    console.error(`Error al cargar la imagen: ${imgObj.src}`);
                    if (ctx && (gameOver || !gameIntervalId || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                        requestAnimationFrame(draw);
                    }
                };
            });
        }

        function applySkin(skinName) {
            currentSkin = skinName;
            console.log(`Jugador aplicado: ${currentSkin}`);

            if (!gameIntervalId && ctx) {
                draw();
            }
        }

        function applyFood(foodName) {
            currentFood = foodName;
            console.log(`Comestible aplicado: ${currentFood}`);
            if (!gameIntervalId && ctx) {
                draw();
            }
        }

        function applyScene(sceneName) {
            currentScene = sceneName;
            console.log(`Escenario aplicado: ${currentScene}`);
            if (!gameIntervalId && ctx) {
                draw();
            }
        }
        
        function resizeGameElements() {
            if (!gameContainer || !canvasEl ) { 
                console.error("Error: gameContainer or canvasEl no están definidos en resizeGameElements.");
                return;
            }
            const containerComputedStyle = getComputedStyle(gameContainer);
            const canvasComputedStyle = getComputedStyle(canvasEl);

           const containerPadding = 2 * parseFloat(containerComputedStyle.paddingLeft);
           let availableWidth = gameContainer.clientWidth - containerPadding;

           const canvasBorderWidth = 2 * parseFloat(canvasComputedStyle.borderLeftWidth);
           availableWidth -= canvasBorderWidth;

            const availableHeight =
                gameContainer.clientHeight -
                topInfoBar.offsetHeight -
                setupControls.offsetHeight;

           GRID_SIZE = Math.floor(
                Math.min(availableWidth, availableHeight) / TILE_COUNT
            );

           canvasEl.width = TILE_COUNT * GRID_SIZE;
           canvasEl.height = TILE_COUNT * GRID_SIZE;


            tileCountX = TILE_COUNT;
            tileCountY = TILE_COUNT;

            // If a panel is open, re-calculate its position after resize
            if (!settingsPanel.classList.contains("settings-panel-hidden")) {
                positionPanel(settingsPanel);
                applyScrollbarPadding(settingsPanelContent);
            }
            if (!infoPanel.classList.contains("info-panel-hidden")) {
                positionPanel(infoPanel);
                applyScrollbarPadding(infoPanelContent);
            }
            if (specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden")) {
                positionPanel(specificInfoPanel);
                applyScrollbarPadding(specificInfoContent);
            }
            if (freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden")) {
                positionPanel(freeSettingsPanel);
                applyScrollbarPadding(freeSettingsPanelContent);
            }
            if (resetConfirmPanel && !resetConfirmPanel.classList.contains("reset-panel-hidden")) {
                positionPanel(resetConfirmPanel);
                applyScrollbarPadding(resetConfirmPanelContent);
            }
            if (storePanel && !storePanel.classList.contains("store-panel-hidden")) {
                positionPanel(storePanel);
                applyScrollbarPadding(storePanel.querySelector('.panel-content'));
            }
            if (profilePanel && !profilePanel.classList.contains("profile-panel-hidden")) {
                positionPanel(profilePanel);
                applyScrollbarPadding(profilePanel.querySelector('.panel-content'));
            }


            if (ctx && (gameIntervalId || gameOver || snake.length > 0 || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                draw();
            } else if (ctx) {
                ctx.fillStyle = "#374151";
                ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            }
        }

        function resetGameUIDisplays() {
            updateCoinDisplay();
            updateGemDisplay();
            scoreValueDisplay.textContent = "0";
            if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
            } else if (gameMode === 'classification') {
                timeLengthValueEl.textContent = formatTime(0);
            } else { // freeMode
                timeLengthValueEl.textContent = initialSnakeLength;
            }
            updateTargetScoreDisplay();
        }

        function positionPanel(panelElement) {
            if (panelElement.classList.contains("centered-panel")) {
                panelElement.style.top = "50%";
                panelElement.style.bottom = "auto";
                panelElement.style.height = "auto";
                panelElement.style.left = "50%";
                return;
            }

            if (!panelElement || !gameContainer || !canvasEl) {
                console.error("positionPanel: Elemento(s) clave(s) para el posicionamiento no encontrado(s)." );
                return;
            }

            const canvasRect = canvasEl.getBoundingClientRect();

            panelElement.style.top = canvasRect.top + "px";
            panelElement.style.left = canvasRect.left + "px";
            panelElement.style.height = canvasRect.height + "px";
            panelElement.style.width = canvasRect.width + "px";
            panelElement.style.bottom = "auto";
        }

        function updateMainButtonStates() {
            const isSettingsVisible = !settingsPanel.classList.contains("settings-panel-hidden") && settingsPanel.classList.contains("panel-visible");
            const isInfoVisible = !infoPanel.classList.contains("info-panel-hidden") && infoPanel.classList.contains("panel-visible");
            const isFreeSettingsVisible = freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden") && freeSettingsPanel.classList.contains("panel-visible");
            const isConfigMenuVisible = !configMenuPanel.classList.contains("config-menu-panel-hidden") && configMenuPanel.classList.contains("panel-visible");
            const isGenericMenuVisible = !genericMenuPanel.classList.contains("generic-menu-panel-hidden") && genericMenuPanel.classList.contains("panel-visible");
            const isStoreVisible = storePanel && !storePanel.classList.contains("store-panel-hidden") && storePanel.classList.contains("panel-visible");
            const isProfileVisible = profilePanel && !profilePanel.classList.contains("profile-panel-hidden") && profilePanel.classList.contains("panel-visible");
            const isAnyMainPanelEffectivelyOpen = isSettingsVisible || isInfoVisible || isFreeSettingsVisible || isConfigMenuVisible || isGenericMenuVisible || isStoreVisible || isProfileVisible;

            if (isAnyMainPanelEffectivelyOpen) {
                startButton.disabled = true;
                restartMazeButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;
                backButtonIcon.src = showModeSelect ? 'https://i.imgur.com/1WrBpTQ.png' : 'https://i.imgur.com/Wvl87cV.png';
                configButtonIcon.src = showModeSelect ? 'https://i.imgur.com/jekDmyV.png' : ((gameMode === 'levels' || gameMode === 'maze') ? 'https://i.imgur.com/IW3a5DA.png' : (gameMode === 'freeMode' ? 'https://i.imgur.com/YIBroBG.png' : 'https://i.imgur.com/jekDmyV.png'));
                return;
            }

            if (gameIntervalId) {
                startButton.disabled = true;
                restartMazeButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;
                backButtonIcon.src = showModeSelect ? 'https://i.imgur.com/1WrBpTQ.png' : 'https://i.imgur.com/Wvl87cV.png';
                configButtonIcon.src = showModeSelect ? 'https://i.imgur.com/jekDmyV.png' : ((gameMode === 'levels' || gameMode === 'maze') ? 'https://i.imgur.com/IW3a5DA.png' : (gameMode === 'freeMode' ? 'https://i.imgur.com/YIBroBG.png' : 'https://i.imgur.com/jekDmyV.png'));
            } else {
                const isWorldIntroCover = screenState.showCoverForWorld > 0 && !screenState.gameActuallyStarted;
                const isWorldCompleteScreen = screenState.showWorldCompleteCover > 0;
                const isLevelCompleteScreen = screenState.showLevelCompleteCover > 0 && !screenState.gameActuallyStarted;
                const isDefeatScreen = screenState.showDefeatCoverForWorld > 0 && !screenState.gameActuallyStarted;
                const isTimeoutScreen = screenState.showTimeoutCover && !screenState.gameActuallyStarted;
                const isFreeModeEndScreen = screenState.showFreeModeEnd && !screenState.gameActuallyStarted;
                const isFreeModeCoverActive = screenState.showFreeModeCover && !screenState.gameActuallyStarted;
                const isClassificationCoverActive = screenState.showClassificationCover && !screenState.gameActuallyStarted;
                const isMazeCoverActive = screenState.showMazeCover && !screenState.gameActuallyStarted;
                const isMazeResultScreen = screenState.mazeResultType && !screenState.gameActuallyStarted;
                const isModeSelectActive = showModeSelect;
                const isModeSelectIntro = isModeSelectActive && MODE_SELECT_ORDER[modeSelectIndex] === 'intro';
                const isSelectedWorldLocked = isWorldIntroCover && displayWorld > maxUnlockedWorld;
                const isSelectedMazeLocked = isMazeCoverActive && displayMazeLevel > currentMazeLevel;

                startButton.disabled = isModeSelectIntro || isSelectedWorldLocked || isSelectedMazeLocked;
                restartMazeButton.disabled = restartMazeButton.classList.contains('hidden');
                configButton.disabled = false;
                backButton.disabled = false;

                if (isModeSelectActive) {
                    backButtonIcon.src = 'https://i.imgur.com/1WrBpTQ.png';
                    configButtonIcon.src = 'https://i.imgur.com/jekDmyV.png';
                } else {
                    backButtonIcon.src = 'https://i.imgur.com/Wvl87cV.png';
                    configButtonIcon.src = (gameMode === 'levels' || gameMode === 'maze') ? 'https://i.imgur.com/IW3a5DA.png' : (gameMode === 'freeMode' ? 'https://i.imgur.com/YIBroBG.png' : 'https://i.imgur.com/jekDmyV.png');
                }

                if (isModeSelectActive) {
                    startButton.textContent = "SELECCIONAR";
                } else if (isLevelCompleteScreen) {
                    // Text is set by handleLevelsModeEnd
                } else if (isWorldCompleteScreen) {
                    // Text is set by handleLevelsModeEnd
                } else if (isDefeatScreen || isTimeoutScreen || isFreeModeEndScreen) {
                    startButton.textContent = "REINTENTAR";
                } else if (isMazeResultScreen) {
                    // Text already set by handleMazeModeEnd
                } else if (isWorldIntroCover || isFreeModeCoverActive || isClassificationCoverActive || isMazeCoverActive) {
                    startButton.textContent = "EMPEZAR";
                } else if (gameOver && (gameMode === 'freeMode' || gameMode === 'classification')) {
                    startButton.textContent = "EMPEZAR";
                } else if (gameOver && gameMode === 'levels') {
                    // finalizeGameOver (via handleLevelsModeEnd) sets the text
                    // If we are here after closing settings, it should be "Empezar"
                     if (!isWorldIntroCover && !isWorldCompleteScreen && !isLevelCompleteScreen && !isDefeatScreen) {
                        startButton.textContent = "EMPEZAR";
                    }
                } else { 
                    startButton.textContent = "EMPEZAR";
                }
                
                const isAnyCoverScreenActive = isWorldIntroCover || isWorldCompleteScreen || isLevelCompleteScreen || isDefeatScreen || isTimeoutScreen || isFreeModeEndScreen || isFreeModeCoverActive || isClassificationCoverActive || isMazeCoverActive || isMazeResultScreen || isModeSelectActive;
                if (!isAnyCoverScreenActive && !gameOver) {
                     if (isMusicEnabled && generalBackgroundMusic && generalBackgroundMusic.paused) {
                        if (inGameBackgroundMusic && !inGameBackgroundMusic.paused) inGameBackgroundMusic.pause();
                        generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (updateMainButtonStates):", e));
                    }
                }
            }
        }

        function applyScrollbarPadding(el) {
            if (!el) return;
            const needsPadding = el.scrollHeight > el.clientHeight + 1;
            if (needsPadding) el.classList.add('scroll-padding');
            else el.classList.remove('scroll-padding');
        }

        function matchPanelSizeWithElement(sourceElement, targetPanel) {
            if (!sourceElement || !targetPanel) return;
            const srcRect = sourceElement.getBoundingClientRect();
            targetPanel.style.top = srcRect.top + 'px';
            targetPanel.style.left = srcRect.left + 'px';
            targetPanel.style.height = srcRect.height + 'px';
            targetPanel.style.width = srcRect.width + 'px';
        }

        // --- Panel Management Refactor ---
        function togglePanel(panelElement, contentContainer, show, instant = false) {
            if (!panelElement) {
                console.error("togglePanel: panelElement no encontrado.");
                return;
            }
            const panelId = panelElement.id;
            let hiddenClassName;
            const visibleClassName = "panel-visible";

            if (panelId === "settings-panel") hiddenClassName = "settings-panel-hidden";
            else if (panelId === "info-panel") hiddenClassName = "info-panel-hidden";
            else if (panelId === "specific-info-panel") hiddenClassName = "specific-info-panel-hidden";
            else if (panelId === "free-settings-panel") hiddenClassName = "free-settings-panel-hidden";
            else if (panelId === "reset-confirmation-panel") hiddenClassName = "reset-panel-hidden";
            else if (panelId === "config-menu-panel") hiddenClassName = "config-menu-panel-hidden";
            else if (panelId === "generic-menu-panel") hiddenClassName = "generic-menu-panel-hidden";
            else if (panelId === "store-panel") hiddenClassName = "store-panel-hidden";
            else if (panelId === "profile-panel") hiddenClassName = "profile-panel-hidden";
            else if (panelId === "purchase-confirmation-panel") hiddenClassName = "purchase-confirmation-panel-hidden";
            else if (panelId === "delete-confirmation-panel") hiddenClassName = "delete-confirmation-panel-hidden";
            else if (panelId === "out-of-lives-panel") hiddenClassName = "out-of-lives-panel-hidden";
            else if (panelId === "select-confirmation-panel") hiddenClassName = "select-confirmation-panel-hidden";
            else {
                console.error("togglePanel: Clase oculta no definida para el panel:", panelId);
                return;
            }

            if (show) {
                if (panelElement === settingsPanel && !infoPanel.classList.contains("info-panel-hidden")) {
                    togglePanel(infoPanel, infoPanelContent, false);
                }
                if (panelElement === settingsPanel && freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden")) {
                    togglePanel(freeSettingsPanel, freeSettingsPanelContent, false);
                }
                if (panelElement === infoPanel && !settingsPanel.classList.contains("settings-panel-hidden")) {
                    togglePanel(settingsPanel, settingsPanelContent, false);
                }
                if (panelElement === freeSettingsPanel && !settingsPanel.classList.contains("settings-panel-hidden")) {
                    togglePanel(settingsPanel, settingsPanelContent, false);
                }
                if (panelElement !== specificInfoPanel && specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden")) {
                    togglePanel(specificInfoPanel, specificInfoContent, false);
                }

                panelElement.classList.remove(hiddenClassName);
                positionPanel(panelElement);

                if (instant) {
                    panelElement.style.transition = 'none';
                    panelElement.classList.add(visibleClassName);
                    if (panelElement.classList.contains('centered-panel')) {
                        panelElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    } else {
                        panelElement.style.transform = 'scale(1)';
                    }
                    const targetScrollElement = contentContainer || panelElement;
                    if (targetScrollElement) {
                        targetScrollElement.scrollTop = 0;
                        applyScrollbarPadding(targetScrollElement);
                    }
                    requestAnimationFrame(() => { panelElement.style.transition = ''; });
                } else {
                    if (panelElement.classList.contains('centered-panel')) {
                        panelElement.style.transform = 'translate(-50%, -50%) scale(0)';
                    } else {
                        panelElement.style.transform = 'scale(0)';
                    }
                    requestAnimationFrame(() => {
                        panelElement.classList.add(visibleClassName);
                        if (panelElement.classList.contains('centered-panel')) {
                            panelElement.style.transform = 'translate(-50%, -50%) scale(1)';
                        } else {
                            panelElement.style.transform = 'scale(1)';
                        }
                        const targetScrollElement = contentContainer || panelElement;
                        if (targetScrollElement) {
                            targetScrollElement.scrollTop = 0;
                            applyScrollbarPadding(targetScrollElement);
                        }
                    });
                }
                
                startButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;

                if (panelElement === settingsPanel && !gameIntervalId) {
                    skinSelectors.forEach(sel => sel.disabled = false);
                    foodSelectors.forEach(sel => sel.disabled = false);
                    skinControlGroups.forEach(g => g.classList.add("interactive-mode"));
                    foodControlGroups.forEach(g => g.classList.add("interactive-mode"));
                    if (gameMode === 'levels') worldsSelector.disabled = false; else difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                    if (typeof Tone !== 'undefined') {
                        if (panelOpenedFromSplash) {
                            audioControlGroup.classList.remove('hidden');
                            musicVolumeControlGroup.classList.remove('hidden');
                            sfxVolumeControlGroup.classList.remove('hidden');
                            audioToggleSelector.disabled = false;
                            audioControlGroup.classList.add("interactive-mode");
                            musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                            sfxVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'music_only');
                            if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                            else musicVolumeControlGroup.classList.remove("interactive-mode");
                            if (!sfxVolumeSlider.disabled) sfxVolumeControlGroup.classList.add("interactive-mode");
                            else sfxVolumeControlGroup.classList.remove("interactive-mode");
                        } else {
                            audioToggleSelector.disabled = true;
                            musicVolumeSlider.disabled = true;
                            sfxVolumeSlider.disabled = true;
                            audioControlGroup.classList.add('hidden');
                            musicVolumeControlGroup.classList.add('hidden');
                            sfxVolumeControlGroup.classList.add('hidden');
                            audioControlGroup.classList.remove("interactive-mode");
                            musicVolumeControlGroup.classList.remove("interactive-mode");
                            sfxVolumeControlGroup.classList.remove("interactive-mode");
                        }
                    }
                    settingsPanel.querySelectorAll('.setting-info-button').forEach(btn => btn.disabled = false);
                }
            } else { // Hiding a panel
                panelElement.classList.remove(visibleClassName);
                if (panelElement.classList.contains('centered-panel')) {
                    panelElement.style.transform = 'translate(-50%, -50%) scale(0)';
                } else {
                    panelElement.style.transform = 'scale(0)';
                }
                setTimeout(() => {
                    panelElement.classList.add(hiddenClassName);
                    panelElement.style.top = '';
                    panelElement.style.bottom = '';
                    panelElement.style.height = '';
                    panelElement.style.width = '';
                    panelElement.style.left = '';
                    panelElement.style.transform = '';
                    // Caller of togglePanel(..., false) is now responsible for updateMainButtonStates
                }, 300);
            }
        }


       function openSettingsPanel() {
            if (panelOpenedFromSplash) {
                settingsPanel.classList.add("centered-panel");
            } else {
                settingsPanel.classList.remove("centered-panel");
                settingsPanel.style.width = '';
                settingsPanel.style.left = '';
            }
            let desiredWidth = '';
            let desiredLeft = '';
            if (panelOpenedFromSplash) {
                const splashContent = document.getElementById('splash-content');
                if (splashContent) {
                    const rect = splashContent.getBoundingClientRect();
                    const margin = 15;
                    desiredWidth = (rect.width - margin * 2) + 'px';
                    desiredLeft = (rect.left + rect.width / 2) + 'px';
                    settingsPanel.style.width = desiredWidth;
                    settingsPanel.style.left = desiredLeft;
                }
            }
            togglePanel(settingsPanel, settingsPanelContent, true);
            if (panelOpenedFromSplash) {
                settingsPanel.style.width = desiredWidth;
                settingsPanel.style.left = desiredLeft;
            }
            updateSfxVolume();
            if (profileInfoButton) profileInfoButton.classList.add('hidden');
            if (playerNameInfoButton) playerNameInfoButton.classList.remove('hidden');
            // Show or hide certain settings when accessed from the splash screen
            if (!gameMode) difficultyControlGroup.classList.add('hidden');
            else difficultyControlGroup.classList.remove('hidden');
            skinControlGroups.forEach(g => g.classList.remove('hidden'));
            foodControlGroups.forEach(g => g.classList.remove('hidden'));
            if (playerNameControlGroup) playerNameControlGroup.classList.remove('hidden');
            if (playerSelectControlGroup) playerSelectControlGroup.classList.add('hidden');
            if (addPlayerControlGroup) addPlayerControlGroup.classList.add('hidden');

            if (panelOpenedFromSplash) {
                difficultyControlGroup.classList.add('hidden');
                skinControlGroups.forEach(g => g.classList.add('hidden'));
                foodControlGroups.forEach(g => g.classList.add('hidden'));
                if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
                resetDataButton.classList.remove('hidden');
                resetDataButton.classList.add('interactive-mode');
            } else {
                resetDataButton.classList.add('hidden');
                resetDataButton.classList.remove('interactive-mode');
            }

            if (gameMode === 'classification' && !panelOpenedFromSplash) {
                if (classificationRankingGroup) {
                    classificationRankingGroup.classList.remove('hidden');
                    populateClassificationRanking();
                }
                skinControlGroups.forEach(g => g.classList.add('hidden'));
                foodControlGroups.forEach(g => g.classList.add('hidden'));
                audioControlGroup.classList.add('hidden');
                musicVolumeControlGroup.classList.add('hidden');
                sfxVolumeControlGroup.classList.add('hidden');
            } else if (classificationRankingGroup) {
                classificationRankingGroup.classList.add('hidden');
            }
            if (gameOver && !gameIntervalId) { // Game is over and not running
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
                
                score = 0; // Reset internal score
                streakMultiplier = 1; // Reset internal streak
                
                if (gameMode === 'levels' || gameMode === 'maze') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    screenState.showFreeModeEnd = false;
                    screenState.showClassificationCover = false;
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    screenState.gameActuallyStarted = false;
                    snake = []; // Vaciar la serpiente para que updateTimeLengthDisplay use initialSnakeLength
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = [];
                }
                resetGameUIDisplays(); // Update UI for score, streak, AND length (if free mode and snake is empty)
                updateGameModeUI(); // This will refresh panel values and target scores
                requestAnimationFrame(draw); // Redraw canvas to show cover
            } else {
                updateGameModeUI(); // Ensure panel reflects current mode when opening during gameplay
            }
        }

        function closeSettingsPanel() {
            const wasSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden");

            togglePanel(settingsPanel, settingsPanelContent, false); // Hides panel

            if (wasSpecificInfoOpen) {
                togglePanel(specificInfoPanel, specificInfoContent, false); // Hides specific info
            }

            if (gameOver && !gameIntervalId) { // If game was over and not running
                if (gameMode === 'levels') {

                    screenState.showCoverForWorld = currentWorld; // Show current world cover
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    
                    // Score and streak should have been reset when settings panel was opened if game was over
                    updateScoreDisplay(); // Ensure score 0 is displayed
                    updateTargetScoreDisplay(); // Ensure correct target is displayed
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true; // Ensure cover is shown when returning from settings
                    screenState.showFreeModeEnd = false;
                    screenState.gameActuallyStarted = false;
                    // Score, streak and snake length (via snake=[]) reset when settings opened
                    updateScoreDisplay();
                    updateTimeLengthDisplay(); // Ensure length is updated based on empty snake array
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true; // Ensure cover is shown when returning from settings
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                }
                updateGameModeUI(); 
                requestAnimationFrame(draw); 
            }
            
            setTimeout(() => { // Ensure buttons are updated after panel animation
                updateMainButtonStates();
            }, 0);
            settingsPanel.classList.remove('centered-panel');

            if (panelOpenedFromSplash && splashScreen && !splashScreen.classList.contains('hidden')) {
                if (gameContainer) gameContainer.classList.add('hidden');
                panelOpenedFromSplash = false;
            }
            if (profileInfoButton) profileInfoButton.classList.add('hidden');
            if (playerNameInfoButton) playerNameInfoButton.classList.remove('hidden');
        }

        function openFreeSettingsPanel() {
            freeSettingsPanel.classList.remove('centered-panel');
            togglePanel(freeSettingsPanel, freeSettingsPanelContent, true);
            if (freeDifficultySelector) {
                freeDifficultySelector.value = freeDifficulty;
            }
           populateFreeSettingsInputs();
            displayHighScoreInPanel();
            updateFreeSettingsLockState();
       }

        function closeFreeSettingsPanel() {
            togglePanel(freeSettingsPanel, freeSettingsPanelContent, false);
            setTimeout(updateMainButtonStates, 0);
            freeSettingsPanel.classList.remove('centered-panel');
        }

        function populateFreeSettingsInputs() {
            const speedFactor = freeModeSettings.speed / FREE_MODE_DEFAULTS.speed;
            freeSpeedInput.value = Math.round(((2 - speedFactor) / 1.5) * 100);
            if (freeSpeedValue) freeSpeedValue.textContent = freeSpeedInput.value;

            freeLifespanToggle.checked = freeModeSettings.initialLifespan > 0;
            freeLifespanInput.value = freeModeSettings.initialLifespan > 0 ? freeModeSettings.initialLifespan / 1000 : 4;
            if (freeLifespanValue) freeLifespanValue.textContent = freeLifespanInput.value;
            freeLifespanInput.disabled = !freeLifespanToggle.checked;

            freeLengthInput.value = freeModeSettings.initialLength;
            if (freeLengthValue) freeLengthValue.textContent = freeLengthInput.value;

            freeGoldenToggle.checked = freeModeSettings.goldenFoodChance > 0;
            freeGoldenChanceInput.value = freeModeSettings.goldenFoodChance > 0 ? freeModeSettings.goldenFoodChance * 100 : 10;
            if (freeGoldenChanceValue) freeGoldenChanceValue.textContent = freeGoldenChanceInput.value;
            freeGoldenLifespanInput.value = freeModeSettings.goldenFoodLifespan / 1000;
            if (freeGoldenLifespanValue) freeGoldenLifespanValue.textContent = freeGoldenLifespanInput.value;
            freeGoldenChanceInput.disabled = freeGoldenLifespanInput.disabled = !freeGoldenToggle.checked;

            freeLightningToggle.checked = !!freeModeSettings.lightningSpawnRange;
            if (freeModeSettings.lightningSpawnRange) {
                freeLightningRange.value = freeModeSettings.lightningSpawnRange[0] / 1000;
            } else {
                freeLightningRange.value = 0;
            }
            if (freeLightningRangeDisplay) {
                freeLightningRangeDisplay.textContent = `${freeLightningRange.value} - ${parseFloat(freeLightningRange.value) + 4}`;
            }
            freeLightningRange.disabled = !freeLightningToggle.checked;
            freeLightningLifespan.value = freeModeSettings.lightningLifespan / 1000;
            if (freeLightningLifespanValue) freeLightningLifespanValue.textContent = freeLightningLifespan.value;
            freeLightningLifespan.disabled = !freeLightningToggle.checked;
            freeRedChance.value = freeModeSettings.redLightningChance * 100;
            if (freeRedChanceValue) freeRedChanceValue.textContent = freeRedChance.value;
            freeRedChance.disabled = !freeLightningToggle.checked;

            freeStreakToggle.checked = freeModeSettings.streakReduction > 0;

            freeFalseToggle.checked = !!freeModeSettings.falseFoodSpawnRange;
            if (freeModeSettings.falseFoodSpawnRange) {
                freeFalseRange.value = freeModeSettings.falseFoodSpawnRange[0] / 1000;
            } else {
                freeFalseRange.value = 0;
            }
            if (freeFalseRangeDisplay) {
                freeFalseRangeDisplay.textContent = `${freeFalseRange.value} - ${parseFloat(freeFalseRange.value) + 4}`;
            }
            freeFalseRange.disabled = !freeFalseToggle.checked;
            freeFalseLifespan.value = freeModeSettings.falseFoodLifespan / 1000;
            if (freeFalseLifespanValue) freeFalseLifespanValue.textContent = freeFalseLifespan.value;
            freeFalseLifespan.disabled = !freeFalseToggle.checked;

            freeMirrorToggle.checked = !!freeModeSettings.mirrorSpawnRange;
            if (freeModeSettings.mirrorSpawnRange) {
                freeMirrorRange.value = freeModeSettings.mirrorSpawnRange[0] / 1000;
            } else {
                freeMirrorRange.value = 0;
            }
            if (freeMirrorRangeDisplay) {
                freeMirrorRangeDisplay.textContent = `${freeMirrorRange.value} - ${parseFloat(freeMirrorRange.value) + 4}`;
            }
            freeMirrorRange.disabled = !freeMirrorToggle.checked;
            freeMirrorLifespan.value = freeModeSettings.mirrorLifespan / 1000;
            if (freeMirrorLifespanValue) freeMirrorLifespanValue.textContent = freeMirrorLifespan.value;
            freeMirrorEffect.value = freeModeSettings.mirrorEffectDuration / 1000;
            if (freeMirrorEffectValue) freeMirrorEffectValue.textContent = freeMirrorEffect.value;
            freeMirrorLifespan.disabled = freeMirrorEffect.disabled = !freeMirrorToggle.checked;

            freeObstacleCount.value = freeModeSettings.obstacleCount;
            if (freeObstacleCountValue) freeObstacleCountValue.textContent = freeObstacleCount.value;
            if (freeObstacleGroup) {
                freeObstacleGroup.classList.toggle('dimmed', freeModeSettings.obstacleCount === 0);
            }

            [
                freeLifespanToggle,
                freeGoldenToggle,
                freeLightningToggle,
                freeStreakToggle,
                freeFalseToggle,
                freeMirrorToggle
            ].forEach(t => t && t.dispatchEvent(new Event('change')));
        }

        function applyFreeSettings() {
            freeModeSettings = {
                speed: (2 - (parseFloat(freeSpeedInput.value) / 100) * 1.5) * FREE_MODE_DEFAULTS.speed,
                initialLifespan: freeLifespanToggle.checked ? parseFloat(freeLifespanInput.value) * 1000 : 0,
                initialLength: parseInt(freeLengthInput.value, 10),
                goldenFoodChance: freeGoldenToggle.checked ? parseFloat(freeGoldenChanceInput.value) / 100 : 0,
                goldenFoodLifespan: parseFloat(freeGoldenLifespanInput.value) * 1000,
                lightningSpawnRange: freeLightningToggle.checked ? [parseFloat(freeLightningRange.value) * 1000, (parseFloat(freeLightningRange.value) + 4) * 1000] : null,
                lightningLifespan: parseFloat(freeLightningLifespan.value) * 1000,
                redLightningChance: parseFloat(freeRedChance.value) / 100,
                streakReduction: freeStreakToggle.checked ? FREE_MODE_DEFAULTS.streakReduction : 0,
                falseFoodSpawnRange: freeFalseToggle.checked ? [parseFloat(freeFalseRange.value) * 1000, (parseFloat(freeFalseRange.value) + 4) * 1000] : null,
                falseFoodLifespan: parseFloat(freeFalseLifespan.value) * 1000,
                mirrorSpawnRange: freeMirrorToggle.checked ? [parseFloat(freeMirrorRange.value) * 1000, (parseFloat(freeMirrorRange.value) + 4) * 1000] : null,
                mirrorLifespan: parseFloat(freeMirrorLifespan.value) * 1000,
                mirrorEffectDuration: parseFloat(freeMirrorEffect.value) * 1000,
                obstacleCount: parseInt(freeObstacleCount.value, 10)
            };
            if (playerProfiles[currentPlayerName]) {
                playerProfiles[currentPlayerName].freeModeSettings = freeModeSettings;
                saveGameSettings();
            }
            closeFreeSettingsPanel();
        }

       function openInfoPanel() {
            infoPanel.classList.add('centered-panel');
            let desiredWidth = '';
            let desiredLeft = '';
            if (panelOpenedFromSplash) {
                const splashContent = document.getElementById('splash-content');
                if (splashContent) {
                    const rect = splashContent.getBoundingClientRect();
                    const margin = 15;
                    desiredWidth = (rect.width - margin * 2) + 'px';
                    desiredLeft = (rect.left + rect.width / 2) + 'px';
                }
            }
            if (!panelOpenedFromSplash) {
                infoPanel.style.width = '';
                infoPanel.style.left = '';
            } else {
                infoPanel.style.width = desiredWidth;
                infoPanel.style.left = desiredLeft;
            }
            togglePanel(infoPanel, infoPanelContent, true);
            if (panelOpenedFromSplash) {
                infoPanel.style.width = desiredWidth;
                infoPanel.style.left = desiredLeft;
            }
            if (gameOver && !gameIntervalId) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
                score = 0;
                streakMultiplier = 1;

                if (gameMode === 'levels' || gameMode === 'maze') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showFreeModeEnd = false;
                screenState.showClassificationCover = false;
            } else if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = true;
                screenState.showFreeModeEnd = false;
                screenState.gameActuallyStarted = false;
                snake = []; // Vaciar la serpiente
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = [];
                }
                resetGameUIDisplays(); // Llamar aquí para que la UI se actualice con los valores reseteados
                updateGameModeUI();
                requestAnimationFrame(draw);
            }
        }

        function closeInfoPanel() {
            togglePanel(infoPanel, infoPanelContent, false);
             if (gameOver && !gameIntervalId) { // If game was over and not running
                if (gameMode === "levels") {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showFreeModeEnd = false;
                    screenState.showClassificationCover = false;
                    updateScoreDisplay();
                    updateTargetScoreDisplay();
                } else if (gameMode === "freeMode") {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                } else if (gameMode === "classification") {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                }
                updateGameModeUI();
                requestAnimationFrame(draw);
            }
            setTimeout(() => {
                updateMainButtonStates();
            }, 0);
            infoPanel.classList.remove('centered-panel');

            if (panelOpenedFromSplash && splashScreen && !splashScreen.classList.contains('hidden')) {
                if (gameContainer) gameContainer.classList.add('hidden');
                panelOpenedFromSplash = false;
            }
        }
        
        configButton.addEventListener('click', () => {
            if (areSfxEnabled) playSound('modeSwitch');
            if (showModeSelect) {
                // When browsing game modes, open the general configuration menu
                openConfigMenuPanel();
            } else {
                // Inside a game mode, open the corresponding settings menu
                switch (gameMode) {
                    case 'levels':
                    case 'maze':
                    case 'classification':
                        openSettingsPanel();
                        break;
                    case 'freeMode':
                        openFreeSettingsPanel();
                        break;
                    default:
                        openConfigMenuPanel();
                }
            }
        });
        if (closeConfigMenuButton) closeConfigMenuButton.addEventListener('click', closeConfigMenuPanel);
        if (closeGenericMenuButton) closeGenericMenuButton.addEventListener('click', closeGenericMenuPanel);
        if (profileMenuButton) profileMenuButton.addEventListener('click', openProfileMenu);
        if (storeMenuButton) storeMenuButton.addEventListener('click', openStoreMenu);
        if (achievementsMenuButton) achievementsMenuButton.addEventListener('click', () => { openGenericMenuPanel('Logros'); });
        if (bonusesMenuButton) bonusesMenuButton.addEventListener('click', () => { openGenericMenuPanel('Bonificaciones'); });
        if (dailyMenuButton) dailyMenuButton.addEventListener('click', () => { openGenericMenuPanel('Premios diarios'); });
        if (wheelMenuButton) wheelMenuButton.addEventListener('click', () => { openGenericMenuPanel('Ruleta de premios'); });
        if (applyFreeSettingsBottomButton) applyFreeSettingsBottomButton.addEventListener('click', applyFreeSettings);
        if (freeDifficultySelector) freeDifficultySelector.addEventListener('change', () => {
            freeDifficulty = freeDifficultySelector.value;
            if (freeDifficulty === 'personalizado') {
                if (playerProfiles[currentPlayerName] && playerProfiles[currentPlayerName].freeModeSettings) {
                    freeModeSettings = { ...FREE_MODE_DEFAULTS, ...playerProfiles[currentPlayerName].freeModeSettings };
                } else {
                    freeModeSettings = { ...FREE_MODE_DEFAULTS };
                }
            } else {
                freeModeSettings = { ...FREE_MODE_DEFAULTS, ...DIFFICULTY_SETTINGS[freeDifficulty] };
            }
            difficulty = freeDifficulty;
            if (!gameIntervalId) {
                snakeSpeed = freeModeSettings.speed;
                initialSnakeLength = freeModeSettings.initialLength;
            }
            populateFreeSettingsInputs();
            displayHighScoreInPanel();
            updateFreeSettingsLockState();
        });
        closeFreeSettingsButton.addEventListener('click', closeFreeSettingsPanel);
        closeSettingsButton.addEventListener('click', closeSettingsPanel);
        backButton.addEventListener('click', () => {
            if (areSfxEnabled) playSound('modeSwitch');
            handleBackButtonClick();
        });
        closeInfoButton.addEventListener('click', closeInfoPanel);

        function openResetConfirmPanel() {
            if (!panelOpenedFromSplash) return;
            resetConfirmPanel.classList.add('centered-panel');
            togglePanel(settingsPanel, settingsPanelContent, false);
            togglePanel(resetConfirmPanel, resetConfirmPanelContent, true);
        }

        function closeResetConfirmPanel() {
            togglePanel(resetConfirmPanel, resetConfirmPanelContent, false);
            resetConfirmPanel.classList.remove('centered-panel');
        }

        function openConfigMenuPanel() {
            configMenuPanel.classList.remove('centered-panel');
            togglePanel(configMenuPanel, configMenuPanel.querySelector('.panel-content'), true);
        }

        function closeConfigMenuPanel() {
            togglePanel(configMenuPanel, configMenuPanel.querySelector('.panel-content'), false);
            configMenuPanel.classList.remove('centered-panel');
            setTimeout(updateMainButtonStates, 0);
        }

        function openGenericMenuPanel(title) {
            if (genericMenuTitle) genericMenuTitle.textContent = (title || '').toUpperCase();
            const isConfigMenuVisible = !configMenuPanel.classList.contains('config-menu-panel-hidden') && configMenuPanel.classList.contains('panel-visible');
            genericMenuPanel.classList.remove('centered-panel');
            togglePanel(genericMenuPanel, genericMenuPanel.querySelector('.panel-content'), true);
            if (isConfigMenuVisible) {
                matchPanelSizeWithElement(configMenuPanel, genericMenuPanel);
            }
        }

        function closeGenericMenuPanel() {
            togglePanel(genericMenuPanel, genericMenuPanel.querySelector('.panel-content'), false);
            setTimeout(updateMainButtonStates, 0);
        }

        function openStoreMenu() {
            if (!storePanel) return;
            storeTab = 'general';
            if (storeTabButtons && storeTabButtons.length) {
                storeTabButtons.forEach(b => b.classList.remove('active'));
                const defaultBtn = document.querySelector('#store-tab-general');
                if (defaultBtn) defaultBtn.classList.add('active');
            }
            populateStoreItems();
            const isConfigMenuVisible = !configMenuPanel.classList.contains('config-menu-panel-hidden') && configMenuPanel.classList.contains('panel-visible');
            storePanel.classList.remove('centered-panel');
            togglePanel(storePanel, storePanel.querySelector('.panel-content'), true);
            if (isConfigMenuVisible) {
                matchPanelSizeWithElement(configMenuPanel, storePanel);
            }
        }

        function closeStoreMenu() {
            togglePanel(storePanel, storePanel.querySelector('.panel-content'), false);
            setTimeout(updateMainButtonStates, 0);
        }

        function populateStoreItems() {
            if (!storeItemsContainer) return;
            storeItemsContainer.innerHTML = '';
            if (storeTab === 'comida') {
                FOOD_ORDER.forEach(key => {
                    const item = document.createElement('div');
                    item.className = 'store-item';

                    const img = document.createElement('img');
                    img.className = 'store-item-img';
                    img.src = FOODS[key]?.asset?.src || '';
                    item.appendChild(img);

                    const status = document.createElement('div');
                    status.className = 'store-item-status';
                    if (unlockedFoods[key]) {
                        status.textContent = '';
                        item.classList.add('purchased');
                    } else {
                        status.textContent = FOODS[key].price.toString();
                        item.classList.add('locked');
                        item.addEventListener('click', () => openPurchaseConfirm('food', key));
                        addIconPressEvents(item, item);
                    }
                    item.appendChild(status);
                    storeItemsContainer.appendChild(item);
                });
            } else if (storeTab === 'disfraces') {
                SKIN_ORDER.forEach(key => {
                    const item = document.createElement('div');
                    item.className = 'store-item';

                    const img = document.createElement('img');
                    img.className = 'store-item-img';
                    img.src = SKINS[key]?.snakeHeadAsset?.upDown?.src || '';
                    item.appendChild(img);

                    const status = document.createElement('div');
                    status.className = 'store-item-status';
                    if (unlockedSkins[key]) {
                        status.textContent = '';
                        item.classList.add('purchased');
                    } else {
                        status.textContent = SKIN_PRICES[key].toString();
                        item.classList.add('locked');
                        item.addEventListener('click', () => openPurchaseConfirm('skin', key));
                        addIconPressEvents(item, item);
                    }
                    item.appendChild(status);
                    storeItemsContainer.appendChild(item);
                });
            } else if (storeTab === 'escenarios') {
                SCENE_ORDER.forEach(key => {
                    const item = document.createElement('div');
                    item.className = 'store-item scene-item';

                    const img = document.createElement('img');
                    img.className = 'store-item-img scene-img-full';
                    img.src = SCENES[key]?.icon || '';
                    item.appendChild(img);

                    const status = document.createElement('div');
                    status.className = 'store-item-status';
                    if (unlockedScenes[key]) {
                        status.textContent = '';
                        item.classList.add('purchased');
                    } else {
                        status.textContent = SCENE_PRICES[key].toString();
                        item.classList.add('locked');
                        item.addEventListener('click', () => openPurchaseConfirm('scene', key));
                        addIconPressEvents(item, item);
                    }
                    item.appendChild(status);
                    storeItemsContainer.appendChild(item);
                });
            } else {
                const generalItems = [
                    { key: 'heart', price: HEART_PRICE, img: 'https://i.imgur.com/WrI2XXx.png' },
                    { key: 'gem', price: GEM_PRICE, img: 'https://i.imgur.com/gPGsaCO.png' }
                ];
                generalItems.forEach(data => {
                    const item = document.createElement('div');
                    item.className = 'store-item';
                    const img = document.createElement('img');
                    img.className = 'store-item-img';
                    img.src = data.img;
                    item.appendChild(img);
                    const status = document.createElement('div');
                    status.className = 'store-item-status';
                    status.textContent = data.price.toString();
                    item.addEventListener('click', () => openPurchaseConfirm('general', data.key));
                    addIconPressEvents(item, item);
                    item.appendChild(status);
                    storeItemsContainer.appendChild(item);
                });
            }
        }

        let purchaseInfo = null;
        function openPurchaseConfirm(type, key) {
            purchaseInfo = { type, key };
            if (purchaseItemPreview) {
                purchaseItemPreview.innerHTML = '';
                purchaseItemPreview.className = 'store-item' + (type === 'scene' ? ' scene-item' : '');
                const img = document.createElement('img');
                img.className = 'store-item-img';
                if (type === 'food') {
                    img.src = FOODS[key]?.asset?.src || '';
                } else if (type === 'skin') {
                    img.src = SKINS[key]?.snakeHeadAsset?.upDown?.src || '';
                } else if (type === 'scene') {
                    img.classList.add('scene-img-full');
                    img.src = SCENES[key]?.icon || '';
                } else if (type === 'general') {
                    img.src = key === 'heart' ? 'https://i.imgur.com/WrI2XXx.png' : 'https://i.imgur.com/gPGsaCO.png';
                }
                purchaseItemPreview.appendChild(img);
            }
            let price = 0;
            let name = '';
            if (type === 'food') {
                price = FOODS[key].price;
                name = FOOD_DISPLAY_NAMES[key];
            } else if (type === 'skin') {
                price = SKIN_PRICES[key];
                name = SKIN_DISPLAY_NAMES[key];
            } else if (type === 'scene') {
                price = SCENE_PRICES[key];
                name = SCENE_DISPLAY_NAMES[key];
            } else if (type === 'general') {
                price = key === 'heart' ? HEART_PRICE : GEM_PRICE;
                name = key === 'heart' ? 'coraz\u00F3n' : 'gema';
            }
            if (purchaseConfirmationText) purchaseConfirmationText.innerHTML = `¿Comprar ${name} por <strong>${price}</strong> monedas?`;
            purchaseConfirmationPanel.classList.add('centered-panel');
            togglePanel(purchaseConfirmationPanel, purchaseConfirmationPanel.querySelector('.panel-content'), true);
            if (modalOverlay) modalOverlay.classList.remove('hidden');
        }

        function confirmPurchase() {
            if (!purchaseInfo) { closePurchaseConfirm(); return; }
            let price = 0;
            let success = false;
            let failureMessage;
            if (purchaseInfo.type === 'food') {
                price = FOODS[purchaseInfo.key].price;
                if (totalCoins >= price) {
                    totalCoins -= price;
                    unlockedFoods[purchaseInfo.key] = true;
                    saveUnlockedFoods();
                    updateFoodSelectorAvailability();
                    success = true;
                }
            } else if (purchaseInfo.type === 'skin') {
                price = SKIN_PRICES[purchaseInfo.key];
                if (totalCoins >= price) {
                    totalCoins -= price;
                    unlockedSkins[purchaseInfo.key] = true;
                    saveUnlockedSkins();
                    updateSkinSelectorAvailability();
                    success = true;
                }
            } else if (purchaseInfo.type === 'scene') {
                price = SCENE_PRICES[purchaseInfo.key];
                if (totalCoins >= price) {
                    totalCoins -= price;
                    unlockedScenes[purchaseInfo.key] = true;
                    saveUnlockedScenes();
                    updateSceneSelectorAvailability();
                    success = true;
                }
            } else if (purchaseInfo.type === 'general') {
                if (purchaseInfo.key === 'heart') {
                    price = HEART_PRICE;
                    if (totalCoins >= price && playerLives < MAX_LIVES) {
                        totalCoins -= price;
                        playerLives++;
                        if (lifeRestoreQueue.length > 0) {
                            lifeRestoreQueue.pop();
                        }
                        if (playerLives >= MAX_LIVES) lifeRestoreQueue = [];
                        saveLives();
                        updateLivesDisplay();
                        updateLifeTimerDisplay();
                        success = true;
                    } else if (playerLives >= MAX_LIVES) {
                        failureMessage = 'Vidas al máximo';
                    }
                } else if (purchaseInfo.key === 'gem') {
                    price = GEM_PRICE;
                    if (totalCoins >= price) {
                        totalCoins -= price;
                        totalGems++;
                        saveGems();
                        updateGemDisplay();
                        success = true;
                    }
                }
            }
            if (success) {
                localStorage.setItem('snakeGameCoins', totalCoins.toString());
                updateCoinDisplay();
                populateStoreItems();
                closePurchaseConfirm();
            } else {
                showInsufficientFundsToast(failureMessage);
            }
        }

        function closePurchaseConfirm() {
            togglePanel(purchaseConfirmationPanel, purchaseConfirmationPanel.querySelector('.panel-content'), false);
            purchaseConfirmationPanel.classList.remove('centered-panel');
            if (purchaseItemPreview) purchaseItemPreview.innerHTML = '';
            if (modalOverlay) modalOverlay.classList.add('hidden');
            purchaseInfo = null;
        }

        let playerToDelete = null;
        function openDeleteConfirm(name) {
            playerToDelete = name;
            if (deleteConfirmationText) deleteConfirmationText.textContent = `¿Eliminar jugador ${name}?`;
            deleteConfirmationPanel.classList.add('centered-panel');
            togglePanel(deleteConfirmationPanel, deleteConfirmationPanel.querySelector('.panel-content'), true);
            if (modalOverlay) modalOverlay.classList.remove('hidden');
        }

        function confirmDelete() {
            if (!playerToDelete) { closeDeleteConfirm(); return; }
            const nameToDelete = playerToDelete;
            if (Object.keys(playerProfiles).length <= 1) { closeDeleteConfirm(); return; }
            if (nameToDelete === 'Snake') { closeDeleteConfirm(); return; }
            if (playerProfiles[nameToDelete]) delete playerProfiles[nameToDelete];
            const remaining = Object.keys(playerProfiles);
            const newSelection = remaining[0];
            updatePlayerNameSelectors(newSelection);
            currentPlayerName = newSelection;
            const keepDifficulty = difficultySelector.value;
            applyProfile(playerProfiles[currentPlayerName]);
            if (gameMode === 'classification') {
                difficultySelector.value = keepDifficulty;
                classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(keepDifficulty);
            }
            updateCoinDisplay();
            updateGemDisplay();
            updateGameModeUI();
            requestAnimationFrame(draw);
            saveGameSettings();
            closeDeleteConfirm();
        }

        function closeDeleteConfirm() {
            togglePanel(deleteConfirmationPanel, deleteConfirmationPanel.querySelector('.panel-content'), false);
            deleteConfirmationPanel.classList.remove('centered-panel');
            if (modalOverlay) modalOverlay.classList.add('hidden');
            playerToDelete = null;
        }

        function openOutOfLivesPanel() {
            if (!outOfLivesPanel) return;
            togglePanel(outOfLivesPanel, outOfLivesPanel.querySelector('.panel-content'), true);
            if (modalOverlay) modalOverlay.classList.remove('hidden');
        }

        function closeOutOfLivesPanel() {
            togglePanel(outOfLivesPanel, outOfLivesPanel.querySelector('.panel-content'), false);
            if (modalOverlay) modalOverlay.classList.add('hidden');
            setTimeout(updateMainButtonStates, 0);
        }

       function openProfileMenu() {
           if (!profilePanel) return;

           togglePanel(profilePanel, profilePanel.querySelector('.panel-content'), true);
           matchPanelSizeWithElement(configMenuPanel, profilePanel);
           updateSfxVolume();

           if (profileInfoButton) profileInfoButton.classList.remove('hidden');
           if (playerNameInfoButton) playerNameInfoButton.classList.add('hidden');
           if (playerSelectControlGroup) playerSelectControlGroup.classList.remove('hidden');
           if (addPlayerControlGroup) addPlayerControlGroup.classList.remove('hidden');
           if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
           skinControlGroups.forEach(g => g.classList.add('hidden'));
           foodControlGroups.forEach(g => g.classList.add('hidden'));
           skinControlGroups.forEach(g => g.classList.remove('interactive-mode'));
           foodControlGroups.forEach(g => g.classList.remove('interactive-mode'));
           difficultyControlGroup.classList.add('hidden');
           audioControlGroup.classList.add('hidden');
           musicVolumeControlGroup.classList.add('hidden');
           sfxVolumeControlGroup.classList.add('hidden');
           if (classificationRankingGroup) classificationRankingGroup.classList.add('hidden');
           if (resetDataButton) {
               resetDataButton.classList.add('hidden');
               resetDataButton.classList.remove('interactive-mode');
           }

           profileTab = 'general';
           profileTabButtons.forEach(b => b.classList.remove('active'));
           const defaultProfileBtn = document.querySelector('#profile-tab-general');
           if (defaultProfileBtn) defaultProfileBtn.classList.add('active');
           if (profileGeneralContent) profileGeneralContent.classList.remove('hidden');
           if (profileFoodContent) profileFoodContent.classList.add('hidden');
           if (profileSkinContent) profileSkinContent.classList.add('hidden');
           updateProfileSelectedItems();
       }

       function closeProfileMenu() {
           const wasSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains('specific-info-panel-hidden');
           togglePanel(profilePanel, profilePanel.querySelector('.panel-content'), false);
           if (wasSpecificInfoOpen) togglePanel(specificInfoPanel, specificInfoContent, false);
           setTimeout(updateMainButtonStates, 0);
           if (profileInfoButton) profileInfoButton.classList.add('hidden');
           if (playerNameInfoButton) playerNameInfoButton.classList.remove('hidden');
       }

        if (resetDataButton) {
            resetDataButton.addEventListener('click', openResetConfirmPanel);
        }
        if (confirmResetNoButton) {
            confirmResetNoButton.addEventListener('click', () => {
                closeResetConfirmPanel();
                togglePanel(settingsPanel, settingsPanelContent, true);
            });
        }
        if (confirmResetYesButton) {
            confirmResetYesButton.addEventListener('click', () => {
                localStorage.clear();
                window.location.reload();
            });
        }

        if (closeStorePanelButton) closeStorePanelButton.addEventListener('click', closeStoreMenu);
        if (closeProfilePanelButton) closeProfilePanelButton.addEventListener('click', closeProfileMenu);
        if (confirmPurchaseYesButton) confirmPurchaseYesButton.addEventListener('click', confirmPurchase);
        if (confirmPurchaseNoButton) confirmPurchaseNoButton.addEventListener('click', closePurchaseConfirm);
        if (confirmDeleteYesButton) confirmDeleteYesButton.addEventListener('click', confirmDelete);
        if (confirmDeleteNoButton) confirmDeleteNoButton.addEventListener('click', closeDeleteConfirm);
        if (closeOutOfLivesPanelButton) closeOutOfLivesPanelButton.addEventListener('click', closeOutOfLivesPanel);
        if (getLivesStoreButton) getLivesStoreButton.addEventListener('click', () => { closeOutOfLivesPanel(); openStoreMenu(); });
        if (getLivesBonusesButton) getLivesBonusesButton.addEventListener('click', () => { closeOutOfLivesPanel(); openGenericMenuPanel('Bonificaciones'); });

        storeTabButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                storeTabButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                storeTab = btn.dataset.tab;
                populateStoreItems();
            });
        });

        function switchProfileTab(tab) {
            profileTab = tab;
            profileTabButtons.forEach(b => {
                if (b.dataset.tab === tab) b.classList.add('active');
                else b.classList.remove('active');
            });
            if (profileGeneralContent) profileGeneralContent.classList.add('hidden');
            if (profileFoodContent) profileFoodContent.classList.add('hidden');
            if (profileSkinContent) profileSkinContent.classList.add('hidden');
            if (profileSceneContent) profileSceneContent.classList.add('hidden');
            if (tab === 'comida') {
                if (profileFoodContent) profileFoodContent.classList.remove('hidden');
                populateProfileFoodTab();
            } else if (tab === 'disfraces') {
                if (profileSkinContent) profileSkinContent.classList.remove('hidden');
                populateProfileSkinTab();
            } else if (tab === 'escenarios') {
                if (profileSceneContent) profileSceneContent.classList.remove('hidden');
                populateProfileSceneTab();
            } else {
                if (profileGeneralContent) profileGeneralContent.classList.remove('hidden');
                updateProfileSelectedItems();
            }
        }

        profileTabButtons.forEach(btn => {
            btn.addEventListener('click', () => switchProfileTab(btn.dataset.tab));
        });

        if (confirmSelectYesButton) confirmSelectYesButton.addEventListener('click', confirmSelect);
        if (confirmSelectNoButton) confirmSelectNoButton.addEventListener('click', closeSelectConfirm);
        if (profileSelectedSkin) profileSelectedSkin.addEventListener('click', () => {
            switchProfileTab('disfraces');
        });
        if (profileSelectedFood) profileSelectedFood.addEventListener('click', () => {
            switchProfileTab('comida');
        });
        if (profileSelectedScene) profileSelectedScene.addEventListener('click', () => {
            switchProfileTab('escenarios');
        });

        // --- Specific Info Panel Logic ---
        const specificHelpTexts = {
            difficulty: {
                title: "Modo Clasificacion",
                image: "https://i.imgur.com/19iGpfZ.png",
                text_classification: "<p>¡Demuestra de lo que eres capaz y compite por lo más alto!</p> <p><strong>Selecciona la dificultad</strong> que prefieras y trata de superar tus propios récords.</p><p>También puedes <strong>compartir el juego</strong> con amigos y familia. Solo asegúrate de que seleccionan su perfil antes de empezar, ¡y que intenten superarte si pueden!</p> <p>¿Estás listo para luchar por la <strong>primera posición</strong> del ranking?</p>"
            },
            freeDifficulty: {
                title: "Modo Libre",
                image: "https://i.imgur.com/5WQnA4G.png",
                text: "<p>Disfruta de una experiencia <strong>totalmente personalizada</strong>.</p> <p>Elige el nivel de dificultad que prefieras para <strong>ajustar automáticamente</strong> la configuración de la partida.</p> <p>También puedes seleccionar la opción <strong>Personalizado</strong> para ajustar tu propia configuración de partida.</p><p>Cada jugador puede tener su configuración individual: Elige las opciones que prefieras, pulsa el botón <strong>Guardar</strong>, y podrás reutilizarla en futuras partidas.</p><p>¡Juega a tu ritmo y desafíate como quieras!</p>"
            },
            world: {
                title: "Modo Aventura",
                image: "https://i.imgur.com/KxnNVqC.png",
                text: "<p>¡Supera todos los Mundos y completa la aventura!</p> <p>Explora <strong>10 escenarios únicos</strong>, cada uno con nuevos elementos de juego y <strong>5 niveles</strong> de dificultad progresiva que pondrán a prueba tus habilidades.</p> <p>Avanza superando desafíos y <strong>desbloquea nuevos mundos</strong> en tu recorrido.</p> <p><strong>Continúa</strong> donde lo dejaste o <strong>regresa</strong> a niveles ya completados para volver a disfrutar de la experiencia.</p> <p>¡Y esto es solo el comienzo! Muy pronto llegarán actualizaciones con <strong>nuevas aventuras</strong>.</p>"
            },
            mazeLevel: {
                title: "Modo Laberinto",
                image: "https://i.imgur.com/6zcf86e.png",
                text: "<p>¡Pon a prueba tu ingenio y reflejos en <strong>10 laberintos únicos</strong>!</p> <p>La distribución de bloques en cada nivel cambia la forma de jugar, conviertiendo cada partida en una experiencia diferente.</p> <p>Acumula puntos para conseguir al menos <strong>3 estrellas</strong> y desbloquear nuevos laberintos, o trata de lograr las <strong>5 estrellas</strong> en todos para desbloquear increíbles sorpresas.</p> <p>¿Tendrás lo que hace falta para <strong>completar todos los niveles</strong> y alcanzar la <strong>puntuación perfecta</strong> en cada uno?</p>"
            },
            skin: {
                title: "Disfraz",
                text: "<p>Desbloquea disfraces con estética temática u original, juega con el look que más te guste y convierte tu experiencia en algo único y divertido</p><p>La elección del disfraz es <strong>puramente estética</strong>.<p>¡Así que <strong>siéntete libre de experimentar</strong> sin preocuparte por ventajas o desventajas en el juego!</p>"
            },
            food: {
                title: "Comestible",
                text: "<p>Selecciona el alimento que quieres que aparezca en el escenario entre todos los que hayas desbloqueado. Esta elección <strong>solo afecta al aspecto visual</strong> y no modifica la jugabilidad.</p>"
            },
            playerName: {
                title: "Jugador",
                text: "<p>En el <strong>Modo Libre</strong>, se utiliza para guardar los ajustes personalizados de la partida, en el <strong>Modo Clasificacion</strong>, tu nombre se mostrará en el ranking para que puedas comparar tu puntuación con otros jugadores y, en el <strong>Modo Aventura</strong> y el <strong>Modo Laberinto</strong>, te permite guardar tus progresos y continuar donde la habías dejado.</p><p>Si deseas <strong>registrar a un nuevo jugador</strong>, puedes hacerlo desde el menú de configuración de la pantalla de inicio.</p>"
            },
            audioGeneral: {
                title: "Audio General",
                text: "<p>Controla los elementos sonoros del juego para crear la atmósfera perfecta para ti.</p><p>Selecciona <strong>Activado</strong> para disfrutar de música y efectos, <strong>Sólo Música</strong> para escuchar únicamente la banda sonora, <strong>Sólo Efectos</strong> para oír exclusivamente las acciones clave y <strong>Desactivado</strong> para silenciar completamente el juego." 
            },
            musicVolume: {
                title: "Volumen Musica",
                text: "<p>Ajusta con precisión qué tan fuerte o suave quieres que suene la música de fondo del juego, siempre que la tengas activada.</p><p>Mueve el deslizador hacia la derecha para aumentar el volumen, y hacia la izquierda para disminuirlo.</p>"
            },
            sfxVolume: {
                title: "Volumen Efectos",
                text: "<p>Controla la intensidad de los efectos de sonido del juego. Desliza hacia la derecha para escucharlos con más fuerza o hacia la izquierda para suavizarlos.</p>"
            }
        };

        function openSpecificInfoPanel(settingKey, instant = false) {
            if (!specificInfoPanel || !specificInfoTitle || !specificInfoContent) return;

            if (settingKey === 'difficulty' && gameMode !== 'classification') {
                settingKey = 'freeDifficulty';
            }

            let helpData = specificHelpTexts[settingKey];
            if (!helpData) {
                console.error(`No help text found for setting: ${settingKey}`);
                return;
            }

            if (settingKey === 'difficulty') {
                // In classification mode show the dedicated title
                specificInfoTitle.textContent = helpData.title.toUpperCase();
                specificInfoContent.innerHTML = helpData.text_classification;
            } else {
                specificInfoTitle.textContent = helpData.title.toUpperCase();
                specificInfoContent.innerHTML = helpData.text;
            }
            
            // Determine which configuration panel is open and disable its controls
            let sourcePanel = null;
            if (!settingsPanel.classList.contains('settings-panel-hidden')) {
                sourcePanel = settingsPanel;
            } else if (freeSettingsPanel && !freeSettingsPanel.classList.contains('free-settings-panel-hidden')) {
                sourcePanel = freeSettingsPanel;
            } else if (profilePanel && !profilePanel.classList.contains('profile-panel-hidden')) {
                sourcePanel = profilePanel;
            }
            if (sourcePanel) {
                Array.from(sourcePanel.querySelectorAll('select, input[type="range"], .setting-info-button')).forEach(el => el.disabled = true);
                Array.from(sourcePanel.querySelectorAll('.control-group.interactive-mode')).forEach(el => el.classList.remove("interactive-mode")); // Visually indicate disabled state
            }

            togglePanel(specificInfoPanel, specificInfoContent, true, instant);
            if (sourcePanel && sourcePanel !== profilePanel) {
                matchPanelSizeWithElement(sourcePanel, specificInfoPanel);
            }
            applyScrollbarPadding(specificInfoContent);
        }

        function openProfileInfoPanel() {
            if (!specificInfoPanel || !specificInfoTitle || !specificInfoContent) return;

            let sourcePanel = null;
            if (!settingsPanel.classList.contains('settings-panel-hidden')) {
                sourcePanel = settingsPanel;
            } else if (freeSettingsPanel && !freeSettingsPanel.classList.contains('free-settings-panel-hidden')) {
                sourcePanel = freeSettingsPanel;
            } else if (profilePanel && !profilePanel.classList.contains('profile-panel-hidden')) {
                sourcePanel = profilePanel;
            }
            if (sourcePanel) {
                Array.from(sourcePanel.querySelectorAll('select, input[type="range"], .setting-info-button')).forEach(el => el.disabled = true);
                Array.from(sourcePanel.querySelectorAll('.control-group.interactive-mode')).forEach(el => el.classList.remove('interactive-mode'));
            }

            specificInfoTitle.textContent = 'INFORMACIÓN';
            specificInfoContent.innerHTML =
                `<h4>Jugador</h4>${specificHelpTexts.playerName.text}` +
                `<h4>Disfraz</h4>${specificHelpTexts.skin.text}` +
                `<h4>Comestible</h4>${specificHelpTexts.food.text}`;

            togglePanel(specificInfoPanel, specificInfoContent, true);
            if (sourcePanel && sourcePanel !== profilePanel) {
                matchPanelSizeWithElement(sourcePanel, specificInfoPanel);
            }
            applyScrollbarPadding(specificInfoContent);
        }

        function closeSpecificInfoPanel() {
            togglePanel(specificInfoPanel, specificInfoContent, false); // Hide specific info panel
            specificInfoPanel.classList.remove('centered-panel');

            // Re-enable controls depending on which configuration panel is visible
            let targetPanel = null;
            if (!settingsPanel.classList.contains("settings-panel-hidden") && !gameIntervalId) {
                targetPanel = settingsPanel;
            } else if (freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden") && !gameIntervalId) {
                targetPanel = freeSettingsPanel;
            } else if (profilePanel && !profilePanel.classList.contains("profile-panel-hidden") && !gameIntervalId) {
                targetPanel = profilePanel;
            }

            if (targetPanel) {
                targetPanel.querySelectorAll('select, input[type="range"], .setting-info-button').forEach(el => el.disabled = false);

                if (targetPanel === settingsPanel) {
                    skinControlGroups.forEach(g => g.classList.add("interactive-mode"));
                    foodControlGroups.forEach(g => g.classList.add("interactive-mode"));

                    if (gameMode === 'levels') {
                        worldsSelector.disabled = false;
                    } else if (gameMode === 'maze') {
                        mazeLevelButtonsContainer.classList.remove('disabled');
                    } else {
                        difficultySelector.disabled = false;
                    }
                    difficultyControlGroup.classList.add("interactive-mode");

                    if (typeof Tone !== 'undefined') {
                        if (panelOpenedFromSplash) {
                            audioControlGroup.classList.remove('hidden');
                            musicVolumeControlGroup.classList.remove('hidden');
                            sfxVolumeControlGroup.classList.remove('hidden');
                            audioToggleSelector.disabled = false;
                            audioControlGroup.classList.add("interactive-mode");
                            musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                            sfxVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'music_only');
                            if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                            else musicVolumeControlGroup.classList.remove("interactive-mode");
                            if (!sfxVolumeSlider.disabled) sfxVolumeControlGroup.classList.add("interactive-mode");
                            else sfxVolumeControlGroup.classList.remove("interactive-mode");
                        } else {
                            audioToggleSelector.disabled = true;
                            musicVolumeSlider.disabled = true;
                            sfxVolumeSlider.disabled = true;
                            audioControlGroup.classList.add('hidden');
                            musicVolumeControlGroup.classList.add('hidden');
                            sfxVolumeControlGroup.classList.add('hidden');
                            audioControlGroup.classList.remove("interactive-mode");
                            musicVolumeControlGroup.classList.remove("interactive-mode");
                            sfxVolumeControlGroup.classList.remove("interactive-mode");
                        }
                    }
                    playerNameSelectors.forEach(sel => sel.disabled = false);
                    if (panelOpenedFromSplash) {
                        if (addPlayerControlGroup) addPlayerControlGroup.classList.add("interactive-mode");
                    }
                    settingsPanel.querySelectorAll('.setting-info-button').forEach(btn => btn.disabled = false);
                } else {
                    // Free settings panel - restore inputs based on difficulty selection
                    updateFreeSettingsLockState();
                }

                // Ensure main action buttons reflect that a configuration panel is still the context
                startButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;
            } else {
                // If no configuration panel was open, update main buttons normally
                updateMainButtonStates();
            }
        }


        if (closeSpecificInfoButton) {
            closeSpecificInfoButton.addEventListener('click', closeSpecificInfoPanel);
        }

        function maybeShowInitialHelpForMode(mode) {
            const storageKey = `snakeHelpShown_${mode}`;
            if (!localStorage.getItem(storageKey)) {
                let settingKey = null;
                if (mode == 'levels') settingKey = 'world';
                else if (mode == 'freeMode') settingKey = 'freeDifficulty';
                else if (mode == 'classification') settingKey = 'difficulty';
                else if (mode == 'maze') settingKey = 'mazeLevel';
                if (settingKey) {
                    openSpecificInfoPanel(settingKey, true);
                    // Ensure the panel matches the canvas once visible
                    requestAnimationFrame(() => positionPanel(specificInfoPanel));
                    localStorage.setItem(storageKey, 'true');
                }
            }
        }
        document.querySelectorAll('.setting-info-button:not(#profile-info-button)').forEach(button => {
            const icon = button.querySelector('.setting-info-icon');
            const settingKey = button.dataset.setting;
            if (settingKey) {
                button.addEventListener('click', () => {
                    if (areSfxEnabled) playSound('modeSwitch');
                    openSpecificInfoPanel(settingKey);
                });
            } else {
                button.addEventListener('click', () => {
                    if (areSfxEnabled) playSound('modeSwitch');
                });
            }
            if (icon) {
                button.addEventListener('mousedown', () => icon.classList.add('icon-button-pressed'));
                button.addEventListener('mouseup', () => icon.classList.remove('icon-button-pressed'));
                button.addEventListener('mouseleave', () => icon.classList.remove('icon-button-pressed'));
                button.addEventListener('touchstart', () => icon.classList.add('icon-button-pressed'));
                button.addEventListener('touchend', () => icon.classList.remove('icon-button-pressed'));
                button.addEventListener('touchcancel', () => icon.classList.remove('icon-button-pressed'));
            }
        });

        if (profileInfoButton) {
            profileInfoButton.addEventListener('click', () => {
                if (areSfxEnabled) playSound('modeSwitch');
                openProfileInfoPanel();
            });
        }

        if (worldInfoButton) {
            worldInfoButton.addEventListener('click', () => {
                if (areSfxEnabled) playSound('modeSwitch');
                openSpecificInfoPanel('world');
            });
        }

        if (currentWorldInfoGroup) {
            currentWorldInfoGroup.addEventListener('click', () => {
                const isSettingsOpen = !settingsPanel.classList.contains('settings-panel-hidden');
                const isInfoOpen = !infoPanel.classList.contains('info-panel-hidden');
                const isSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains('specific-info-panel-hidden');
                if (isSettingsOpen || isInfoOpen || isSpecificInfoOpen || gameIntervalId || showModeSelect) return;

                // Reset any result screens that may be showing
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;

                if (gameMode === 'levels') {
                    displayWorld = currentWorld;
                    displayLevelInWorld = currentLevelInWorld;
                    const cfg = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1];
                    displayTargetScore = cfg.targetScore || 0;
                    screenState.showCoverForWorld = currentWorld;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                    screenState.showMazeCover = false;
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    screenState.showCoverForWorld = 0;
                    screenState.showClassificationCover = false;
                    screenState.showMazeCover = false;
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.showCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showMazeCover = false;
                } else if (gameMode === 'maze') {
                    displayMazeLevel = currentMazeLevel;
                    mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                    mazeStarsEarned = mazePreviousStars;
                    if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                        displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                    } else {
                        displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                    }
                    screenState.showMazeCover = true;
                    screenState.showCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                    screenState.mazeResultType = '';
                } else {
                    return;
                }

                screenState.gameActuallyStarted = false;
                updateGameModeUI();
                updateMainButtonStates();
                requestAnimationFrame(draw);
            });
        }

        function drawFoodItem(x, y) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS['apple'];
            const foodImg = foodData.asset;

            let foodVisualTopY;
            let foodVisualHeight;
            let drawWidth = GRID_SIZE;
            let drawHeight = GRID_SIZE;
            let offsetX = 0;
            let offsetY = 0;

            if (foodImg && foodImg.complete && foodImg.naturalHeight !== 0) {
                const drawSize = GRID_SIZE * foodData.scale;
                const aspect = foodImg.naturalWidth / foodImg.naturalHeight;
                if (aspect >= 1) {
                    drawWidth = drawSize;
                    drawHeight = drawSize / aspect;
                } else {
                    drawHeight = drawSize;
                    drawWidth = drawSize * aspect;
                }
                offsetX = (drawWidth - GRID_SIZE) / 2;
                offsetY = (drawHeight - GRID_SIZE) / 2;
                foodVisualTopY = y * GRID_SIZE - offsetY;
                foodVisualHeight = drawHeight;
            } else {
                drawWidth = GRID_SIZE - 4;
                drawHeight = GRID_SIZE - 4;
                offsetX = -2;
                offsetY = -2;
                foodVisualTopY = y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
            }
            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            let foodIsVisible = true;
            if (!gameOver && foodTimeRemaining <= FOOD_WARNING_TIME && foodTimeRemaining > 0) {
                const blinkInterval = 500; 
                foodIsVisible = (Math.floor(foodTimeRemaining / blinkInterval) % 2 !== 0);
            }

            if (foodIsVisible && (foodTimeRemaining > 0 || currentFoodItem.initialLifespanForThisFood === 0)) {
                if (foodImg && foodImg.complete && foodImg.naturalHeight !== 0) {
                    if (currentFoodItem.isGolden) {
                        ctx.filter = 'brightness(1.2)';
                        drawImageWithTint(ctx, foodImg, x * GRID_SIZE - offsetX, y * GRID_SIZE - offsetY, drawWidth, drawHeight, 'rgba(255,215,0,0.5)');
                        ctx.filter = 'none';
                    } else {
                        ctx.drawImage(foodImg, x * GRID_SIZE - offsetX, y * GRID_SIZE - offsetY, drawWidth, drawHeight);
                    }
                } else {
                    ctx.fillStyle = currentFoodItem.isGolden ? 'gold' : FOOD_SHAPE_FALLBACK.color;
                    ctx.fillRect(x * GRID_SIZE + 2, y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                    ctx.strokeStyle = FOOD_SHAPE_FALLBACK.borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x * GRID_SIZE + 2, y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                }
            }

            if (!gameOver && foodTimeRemaining > 0 && currentFoodItem.initialLifespanForThisFood > 0) {
                const barProgress = foodTimeRemaining / currentFoodItem.initialLifespanForThisFood;
                const barWidth = (GRID_SIZE - 4) * barProgress; 
                const barHeight = 3;
                const barGap = 2; 

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                   timeBarYPosition = canvasEl.height - barHeight -1; 
                }
                 if (timeBarYPosition < 0){ 
                       timeBarYPosition = 1; 
                }
                
                let barColor = 'rgba(76, 175, 80, 0.85)'; 
                const percentageRemaining = (foodTimeRemaining / currentFoodItem.initialLifespanForThisFood) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)'; 
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)'; 
                }
                
                ctx.fillStyle = barColor;
                ctx.fillRect(
                    x * GRID_SIZE + 2, 
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }
        
        function applyStreakReduction(base, min = 0) {
            if (base <= 0) return 0;
            let streakReduction = 0;
            const effectiveStreak = Math.min(streakMultiplier, MAX_STREAK);
            if (effectiveStreak > 1) {
                // Reduce food lifespan by 0.5 s per 0.5 streak increase
                const reductionPerStep = (gameMode === 'classification'
                    ? DIFFICULTY_SETTINGS[difficulty].streakReduction
                    : (gameMode === 'levels'
                        ? (LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1].streakReduction || 0)
                        : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty].streakReduction : freeModeSettings.streakReduction))) || 1000;
                streakReduction = (effectiveStreak - 1) * reductionPerStep;
            }
            return Math.max(min, base - streakReduction);
        }

        function calculateNextFoodLifespan() {
            let baseLifespan;
            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                baseLifespan = levelCfg.initialLifespan || 0;
            } else if (gameMode === 'classification') {
                baseLifespan = DIFFICULTY_SETTINGS[difficulty].initialLifespan;
            } else if (gameMode === 'maze') {
                baseLifespan = DIFFICULTY_SETTINGS[currentMazeDifficulty].initialLifespan;
            } else {
                baseLifespan = freeModeSettings.initialLifespan;
            }
            return applyStreakReduction(baseLifespan, MIN_FOOD_LIFESPAN);
        }

        function generateFood() {
            clearTimeout(foodDisappearTimeoutId);
            clearInterval(foodVisualTimerIntervalId);
            lastWarningSoundSecond = -1; 
            let newFoodPosition;
            do {
                newFoodPosition = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                };
            } while (isPositionOccupied(newFoodPosition) && tileCountX > 0 && tileCountY > 0);
            
            if (tileCountX <=0 || tileCountY <=0) { 
                console.warn("Canvas too small to generate food.");
                currentFoodItem = {}; 
                return;
            }

            const classificationRank = CLASSIFICATION_RANKS[difficulty] || 0;
            const diffCfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficulty] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
            let goldenChance = diffCfg.goldenFoodChance !== undefined ? diffCfg.goldenFoodChance : GOLDEN_FOOD_CHANCE;
            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (levelCfg.goldenFoodChance !== undefined) goldenChance = levelCfg.goldenFoodChance;
            }
            const isGolden = ((gameMode === 'levels' && goldenChance > 0) || (gameMode === 'classification' && classificationRank >= 1) || gameMode === 'freeMode') && Math.random() < goldenChance;
            let lifespan = calculateNextFoodLifespan();
            if (isGolden) {
                if (gameMode === 'classification' && classificationRank === 1 && diffCfg.goldenFoodLifespan === undefined) {
                    lifespan = GOLDEN_FOOD_LIFESPAN_CLASSIF_RANK1;
                } else if (gameMode === 'levels') {
                    const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                    if (levelCfg.goldenFoodLifespan !== undefined) {
                        lifespan = levelCfg.goldenFoodLifespan;
                    }
                } else if (gameMode === 'freeMode' && diffCfg.goldenFoodLifespan !== undefined) {
                    lifespan = diffCfg.goldenFoodLifespan;
                } else if (diffCfg.goldenFoodLifespan !== undefined) {
                    lifespan = diffCfg.goldenFoodLifespan;
                }
                lifespan = applyStreakReduction(lifespan);
            }
            currentFoodItem = {
                x: newFoodPosition.x,
                y: newFoodPosition.y,
                isGolden,
                initialLifespanForThisFood: lifespan
            };
            foodTimeRemaining = currentFoodItem.initialLifespanForThisFood;
            if (foodTimeRemaining > 0) {
                foodDisappearTimeoutId = setTimeout(handleFoodTimeout, foodTimeRemaining);
                foodVisualTimerIntervalId = setInterval(() => {
                if (gameOver) {
                    clearInterval(foodVisualTimerIntervalId);
                    return;
                }
                foodTimeRemaining -= 100;
                if (foodTimeRemaining < 0) foodTimeRemaining = 0;
                if (foodTimeRemaining <= FOOD_WARNING_TIME && foodTimeRemaining > 0) {
                    const currentSecondInWarning = Math.ceil(foodTimeRemaining / 1000);
                    if (currentSecondInWarning !== lastWarningSoundSecond) { 
                        if (areSfxEnabled) playSound('warning');
                        lastWarningSoundSecond = currentSecondInWarning;
                    }
                } else {
                    lastWarningSoundSecond = -1; 
                }
            }, 100);
            } else {
                foodDisappearTimeoutId = null;
                foodVisualTimerIntervalId = null;
            }
        }
        
        function handleFoodTimeout() {
            if (gameOver) return;
            console.log("¡Comida no recogida! Racha perdida."); 
            if (areSfxEnabled) playSound('timeout');
            streakMultiplier = 1;
            const classRank = CLASSIFICATION_RANKS[difficulty] || 0;
            if ((gameMode === 'levels' && currentWorld >= 6) ||
                (gameMode === 'classification' && classRank >= 2) ||
                (gameMode === 'freeMode' && freeModeSettings.streakReduction > 0)) {
                startStreakAnimation(streakMultiplier);
            }
            foodTimeRemaining = 0;
            generateFood(); 
            updateScoreDisplay();
            draw(); 
        }

        function isFoodOnSnake(foodPosition) {
            for (let segment of snake) {
                if (segment.x === foodPosition.x && segment.y === foodPosition.y) {
                    return true;
                }
            }
            return false;
        }

        function isAdjacentToAnyFood(pos) {
            if (currentFoodItem.x !== undefined) {
                if (Math.abs(currentFoodItem.x - pos.x) <= 1 && Math.abs(currentFoodItem.y - pos.y) <= 1) {
                    return true;
                }
            }
            for (let ff of falseFoodItems) {
                if (Math.abs(ff.x - pos.x) <= 1 && Math.abs(ff.y - pos.y) <= 1) {
                    return true;
                }
            }
            return false;
        }

        function isAdjacentToAnyObstacle(pos) {
            for (let ob of obstacles) {
                if (Math.abs(ob.x - pos.x) <= 1 && Math.abs(ob.y - pos.y) <= 1) {
                    return true;
                }
            }
            return false;
        }

        function isPositionOccupied(pos) {
            if (isFoodOnSnake(pos)) return true;
            if (currentFoodItem.x === pos.x && currentFoodItem.y === pos.y) return true;
            if (falseFoodItems.some(f => f.x === pos.x && f.y === pos.y)) return true;
            if (obstacles.some(o => o.x === pos.x && o.y === pos.y)) return true;
            if (lightningItems.some(l => l.x === pos.x && l.y === pos.y)) return true;
            if (mirrorItems.some(m => m.x === pos.x && m.y === pos.y)) return true;
            return false;
        }

        function drawFalseFoodItem(item) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS["apple"];
            const img = foodData.asset;
            let foodVisualTopY;
            let foodVisualHeight;
            let drawWidth = GRID_SIZE;
            let drawHeight = GRID_SIZE;
            let offsetX = 0;
            let offsetY = 0;
            if (img && img.complete && img.naturalHeight !== 0) {
                const drawSize = GRID_SIZE * foodData.scale;
                const aspect = img.naturalWidth / img.naturalHeight;
                if (aspect >= 1) {
                    drawWidth = drawSize;
                    drawHeight = drawSize / aspect;
                } else {
                    drawHeight = drawSize;
                    drawWidth = drawSize * aspect;
                }
                offsetX = (drawWidth - GRID_SIZE) / 2;
                offsetY = (drawHeight - GRID_SIZE) / 2;
                foodVisualTopY = item.y * GRID_SIZE - offsetY;
                foodVisualHeight = drawHeight;
                drawImageWithTint(ctx, img, item.x * GRID_SIZE - offsetX, item.y * GRID_SIZE - offsetY, drawWidth, drawHeight, 'rgba(255,0,0,0.3)');
            } else {
                drawWidth = GRID_SIZE - 4;
                drawHeight = GRID_SIZE - 4;
                offsetX = -2;
                offsetY = -2;
                foodVisualTopY = item.y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(item.x * GRID_SIZE + 2, item.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            }

            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            if (!gameOver && item.remaining > 0) {
                const totalLifespan = item.lifespan || FALSE_FOOD_LIFESPAN;
                const barProgress = item.remaining / totalLifespan;
                const barWidth = (GRID_SIZE - 4) * barProgress;
                const barHeight = 3;
                const barGap = 2;

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                    timeBarYPosition = canvasEl.height - barHeight - 1;
                }
                if (timeBarYPosition < 0) {
                    timeBarYPosition = 1;
                }

                let barColor = 'rgba(76, 175, 80, 0.85)';
                const percentageRemaining = (item.remaining / totalLifespan) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)';
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)';
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(
                    item.x * GRID_SIZE + 2,
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }

        function drawObstacle(ob) {
            if (!ctx) return;
            const drawSize = GRID_SIZE;
            const img = ob.img || obstacleImg;
            const offset = 0;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, ob.x * GRID_SIZE - offset, ob.y * GRID_SIZE - offset, drawSize, drawSize);
            } else {
                ctx.fillStyle = "#555";
                ctx.fillRect(ob.x * GRID_SIZE - offset, ob.y * GRID_SIZE - offset, drawSize, drawSize);
            }
        }

        function drawLightningItem(item) {
            if (!ctx) return;
            const img = item.color === 'yellow' ? lightningYellowImg : lightningRedImg;
            const drawSize = GRID_SIZE * 1.5;
            const offset = (drawSize - GRID_SIZE) / 2;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, item.x * GRID_SIZE - offset, item.y * GRID_SIZE - offset, drawSize, drawSize);
            } else {
                const color = item.color === 'yellow' ? 'yellow' : 'red';
                ctx.fillStyle = color;
                ctx.fillRect(item.x * GRID_SIZE + 2 - offset, item.y * GRID_SIZE + 2 - offset, GRID_SIZE - 4 + (drawSize - GRID_SIZE), GRID_SIZE - 4 + (drawSize - GRID_SIZE));
            }
        }

        function removeFalseFoodItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = falseFoodItems.indexOf(item);
            if (idx !== -1) falseFoodItems.splice(idx, 1);
        }

        function generateFalseFood() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos;
            let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isPositionOccupied(pos) || isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let lifespan = FALSE_FOOD_LIFESPAN;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (typeof cfg.falseFoodLifespan === 'number') {
                    lifespan = cfg.falseFoodLifespan;
                }
            } else if (gameMode === 'levels') {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (typeof cfg.falseFoodLifespan === 'number') {
                    lifespan = cfg.falseFoodLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeFalseFoodItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeFalseFoodItem(item); }, 100);
            falseFoodItems.push(item);
        }

        function scheduleNextFalseFoodSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (!cfg.falseFoodSpawnRange) return;
                range = cfg.falseFoodSpawnRange;
            } else if (gameMode === "levels") {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (!cfg.falseFoodSpawnRange) return;
                range = cfg.falseFoodSpawnRange;
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            falseFoodSpawnTimeoutId = setTimeout(() => {
                generateFalseFood();
                scheduleNextFalseFoodSpawn();
            }, delay);
        }

        function startWorld4FalseFoodMechanics() {
            stopWorld4FalseFoodMechanics();
            scheduleNextFalseFoodSpawn();
        }

        function stopWorld4FalseFoodMechanics() {
            if (falseFoodSpawnTimeoutId) {
                clearTimeout(falseFoodSpawnTimeoutId);
                falseFoodSpawnTimeoutId = null;
            }
            falseFoodItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            falseFoodItems = [];
        }

        function generateWorld5Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : (OBSTACLE_COUNTS_WORLD5[currentLevelInWorld - 1] || 0);
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isPositionOccupied(pos) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld5Obstacles(customCount) {
            generateWorld5Obstacles(customCount);
        }

        function stopWorld5Obstacles() {
            obstacles = [];
        }

        function generateWorld6Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : OBSTACLE_COUNT_WORLD6;
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isPositionOccupied(pos) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld6Obstacles(customCount) {
            generateWorld6Obstacles(customCount);
        }

        function stopWorld6Obstacles() {
            obstacles = [];
        }

        function generateWorld8Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : (OBSTACLE_COUNTS_WORLD8[currentLevelInWorld - 1] || 0);
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isPositionOccupied(pos) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld8Obstacles(customCount) {
            generateWorld8Obstacles(customCount);
        }

        function stopWorld8Obstacles() {
            obstacles = [];
        }

        function removeLightningItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = lightningItems.indexOf(item);
            if (idx !== -1) lightningItems.splice(idx, 1);
        }

        function generateLightning() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos; let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isPositionOccupied(pos) || isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let redChance = 0.25;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (typeof cfg.redLightningChance === 'number') {
                    redChance = cfg.redLightningChance;
                }
            } else if (gameMode === 'levels') {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (typeof cfg.redLightningChance === 'number') {
                    redChance = cfg.redLightningChance;
                }
            }
            const color = Math.random() < redChance ? 'red' : 'yellow';
            let lifespan = LIGHTNING_LIFESPAN;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (typeof cfg.lightningLifespan === 'number') {
                    lifespan = cfg.lightningLifespan;
                }
            } else if (gameMode === 'levels') {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (typeof cfg.lightningLifespan === 'number') {
                    lifespan = cfg.lightningLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, color, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeLightningItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeLightningItem(item); }, 100);
            lightningItems.push(item);
        }

        function scheduleNextLightningSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === "classification" || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (!cfg.lightningSpawnRange) return;
                range = cfg.lightningSpawnRange;
            } else if (gameMode === "levels") {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (!cfg.lightningSpawnRange) return;
                range = cfg.lightningSpawnRange;
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            lightningSpawnTimeoutId = setTimeout(() => {
                generateLightning();
                scheduleNextLightningSpawn();
            }, delay);
        }

        function startWorld6LightningMechanics() {
            stopWorld6LightningMechanics();
            scheduleNextLightningSpawn();
        }

        function stopWorld6LightningMechanics() {
            if (lightningSpawnTimeoutId) {
                clearTimeout(lightningSpawnTimeoutId);
                lightningSpawnTimeoutId = null;
            }
            lightningItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            lightningItems = [];
        }

        function drawMirrorItem(item) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS["apple"];
            const img = foodData.asset;
            let foodVisualTopY;
            let foodVisualHeight;
            let drawWidth = GRID_SIZE;
            let drawHeight = GRID_SIZE;
            let offsetX = 0;
            let offsetY = 0;
            if (img && img.complete && img.naturalHeight !== 0) {
                const drawSize = GRID_SIZE * foodData.scale;
                const aspect = img.naturalWidth / img.naturalHeight;
                if (aspect >= 1) {
                    drawWidth = drawSize;
                    drawHeight = drawSize / aspect;
                } else {
                    drawHeight = drawSize;
                    drawWidth = drawSize * aspect;
                }
                offsetX = (drawWidth - GRID_SIZE) / 2;
                offsetY = (drawHeight - GRID_SIZE) / 2;
                foodVisualTopY = item.y * GRID_SIZE - offsetY;
                foodVisualHeight = drawHeight;
                drawImageWithTint(ctx, img, item.x * GRID_SIZE - offsetX, item.y * GRID_SIZE - offsetY, drawWidth, drawHeight, 'rgba(0,0,255,0.3)');
            } else {
                drawWidth = GRID_SIZE - 4;
                drawHeight = GRID_SIZE - 4;
                offsetX = -2;
                offsetY = -2;
                foodVisualTopY = item.y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(item.x * GRID_SIZE + 2, item.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            }

            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            if (!gameOver && item.remaining > 0) {
                const totalLifespan = item.lifespan || FALSE_FOOD_LIFESPAN;
                const barProgress = item.remaining / totalLifespan;
                const barWidth = (GRID_SIZE - 4) * barProgress;
                const barHeight = 3;
                const barGap = 2;

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                    timeBarYPosition = canvasEl.height - barHeight - 1;
                }
                if (timeBarYPosition < 0) {
                    timeBarYPosition = 1;
                }

                let barColor = 'rgba(76, 175, 80, 0.85)';
                const percentageRemaining = (item.remaining / totalLifespan) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)';
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)';
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(
                    item.x * GRID_SIZE + 2,
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }

        function removeMirrorItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = mirrorItems.indexOf(item);
            if (idx !== -1) mirrorItems.splice(idx, 1);
        }

        function generateMirror() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos; let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isPositionOccupied(pos) || isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let lifespan = FALSE_FOOD_LIFESPAN;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (typeof cfg.mirrorLifespan === 'number') {
                    lifespan = cfg.mirrorLifespan;
                }
            } else if (gameMode === 'levels') {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (typeof cfg.mirrorLifespan === 'number') {
                    lifespan = cfg.mirrorLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeMirrorItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeMirrorItem(item); }, 100);
            mirrorItems.push(item);
        }

        function scheduleNextMirrorSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === 'classification' || gameMode === 'freeMode' || gameMode === 'maze') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                          : (gameMode === 'maze' ? DIFFICULTY_SETTINGS[currentMazeDifficulty] : freeModeSettings);
                if (!cfg.mirrorSpawnRange) return;
                range = cfg.mirrorSpawnRange;
            } else if (gameMode === "levels") {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (!cfg.mirrorSpawnRange) return;
                range = cfg.mirrorSpawnRange;
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            mirrorSpawnTimeoutId = setTimeout(() => {
                generateMirror();
                scheduleNextMirrorSpawn();
            }, delay);
        }

        function startWorld7MirrorMechanics() {
            stopWorld7MirrorMechanics();
            scheduleNextMirrorSpawn();
        }

        function stopWorld7MirrorMechanics() {
            if (mirrorSpawnTimeoutId) {
                clearTimeout(mirrorSpawnTimeoutId);
                mirrorSpawnTimeoutId = null;
            }
            mirrorItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            mirrorItems = [];
            controlsInverted = false;
            mirrorEffect = { active: false, startTime: 0 };
            if (eatReactionTimeoutId) {
                clearTimeout(eatReactionTimeoutId);
                eatReactionTimeoutId = null;
            }
            currentReaction = null;
            reactionEndTime = 0;
        }

       function generateMazeLevel(levelIndex) {
            obstacles = [];
            if (levelIndex <= MAZE_LEVELS_PER_DIFFICULTY * 2) {
                const layout = MAZE_LAYOUTS[((levelIndex - 1) % MAZE_LEVELS_PER_DIFFICULTY) + 1];
                if (layout) {
                    obstacles = layout.map(pos => ({ x: pos.x, y: pos.y, img: obstacleImg }));
                }
            }
        }

        function startMazeLevel() {
            generateMazeLevel(displayMazeLevel);
        }

        function stopMazeLevel() {
            obstacles = [];
        }

        function applySpeedChange(change) {
            clearInterval(gameIntervalId);
            snakeSpeed = Math.max(50, snakeSpeed + change);
            gameIntervalId = setInterval(update, snakeSpeed);
        }

        function activateSpeedBoost(color) {
            const change = color === 'yellow' ? -25 : -50;
            if (speedBoost.active) {
                applySpeedChange(-speedBoost.change);
            }
            if (mirrorEffect.active) {
                mirrorEffect = { active: false, startTime: 0 };
                controlsInverted = false;
            }
            applySpeedChange(change);
            speedBoost = { active: true, color, change, startTime: Date.now() };
        }

        function updateSpeedBoost() {
            if (!speedBoost.active) return;
            const elapsed = Date.now() - speedBoost.startTime;
            if (elapsed >= SPEED_BOOST_DURATION) {
                applySpeedChange(-speedBoost.change);
                speedBoost.active = false;
            }
        }
        function splitTextIntoLines(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            if (words.length === 0) return lines;
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + " " + word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth < maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // --- High Score Functions ---
        function getHighScoreKey(difficultyLevel) {
            return `snakeHighScores_${difficultyLevel}`;
        }

        function loadHighScores(difficultyLevel) {
            const key = getHighScoreKey(difficultyLevel);
            const scoresJSON = localStorage.getItem(key);
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function getClassificationHighScoreKey(difficultyLevel) {
            return `snakeClassificationHighScores_${difficultyLevel}`;
        }

        function loadClassificationHighScores(difficultyLevel) {
            const key = getClassificationHighScoreKey(difficultyLevel);
            const scoresJSON = localStorage.getItem(key);
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function saveClassificationHighScore(currentScore, timeValue, difficultyLevel) {
            const key = getClassificationHighScoreKey(difficultyLevel);
            let highScores = loadClassificationHighScores(difficultyLevel);
            const newEntry = {
                score: currentScore,
                time: timeValue,
                difficulty: DIFFICULTY_DISPLAY_NAMES[difficultyLevel],
                skin: currentSkin,
                playerName: currentPlayerName,
            };

            let insertIndex = highScores.findIndex(entry => {
                if (currentScore > entry.score) return true;
                if (currentScore === entry.score) {
                    if (timeValue < entry.time) return true;
                    if (timeValue === entry.time) return true;
                }
                return false;
            });

            if (insertIndex === -1) {
                highScores.push(newEntry);
                insertIndex = highScores.length - 1;
            } else {
                highScores.splice(insertIndex, 0, newEntry);
            }

            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            localStorage.setItem(key, JSON.stringify(highScores));
            console.log(`Puntuaciones Modo Clasificacion guardadas para ${difficultyLevel}:`, highScores);

            const isActuallyNewHighScoreThisGame = insertIndex < MAX_HIGH_SCORES;
            const newRecordIndex = isActuallyNewHighScoreThisGame ? insertIndex : -1;
            return { isNewRecord: isActuallyNewHighScoreThisGame, rowIndex: newRecordIndex };
        }

        function saveHighScore(currentScore, timeValue, difficultyLevel) {
            const key = getHighScoreKey(difficultyLevel);
            let highScores = loadHighScores(difficultyLevel);
            const newEntry = {
                score: currentScore,
                time: timeValue,
                difficulty: DIFFICULTY_DISPLAY_NAMES[difficultyLevel],
                skin: currentSkin, // Guardamos el 'value' del skin actual
            };

            let insertIndex = highScores.findIndex(entry => {
                if (currentScore > entry.score) return true;
                if (currentScore === entry.score) {
                    if (timeValue < entry.time) return true;
                    if (timeValue === entry.time) return true; // Nuevo registro se coloca antes de los empates
                }
                return false;
            });

            if (insertIndex === -1) {
                highScores.push(newEntry);
                insertIndex = highScores.length - 1;
            } else {
                highScores.splice(insertIndex, 0, newEntry);
            }

            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            localStorage.setItem(key, JSON.stringify(highScores));
            console.log(`Puntuaciones guardadas para ${difficultyLevel}:`, highScores);

            const isActuallyNewHighScoreThisGame = insertIndex < MAX_HIGH_SCORES;
            const newRecordIndex = isActuallyNewHighScoreThisGame ? insertIndex : -1;
            return { isNewRecord: isActuallyNewHighScoreThisGame, rowIndex: newRecordIndex };
        }

        // --- Funciones de Refactorización de finalizeGameOver ---
        function clearGameTimersAndMusic() {
            clearInterval(gameIntervalId);
            gameIntervalId = null;
            clearTimeout(foodDisappearTimeoutId);
            clearInterval(foodVisualTimerIntervalId);
            clearInterval(gameTimerIntervalId);
            clearInterval(inactivityIntervalId);
            inactivityIntervalId = null;
            stopWorld4FalseFoodMechanics();
            stopWorld5Obstacles();
            stopWorld6Obstacles();
            stopWorld8Obstacles();
            stopWorld6LightningMechanics();
            stopWorld7MirrorMechanics();

            if (inGameBackgroundMusic) {
                inGameBackgroundMusic.pause();
                console.log("Música de partida pausada (clearGameTimersAndMusic).");
            }
        }

        function handleFreeModeEnd(currentScore, timeElapsedValue, difficultyValue) {
            const highScoreData = saveHighScore(currentScore, timeElapsedValue, difficultyValue);

            console.log("FinalizeGameOver - Modo Libre - isNewRecord:", highScoreData.isNewRecord, "Score:", currentScore, "Time:", timeElapsedValue, "Difficulty:", difficultyValue, "Blink Row Index:", highScoreData.rowIndex);
            
            if (highScoreData.isNewRecord) {
                blinkAnimation.startTime = Date.now();
                blinkAnimation.active = true; 
                console.log("Blink animation activated for new high score.");
            }
            return { isNewRecord: highScoreData.isNewRecord, isEffectivelyWon: highScoreData.isNewRecord, rowIndex: highScoreData.rowIndex };
        }

        function handleClassificationModeEnd(currentScore, timeElapsedValue, difficultyValue) {
            const highScoreData = saveClassificationHighScore(currentScore, timeElapsedValue, difficultyValue);

            console.log("FinalizeGameOver - Modo Clasificacion - isNewRecord:", highScoreData.isNewRecord, "Score:", currentScore, "Time:", timeElapsedValue, "Difficulty:", difficultyValue, "Blink Row Index:", highScoreData.rowIndex);

            if (highScoreData.isNewRecord) {
                blinkAnimation.startTime = Date.now();
                blinkAnimation.active = true;
                console.log("Blink animation activated for new classification high score.");
            }
            return { isNewRecord: highScoreData.isNewRecord, isEffectivelyWon: highScoreData.isNewRecord, rowIndex: highScoreData.rowIndex };
        }

        function handleLevelsModeEnd(currentScore, timeRemaining) {
            const absoluteLevelIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
            const currentTarget = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1].targetScore;
            const levelWon = (currentScore >= currentTarget && timeRemaining > 0);

            if (levelWon) {
                levelsProgress[absoluteLevelIndex] = true; // Se marca la estrella
                worldCurrentLevels[currentWorld - 1] = currentLevelInWorld;

                if (currentLevelInWorld === LEVELS_PER_WORLD) { // Mundo completado
                    screenState.showWorldCompleteCover = currentWorld;

                    if (currentWorld === TOTAL_WORLDS) { // Juego completado
                        startButton.textContent = "AJUSTES";
                        // No hay más niveles a los que avanzar. currentWorld y currentLevelInWorld permanecen en el máximo.
                    } else { // Avanzar al siguiente mundo
                        startButton.textContent = "NUEVO MUNDO";
                        worldCurrentLevels[currentWorld - 1] = LEVELS_PER_WORLD;
                        currentWorld++;
                        currentLevelInWorld = worldCurrentLevels[currentWorld - 1] || 1;
                        if (currentWorld > maxUnlockedWorld) {
                            maxUnlockedWorld = currentWorld;
                        }
                    }
                } else { // Nivel completado (no es el último del mundo)
                    currentLevelInWorld++; // Avanzamos el nivel inmediatamente
                    screenState.showLevelCompleteCover = currentWorld;
                    startButton.textContent = `Nivel ${currentWorld}.${currentLevelInWorld}`; // Botón para el *nuevo* nivel actual
                }
                // Limpiamos otros estados de pantalla
                screenState.showCoverForWorld = 0;
                screenState.showDefeatCoverForWorld = 0;

            } else { // Nivel perdido
                startButton.textContent = "REINTENTAR";
                screenState.showDefeatCoverForWorld = currentWorld;
                // Limpiamos otros estados de pantalla por si acaso
                screenState.showCoverForWorld = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
            }
            worldCurrentLevels[currentWorld - 1] = currentLevelInWorld;
            drawStarProgress(); // Dibuja las estrellas con la nueva completada
            return levelWon;
        }

        function handleMazeModeEnd(currentScore, timeRemaining) {
            const isLastLevel = displayMazeLevel === MAZE_LEVEL_COUNT;
            let levelWon = false;
            let resultType = 'fail';

            const levelIndex = displayMazeLevel - 1;
            const previousStars = mazePreviousStars;
            const improved = mazeStarsEarned > previousStars;

            if (isLastLevel && improved && mazeStarsEarned >= 3) {
                levelWon = true;
                resultType = 'final';
                startButton.textContent = 'AJUSTES';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            } else if (improved && mazeStarsEarned >= MAZE_STAR_TARGETS.length) {
                levelWon = true;
                if (isLastLevel) {
                    resultType = 'final';
                    startButton.textContent = 'AJUSTES';
                } else {
                    resultType = 'perfect';
                    startButton.textContent = 'CONTINUAR';
                }
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            } else if (improved && mazeStarsEarned >= 3) {
                if (!isLastLevel) {
                    levelWon = true;
                    resultType = 'partial';
                    startButton.textContent = 'CONTINUAR';
                    restartMazeButton.classList.remove('hidden');
                    startButtonWrapperEl.classList.add('split');
                } else {
                    startButton.textContent = 'REINTENTAR';
                    resultType = 'fail';
                    restartMazeButton.classList.add('hidden');
                    startButtonWrapperEl.classList.remove('split');
                }
            } else {
                startButton.textContent = 'REINTENTAR';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            }

            if (levelWon && !isLastLevel && displayMazeLevel === currentMazeLevel) {
                currentMazeLevel++;
            }

            if (levelIndex >= 0 && levelIndex < MAZE_LEVEL_COUNT && mazeStarsEarned > mazePreviousStars) {
                mazeLevelStars[levelIndex] = mazeStarsEarned;
            }

            saveGameSettings();

            const allStarsAchieved = mazeLevelStars.every(s => s >= MAZE_STAR_TARGETS.length);
            if (levelWon && allStarsAchieved) {
                resultType = 'allstars';
            }

        screenState.mazeResultType = resultType;
        return levelWon;
        }

        function getNextIncompleteMazeLevel(currentLevel) {
            let next = currentLevel + 1;
            while (next <= currentMazeLevel && mazeLevelStars[next - 1] >= MAZE_STAR_TARGETS.length) {
                next++;
            }
            if (next <= currentMazeLevel) {
                return next;
            }
            return currentMazeLevel;
        }


        function playSoundForGameOver(levelWon) {
            if (!areSfxEnabled) return;

            if (gameMode === 'freeMode') {
                if (gameOverByInactivity) {
                    playSound('gameOver');
                } else {
                    playSound('win');
                }
                return;
            }

            if (levelWon) {
                playSound('win');
            } else {
                playSound('gameOver');
            }
        }
        
        function managePostGameOverMusicAndAnimation() {
            if (blinkAnimation.active && gameOver) { 
                requestAnimationFrame(gameEndAnimationLoop);
            } else {
                const isSettingsCurrentlyOpen = settingsPanel && !settingsPanel.classList.contains("settings-panel-hidden");
                const isInfoCurrentlyOpen = infoPanel && !infoPanel.classList.contains("info-panel-hidden");
                if (isMusicEnabled && generalBackgroundMusic && !isSettingsCurrentlyOpen && !isInfoCurrentlyOpen) {
                    if (generalBackgroundMusic.paused) {
                        generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (managePostGameOverMusic):", e));
                        console.log("Música general iniciada (managePostGameOverMusic - no blink).");
                    }
                }
            }
        }
        
        function gameEndAnimationLoop() { // This is the loop for the blinking animation
            if (gameOver && blinkAnimation.active) { 
                draw(); 
                const elapsedTime = Date.now() - blinkAnimation.startTime;
                if (elapsedTime >= blinkAnimation.duration) {
                    blinkAnimation.active = false; 
                    draw(); 
                    managePostGameOverMusicAndAnimation(); // Check for music again once blink is done
                } else {
                    requestAnimationFrame(gameEndAnimationLoop); 
                }
            }
        }

        function updateUIOnGameOver() {
            updateMainButtonStates();

            skinSelectors.forEach(sel => sel.disabled = false);
            foodSelectors.forEach(sel => sel.disabled = false);
            skinControlGroups.forEach(g => g.classList.add("interactive-mode"));
            foodControlGroups.forEach(g => g.classList.add("interactive-mode"));

            if (gameMode === 'levels') {
                worldsSelector.disabled = false; 
            } else { 
                difficultySelector.disabled = false;
            }
            difficultyControlGroup.classList.add("interactive-mode");

            if (typeof Tone !== 'undefined') {
                 if (panelOpenedFromSplash) {
                     audioControlGroup.classList.remove('hidden');
                     musicVolumeControlGroup.classList.remove('hidden');
                     sfxVolumeControlGroup.classList.remove('hidden');
                     audioToggleSelector.disabled = false;
                     audioControlGroup.classList.add("interactive-mode");
                     musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                     sfxVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'music_only');
                     if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                     else musicVolumeControlGroup.classList.remove("interactive-mode");
                     if (!sfxVolumeSlider.disabled) sfxVolumeControlGroup.classList.add("interactive-mode");
                     else sfxVolumeControlGroup.classList.remove("interactive-mode");
                 } else {
                     audioToggleSelector.disabled = true;
                     musicVolumeSlider.disabled = true;
                     sfxVolumeSlider.disabled = true;
                     audioControlGroup.classList.add('hidden');
                     musicVolumeControlGroup.classList.add('hidden');
                     sfxVolumeControlGroup.classList.add('hidden');
                     audioControlGroup.classList.remove("interactive-mode");
                     musicVolumeControlGroup.classList.remove("interactive-mode");
                     sfxVolumeControlGroup.classList.remove("interactive-mode");
                 }
            } else {
                 audioToggleSelector.disabled = true;
                 musicVolumeSlider.disabled = true;
                 sfxVolumeSlider.disabled = true;
                 audioControlGroup.classList.add('hidden');
                 musicVolumeControlGroup.classList.add('hidden');
                 sfxVolumeControlGroup.classList.add('hidden');
                 audioControlGroup.classList.remove("interactive-mode");
                 musicVolumeControlGroup.classList.remove("interactive-mode");
                 sfxVolumeControlGroup.classList.remove("interactive-mode");
            }

            resetDataButton.classList.add('hidden');
            resetDataButton.classList.remove('interactive-mode');

            updateScoreDisplay();
            updateTimeLengthDisplay();
            updateGameModeUI();
        }
        // --- Fin de Funciones de Refactorización ---

        function finalizeGameOver() {
            if (gameOver && startButton.disabled === false && configButton.disabled === false && backButton.disabled === false && gameIntervalId === null) return;

            gameOver = true;
            screenState.gameActuallyStarted = false; // Game is no longer "actually started"

            // Crucial for Free Mode: Ensure cover is not shown when game ends, so classification appears
            if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = false; // Ensure no cover is shown
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeEnd = false;
            } else if (gameMode === 'classification') {
                screenState.showClassificationCover = false;
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
            }


            clearGameTimersAndMusic();

            // Ensure any active speed boost or mirror effect ends when the game does
            if (speedBoost.active) {
                speedBoost = { active: false, color: '', change: 0, startTime: 0 };
            }
            controlsInverted = false;
            mirrorEffect = { active: false, startTime: 0 };
            if (eatReactionTimeoutId) {
                clearTimeout(eatReactionTimeoutId);
                eatReactionTimeoutId = null;
            }
            currentReaction = null;
            reactionEndTime = 0;

            let levelEffectivelyWon = false;
            isNewHighScore = false; 

            if (gameMode === 'freeMode') {
                if (gameOverByInactivity) {
                    screenState.showTimeoutCover = true;
                } else {
                    screenState.showFreeModeEnd = true;
                }
                isNewHighScore = false;
                levelEffectivelyWon = false;
            } else if (gameMode === 'classification') {
                const classificationResult = handleClassificationModeEnd(score, Math.floor(gameTimeElapsed / 1000), difficulty);
                isNewHighScore = classificationResult.isNewRecord;
                levelEffectivelyWon = classificationResult.isEffectivelyWon;
                if (isNewHighScore) {
                    blinkAnimation.rowIndex = classificationResult.rowIndex;
                }
            } else if (gameMode === 'levels') {
                levelEffectivelyWon = handleLevelsModeEnd(score, gameTimeRemaining);
            } else if (gameMode === 'maze') {
                levelEffectivelyWon = handleMazeModeEnd(score, gameTimeRemaining);
            }

            if (!levelEffectivelyWon && gameOverByTimeout && (gameMode === 'levels' || gameMode === 'maze')) {
                screenState.showTimeoutCover = true;
                screenState.showDefeatCoverForWorld = 0;
                if (gameMode === 'maze') {
                    screenState.mazeResultType = '';
                }
            }
            gameOverByTimeout = false;
            gameOverByInactivity = false;

            let earnedCoins;
            if (gameMode === 'freeMode') {
                // In free mode coins are earned based on time played
                earnedCoins = Math.floor(gameTimeElapsed / 10);
            } else {
                earnedCoins = Math.floor(score / POINTS_PER_COIN);
            }
            const previousCoins = totalCoins;

            totalCoins += earnedCoins;
            localStorage.setItem('snakeGameCoins', totalCoins.toString());
            updateUIOnGameOver();
            if (gameMode === 'levels' || gameMode === 'maze') {
                saveGameSettings();
            }

            playSoundForGameOver(levelEffectivelyWon);
            draw();
            managePostGameOverMusicAndAnimation();

            if (gameMode === 'classification' || !levelEffectivelyWon) {
                loseLife();
            }

            const soundDelay = levelEffectivelyWon ? WIN_SOUND_DURATION : GAME_OVER_SOUND_DURATION;
            setTimeout(() => {
                showEarnedCoinsMessage(earnedCoins);
                setTimeout(() => {
                    animateCoinGain(previousCoins, totalCoins);
                }, COIN_MESSAGE_DISPLAY_TIME);
            }, soundDelay);
        }
        
        function drawSingleWorldCover(worldNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = worldCoverImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                if (worldNumber > maxUnlockedWorld) {
                    ctx.filter = 'grayscale(100%)';
                }
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
                ctx.filter = 'none';
            } else {
                ctx.fillStyle = "#24f2ed";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Mundo ${worldNumber}`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }
        
        function drawWorldCompleteScreen(worldNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = worldCompleteImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                 ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                // Fallback text if image fails to load
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 10)}px 'Press Start 2P'`;
                if (worldNumber === TOTAL_WORLDS) {
                    ctx.fillText("¡JUEGO COMPLETADO!", canvasEl.width / 2, canvasEl.height / 2);
                } else {
                    ctx.fillText(`¡MUNDO ${worldNumber} SUPERADO!`, canvasEl.width / 2, canvasEl.height / 2);
                }
                 if (!img.complete) {
                    console.warn(`Imagen de mundo completado para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de mundo completado para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawLevelCompleteImage(worldNumber) { 
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = levelCompleteImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`¡Nivel Superado!`, canvasEl.width / 2, canvasEl.height / 2 - 20);
                ctx.font = `${Math.floor(canvasEl.width / 25)}px 'Press Start 2P'`;
                ctx.fillText(`(Mundo ${worldNumber})`, canvasEl.width / 2, canvasEl.height / 2 + 20);

                if (!img.complete) {
                    console.warn(`Imagen de nivel completado para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de nivel completado para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawDefeatScreen(worldNumber) { // New function for defeat screen
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = defeatImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`¡Has Perdido!`, canvasEl.width / 2, canvasEl.height / 2 - 20);
                ctx.font = `${Math.floor(canvasEl.width / 25)}px 'Press Start 2P'`;
                ctx.fillText(`(Mundo ${worldNumber})`, canvasEl.width / 2, canvasEl.height / 2 + 20);

                if (!img.complete) {
                    console.warn(`Imagen de derrota para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de derrota para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawTimeoutScreen() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = (gameMode === 'freeMode') ? freeModeInactivityImg : timeoutImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText('¡Tiempo agotado!', canvasEl.width / 2, canvasEl.height / 2);
            }
        }
        function drawFreeModeCover() { // New function for free mode cover
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = freeModeCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Modo Libre`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de Modo Libre aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de Modo Libre parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawFreeModeEndScreen() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = freeModeEndImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText('Fin de partida', canvasEl.width / 2, canvasEl.height / 2);
            }
        }

        function drawClassificationCover() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const now = performance.now();
            let progress = 1;
            if (classificationTransitionStart !== null) {
                progress = Math.min((now - classificationTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromImg = classificationDifficultyImages[CLASSIFICATION_DIFFICULTY_ORDER[classificationTransitionStart !== null ? classificationTransitionFrom : classificationDifficultyIndex]];
            const toImg = classificationDifficultyImages[CLASSIFICATION_DIFFICULTY_ORDER[classificationDifficultyIndex]];

            if (classificationTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = classificationTransitionDir;
                if (fromImg && fromImg.complete && fromImg.naturalHeight !== 0) {
                    ctx.drawImage(fromImg, -dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, canvasEl.width * dir - dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                requestAnimationFrame(draw);
            } else {
                classificationTransitionStart = null;
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, 0, 0, canvasEl.width, canvasEl.height);
                } else {
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                    ctx.fillText(DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || 'Clasificación', canvasEl.width / 2, canvasEl.height / 2);
                    if (!toImg.complete) {
                        console.warn(`Imagen de portada de dificultad aún no cargada.`);
                    } else if (toImg.naturalHeight === 0) {
                        console.warn(`Imagen de portada de dificultad parece estar corrupta o no es una imagen válida.`);
                    }
                }
            }
        }

        function drawSingleMazeLevelCover(levelNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = mazeLevelCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                if (levelNumber > currentMazeLevel) {
                    ctx.filter = 'grayscale(100%)';
                }
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
                ctx.filter = 'none';
            } else {
                ctx.fillStyle = "#24f2ed";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Nivel ${levelNumber}`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de nivel aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de nivel parece estar corrupta o no es válida.`);
                }
            }

            const textColor = levelNumber > currentMazeLevel ? '#6B7280' : '#24f2ed';
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.font = `${Math.floor(canvasEl.width / 14)}px 'Press Start 2P'`;

            const totalStars = MAZE_STAR_TARGETS.length;
            const starSize = Math.floor(canvasEl.width / (totalStars * 2 + 1));
            // Raise the level text and stars slightly higher on the screen
            const marginBottom = canvasEl.height * 0.1;
            const textY = canvasEl.height - starSize - marginBottom - canvasEl.height * 0.03;
            ctx.fillText(`Nivel ${levelNumber}`, canvasEl.width / 2, textY);

            const starsEarned = mazeLevelStars[levelNumber - 1] || 0;
            const gap = starSize * 0.5;
            const rowWidth = totalStars * starSize + (totalStars - 1) * gap;
            const startX = (canvasEl.width - rowWidth) / 2 + starSize / 2;
            const starY = canvasEl.height - starSize / 2 - marginBottom;
            for (let i = 0; i < totalStars; i++) {
                const filled = levelNumber <= currentMazeLevel && i < starsEarned;
                drawStarShape(startX + i * (starSize + gap), starY, starSize, filled);
            }
        }

        function drawStarShape(cx, cy, size, filled) {
            if (starFullImg.complete && starEmptyImg.complete && starFullImg.naturalHeight !== 0 && starEmptyImg.naturalHeight !== 0) {
                const img = filled ? starFullImg : starEmptyImg;
                ctx.drawImage(img, cx - size / 2, cy - size / 2, size, size);
            } else {
                const path = new Path2D('M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z');
                const scale = size / 24;
                const color = filled ? '#FACC15' : '#6B7280';
                ctx.save();
                ctx.translate(cx - size / 2, cy - size / 2);
                ctx.scale(scale, scale);
                ctx.fillStyle = color;
                ctx.fill(path);
                ctx.restore();
            }
        }

        function drawWorldCover() {
            if (!ctx || !canvasEl) return;
            const now = performance.now();
            let progress = 1;
            if (worldTransitionStart !== null) {
                progress = Math.min((now - worldTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromWorld = worldTransitionStart !== null ? worldTransitionFrom : displayWorld;
            const toWorld = displayWorld;

            if (worldTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = worldTransitionDir;
                ctx.save();
                ctx.translate(-dir * offset, 0);
                drawSingleWorldCover(fromWorld);
                ctx.restore();
                ctx.save();
                ctx.translate(canvasEl.width * dir - dir * offset, 0);
                drawSingleWorldCover(toWorld);
                ctx.restore();
                requestAnimationFrame(draw);
            } else {
                worldTransitionStart = null;
                drawSingleWorldCover(toWorld);
            }
        }

       function drawMazeCover() {
            if (!ctx || !canvasEl) return;
            const now = performance.now();
            let progress = 1;
            if (mazeTransitionStart !== null) {
                progress = Math.min((now - mazeTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromLevel = mazeTransitionStart !== null ? mazeTransitionFrom : displayMazeLevel;
            const toLevel = displayMazeLevel;

            if (mazeTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = mazeTransitionDir;
                ctx.save();
                ctx.translate(-dir * offset, 0);
                drawSingleMazeLevelCover(fromLevel);
                ctx.restore();
                ctx.save();
                ctx.translate(canvasEl.width * dir - dir * offset, 0);
                drawSingleMazeLevelCover(toLevel);
                ctx.restore();
                requestAnimationFrame(draw);
            } else {
                mazeTransitionStart = null;
                drawSingleMazeLevelCover(toLevel);
            }
        }

        function drawMazeResultScreen(resultType) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            let img;
            if (resultType === 'fail') img = mazeFailImg;
            else if (resultType === 'partial') img = mazePartialImg;
            else if (resultType === 'perfect') img = mazePerfectImg;
            else if (resultType === 'complete') img = mazeCompleteImg;
            else if (resultType === 'final') img = mazeFinalImg;
            else if (resultType === 'allstars') img = mazeAllStarsImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                const textMap = {
                    fail: 'Reintentar',
                    partial: 'Continuar',
                    perfect: 'Perfecto',
                    complete: '¡Completado!',
                    final: '¡Completado!',
                    allstars: '¡Completado!'
                };
                ctx.fillText(textMap[resultType] || '', canvasEl.width / 2, canvasEl.height / 2);
            }
        }

        function getModeImage(mode) {
            if (mode === 'intro') return modeSelectIntroImg;
            if (mode === 'levels') return modeSelectLevelsImg;
            if (mode === 'freeMode') return modeSelectFreeImg;
            if (mode === 'classification') return modeSelectClassificationImg;
            return modeSelectMazeImg;
        }

        function drawModeSelection() {
            modeLeftButton.classList.remove('hidden');
            modeRightButton.classList.remove('hidden');

            const now = performance.now();
            let progress = 1;
            if (modeTransitionStart !== null) {
                progress = Math.min((now - modeTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromImg = getModeImage(MODE_SELECT_ORDER[modeTransitionStart !== null ? modeTransitionFrom : modeSelectIndex]);
            const toImg = getModeImage(MODE_SELECT_ORDER[modeSelectIndex]);

            if (modeTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = modeTransitionDir;
                if (fromImg && fromImg.complete && fromImg.naturalHeight !== 0) {
                    ctx.drawImage(fromImg, -dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, canvasEl.width * dir - dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                requestAnimationFrame(draw);
            } else {
                modeTransitionStart = null;
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, 0, 0, canvasEl.width, canvasEl.height);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                    ctx.fillText('Selecciona modo', canvasEl.width / 2, canvasEl.height / 2);
                }
            }
        }


        function draw() {
             if (!ctx) return;
            const sceneData = SCENES[currentScene] || SCENES['classic'];
        const bgImg = getSceneBgPattern(currentScene);
        if (bgImg) {
            ctx.save();
            ctx.filter = `contrast(${SCENE_CONTRAST})`;
            ctx.drawImage(bgImg, 0, 0, canvasEl.width, canvasEl.height);
            ctx.restore();
        } else {
            ctx.fillStyle = sceneData.bgColor || '#374151';
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
        }

            if (showModeSelect) {
                drawModeSelection();
                updateMainButtonStates();
                return;
            } else {
                if ((screenState.showClassificationCover ||
                     (screenState.showCoverForWorld > 0 && gameMode === 'levels') ||
                     (screenState.showMazeCover && gameMode === 'maze')) &&
                    !screenState.gameActuallyStarted) {
                    modeLeftButton.classList.remove('hidden');
                    modeRightButton.classList.remove('hidden');
                } else {
                    modeLeftButton.classList.add('hidden');
                    modeRightButton.classList.add('hidden');
                }
            }

            let speedBoostVisible = false;
            let speedBoostOverlayColor = '';
            if (speedBoost.active) {
                const remaining = SPEED_BOOST_DURATION - (Date.now() - speedBoost.startTime);
                if (remaining > 0) {
                    speedBoostOverlayColor = speedBoost.color === 'yellow' ? 'rgba(255,255,0,0.3)' : 'rgba(255,0,0,0.3)';
                    speedBoostVisible = remaining > 1000 || Math.floor(remaining / 100) % 2 === 0;
                }
            }
            let mirrorVisible = false;
            let mirrorOverlayColor = 'rgba(0,0,255,0.3)';
            if (mirrorEffect.active) {
                let effectDuration = MIRROR_EFFECT_DURATION;
                if (gameMode === 'classification' || gameMode === 'maze') {
                    const cfg = gameMode === 'classification'
                        ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {})
                        : DIFFICULTY_SETTINGS[currentMazeDifficulty] || {};
                    if (typeof cfg.mirrorEffectDuration === 'number') {
                        effectDuration = cfg.mirrorEffectDuration;
                    }
                }
                const remaining = effectDuration - (Date.now() - mirrorEffect.startTime);
                if (remaining > 0) {
                    mirrorVisible = remaining > 1000 || Math.floor(remaining / 100) % 2 === 0;
                } else {
                    mirrorEffect.active = false;
                }
            }

            if (screenState.showFreeModeCover && !screenState.gameActuallyStarted) {
                drawFreeModeCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                drawClassificationCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.showMazeCover && !screenState.gameActuallyStarted) {
                modeLeftButton.classList.remove('hidden');
                modeRightButton.classList.remove('hidden');
                drawMazeCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.mazeResultType && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                drawMazeResultScreen(screenState.mazeResultType);
                updateMainButtonStates();
                return;
            }
            if (screenState.showTimeoutCover && !screenState.gameActuallyStarted) {
                drawTimeoutScreen();
                updateMainButtonStates();
                return;
            }
            if (screenState.showFreeModeEnd && !screenState.gameActuallyStarted) {
                drawFreeModeEndScreen();
                updateMainButtonStates();
                return;
            }
            if (screenState.showDefeatCoverForWorld > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                drawDefeatScreen(screenState.showDefeatCoverForWorld);
                updateMainButtonStates();
                return;
            }
            if (screenState.showWorldCompleteCover > 0 && gameMode === 'levels') { 
                drawWorldCompleteScreen(screenState.showWorldCompleteCover);
                updateMainButtonStates(); 
                return;
            }
            if (screenState.showLevelCompleteCover > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) { 
                drawLevelCompleteImage(screenState.showLevelCompleteCover); 
                updateMainButtonStates(); 
                return;
            }
            if (screenState.showCoverForWorld > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                modeLeftButton.classList.remove('hidden');
                modeRightButton.classList.remove('hidden');
                drawWorldCover();
                updateMainButtonStates();
                return;
            }


            if (tileCountX <= 0 || tileCountY <= 0) return; 

            const currentSkinData = SKINS[currentSkin]; 

            if (!gameOver) {
                if (obstacles.length > 0) {
                    obstacles.forEach(ob => drawObstacle(ob));
                }
                // Draw snake body
                for (let i = 1; i < snake.length; i++) {
                    const segmentX = snake[i].x * GRID_SIZE;
                    const segmentY = snake[i].y * GRID_SIZE;
                    const skinData = SKINS[currentSkin];
                    const isTail = i === snake.length - 1;
                    let renderTail = isTail;
                    const bodyTex = skinData.bodyTexture || snakeBodyTexture;
                    const bodyTexVert = skinData.bodyTextureVertical || skinData.bodyTexture || snakeBodyTextureVertical;
                    const tailTex = skinData.tailTexture || snakeTailTexture;
                    const cornerTexA = skinData.cornerTextureA || snakeCornerTextureA;
                    const cornerTexB = skinData.cornerTextureB || snakeCornerTextureB;
                    let texture = tailTex;

                    if (texture && texture.complete && texture.naturalHeight !== 0) {
                    const prev = snake[i - 1];
                    const sameAsPrev = (snake[i].x === prev.x && snake[i].y === prev.y);
                    if (sameAsPrev) renderTail = false;
                    if (!renderTail) texture = bodyTex;
                    const nextSeg = snake[i + 1];
                    const dx = normalizedDiff(prev.x, snake[i].x, tileCountX);
                    const dy = normalizedDiff(prev.y, snake[i].y, tileCountY);
                    ctx.save();
                    ctx.translate(segmentX + GRID_SIZE / 2, segmentY + GRID_SIZE / 2);
                    let rotation = 0;
                    let scaleX = 1;
                    let scaleY = 1;
                    if (renderTail) {
                        const tailUpTex = skinData.tailTextureUp || snakeTailTextureUp;
                            if (dx === 1 && dy === 0) {
                                scaleX = -1;
                            } else if (dx === 0 && dy === -1) {
                                texture = tailUpTex;
                            } else if (dx === 0 && dy === 1) {
                                texture = tailUpTex;
                                scaleY = -1;
                            }
                    } else {
                            let usedCorner = false;
                            if (nextSeg) {
                                const fromNextX = normalizedDiff(snake[i].x, nextSeg.x, tileCountX);
                                const fromNextY = normalizedDiff(snake[i].y, nextSeg.y, tileCountY);
                                const toPrevX = dx;
                                const toPrevY = dy;
                                let flipCorner = false;
                                if ((fromNextX === -1 && fromNextY === 0 && toPrevX === 0 && toPrevY === -1) ||
                                    (fromNextX === 0 && fromNextY === 1 && toPrevX === 1 && toPrevY === 0)) {
                                    texture = cornerTexA;
                                    usedCorner = true;
                                } else if ((fromNextX === 1 && fromNextY === 0 && toPrevX === 0 && toPrevY === -1) ||
                                           (fromNextX === 0 && fromNextY === 1 && toPrevX === -1 && toPrevY === 0)) {
                                    texture = cornerTexA;
                                    usedCorner = true;
                                    flipCorner = true;
                                } else if ((fromNextX === -1 && fromNextY === 0 && toPrevX === 0 && toPrevY === 1) ||
                                           (fromNextX === 0 && fromNextY === -1 && toPrevX === 1 && toPrevY === 0)) {
                                    texture = cornerTexB;
                                    usedCorner = true;
                                } else if ((fromNextX === 1 && fromNextY === 0 && toPrevX === 0 && toPrevY === 1) ||
                                           (fromNextX === 0 && fromNextY === -1 && toPrevX === -1 && toPrevY === 0)) {
                                    texture = cornerTexB;
                                    usedCorner = true;
                                    flipCorner = true;
                                }
                                if (flipCorner) scaleX = -1;
                            }
                            if (!usedCorner) {
                                if (dx === 1 && dy === 0) {
                                    scaleX = -1;
                                } else if (dx === 0 && Math.abs(dy) === 1) {
                                    texture = bodyTexVert;
                                }
                            }
                    }
                        ctx.rotate(rotation);
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(texture, -GRID_SIZE / 2, -GRID_SIZE / 2, GRID_SIZE, GRID_SIZE);
                        if (skinData.bodyTintColor) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = skinData.bodyTintColor;
                            ctx.fillRect(-GRID_SIZE / 2, -GRID_SIZE / 2, GRID_SIZE, GRID_SIZE);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (speedBoostVisible) {
                            drawImageWithTint(ctx, texture, -GRID_SIZE / 2, -GRID_SIZE / 2, GRID_SIZE, GRID_SIZE, speedBoostOverlayColor);
                        }
                        if (mirrorVisible) {
                            drawImageWithTint(ctx, texture, -GRID_SIZE / 2, -GRID_SIZE / 2, GRID_SIZE, GRID_SIZE, mirrorOverlayColor);
                        }
                        ctx.restore();
                    } else {
                        ctx.fillStyle = skinData.bodyTintColor || '#A8F031';
                        ctx.fillRect(segmentX, segmentY, GRID_SIZE, GRID_SIZE);
                        if (speedBoostVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = speedBoostOverlayColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE, GRID_SIZE);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (mirrorVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = mirrorOverlayColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE, GRID_SIZE);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                }

                // Draw food
                if (currentFoodItem.x !== undefined) {
                    drawFoodItem(currentFoodItem.x, currentFoodItem.y);
                }
                if (falseFoodItems.length > 0) {
                    falseFoodItems.forEach(item => drawFalseFoodItem(item));
                }
                if (lightningItems.length > 0) {
                    lightningItems.forEach(item => drawLightningItem(item));
                }
                if (mirrorItems.length > 0) {
                    mirrorItems.forEach(item => drawMirrorItem(item));
                }

                // Draw snake head
                if (snake.length > 0) {
                    const head = snake[0];
                    if (currentSkinData && currentSkinData.snakeHeadAsset) {
                        let imgToDraw;
                        let baseImageForUp = currentSkinData.snakeHeadAsset.upDown;
                        let baseImageForDown = currentSkinData.snakeHeadAsset.upDown;
                        let baseImageForLeft = currentSkinData.snakeHeadAsset.left;
                        let baseImageForRight = currentSkinData.snakeHeadAsset.left;
                        if (currentReaction && Date.now() < reactionEndTime && currentSkinData.reactionAssets) {
                            const rImgs = currentSkinData.reactionAssets[currentReaction];
                            if (rImgs) {
                                if (rImgs.upDown) {
                                    baseImageForUp = rImgs.upDown;
                                    baseImageForDown = rImgs.upDown;
                                }
                                if (rImgs.left) {
                                    baseImageForLeft = rImgs.left;
                                    baseImageForRight = rImgs.left;
                                }
                            }
                        } else if (currentReaction && (!currentSkinData.reactionAssets || !currentSkinData.reactionAssets[currentReaction])) {
                            currentReaction = null;
                        }
                        let flipHorizontal = false;
                        let flipVertical = false;

                        if (direction === 'up') { imgToDraw = baseImageForUp; flipVertical = true; }
                        else if (direction === 'down') { imgToDraw = baseImageForDown; }
                        else if (direction === 'left') { imgToDraw = baseImageForLeft; }
                        else if (direction === 'right') { imgToDraw = baseImageForRight; flipHorizontal = true; }

                        if (imgToDraw && imgToDraw.complete && imgToDraw.naturalHeight !== 0) {
                            const drawSize = GRID_SIZE * currentSkinData.snakeHeadScale;
                            const offset = (drawSize - GRID_SIZE) / 2;
                            const drawX = head.x * GRID_SIZE - offset;
                            const drawY = head.y * GRID_SIZE - offset;
                            ctx.save();
                            ctx.translate(drawX + drawSize / 2, drawY + drawSize / 2);
                            let scaleX = 1; let scaleY = 1;
                            if (flipHorizontal) scaleX = -1; if (flipVertical) scaleY = -1;
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                            if (speedBoostVisible) {
                                drawImageWithTint(ctx, imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize, speedBoostOverlayColor);
                            }
                            if (mirrorVisible) {
                                drawImageWithTint(ctx, imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize, mirrorOverlayColor);
                            }
                            ctx.restore();
                        } else {
                            ctx.fillStyle = "#a7f3d0";
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            if (speedBoostVisible) {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = speedBoostOverlayColor;
                                ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                                ctx.globalCompositeOperation = 'source-over';
                            }
                            if (mirrorVisible) {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = mirrorOverlayColor;
                                ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                                ctx.globalCompositeOperation = 'source-over';
                            }
                        }
                    } else {
                        ctx.fillStyle = "#a7f3d0";
                        ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        if (speedBoostVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = speedBoostOverlayColor;
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (mirrorVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = mirrorOverlayColor;
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                    drawStreakAnimation(head);
                }
            } else { // Game Over Screen (but not world/level complete or defeat screen)
                if (!screenState.showWorldCompleteCover && !screenState.showLevelCompleteCover && !screenState.showDefeatCoverForWorld && !screenState.showFreeModeCover) { 
                    ctx.fillStyle = "rgba(0, 0, 0, 0.65)"; 
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                    
                    const baseFontSize = Math.min(16, Math.floor(canvasEl.width / 20)); 
                    const highScoreTitleFontSize = Math.max(9, baseFontSize * 0.9);
                    const highScoreEntryFontSize = Math.max(7, baseFontSize * 0.7);
                    const tableHeaderFontSize = Math.max(7, baseFontSize * 0.7);
                    
                    let endMessageFontSize = baseFontSize;
                    let mainTitle = "";
                    let subTitle = "";
                    let titleColor = "rgba(220, 38, 38, 1)"; 

                    if (gameMode === 'levels') {
                        mainTitle = `Nivel ${displayWorld}.${displayLevelInWorld} Fallido`; // Use display variables
                        subTitle = "Inténtalo de nuevo";
                    } else if (gameMode === 'freeMode' || gameMode === 'classification') {
                        mainTitle = isNewHighScore ? "¡Nuevo Récord!" : "Game Over";
                         if (isNewHighScore) titleColor = "rgba(76, 175, 80, 1)";
                    }


                    const targetWidthForEndMessage = canvasEl.width * 0.9;
                    let optimalSizeForEndMessage = Math.floor(canvasEl.height / 5); 
                    if (optimalSizeForEndMessage < 15) optimalSizeForEndMessage = 15;
                    ctx.font = `${optimalSizeForEndMessage}px 'Press Start 2P'`;
                    while(ctx.measureText(mainTitle).width > targetWidthForEndMessage && optimalSizeForEndMessage > 10) {
                        optimalSizeForEndMessage--;
                        ctx.font = `${optimalSizeForEndMessage}px 'Press Start 2P'`;
                    }
                    endMessageFontSize = optimalSizeForEndMessage;

                    let currentY = canvasEl.height * 0.08;

                    ctx.fillStyle = titleColor;
                    ctx.font = `${endMessageFontSize}px 'Press Start 2P'`;
                    ctx.textAlign = "center";
                    ctx.shadowColor = "rgba(0,0,0,0.8)";
                    ctx.shadowBlur = 10;

                    const mainTitleMetrics = ctx.measureText(mainTitle);
                    const mainTitleHeight = mainTitleMetrics.actualBoundingBoxAscent + mainTitleMetrics.actualBoundingBoxDescent;
                    const mainTitleBaseline = currentY + mainTitleMetrics.actualBoundingBoxAscent - mainTitleHeight / 2;

                    ctx.textBaseline = "alphabetic";
                    ctx.fillText(mainTitle, canvasEl.width / 2, mainTitleBaseline);

                    ctx.shadowBlur = 0;
                    currentY = mainTitleBaseline + mainTitleMetrics.actualBoundingBoxDescent + endMessageFontSize * 0.7;

                    if (subTitle) {
                        const subTitleFontSize = Math.max(10, Math.floor(endMessageFontSize * 0.7));
                        ctx.font = `${subTitleFontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = titleColor;

                        const subTitleMetrics = ctx.measureText(subTitle);
                        const subTitleHeight = subTitleMetrics.actualBoundingBoxAscent + subTitleMetrics.actualBoundingBoxDescent;
                        const subTitleBaseline = currentY + subTitleMetrics.actualBoundingBoxAscent - subTitleHeight / 2;

                        ctx.textBaseline = "alphabetic";
                        ctx.fillText(subTitle, canvasEl.width / 2, subTitleBaseline);

                        currentY = subTitleBaseline + subTitleMetrics.actualBoundingBoxDescent + subTitleFontSize * 0.7;
                    }

                    currentY += 10;

                    if (gameMode === 'freeMode' || gameMode === 'classification') {
                        const tableOuterTopPadding = 30; 
                        const tableBottomPadding = 10; 
                        const tableSidePadding = canvasEl.width * 0.05;
                        const tableRectX = tableSidePadding;
                        const tableRectWidth = canvasEl.width - (2 * tableSidePadding);
                        const tableCornerRadius = 10; 
                        const tableBorderWidth = 2;
                        const tableBorderColor = "#4B5563";
                        const internalLineWidth = tableBorderWidth; 

                        const classificationTitleText = `Clasificación`;
                        let classificationTitleY = currentY; 
                        
                        const titleRowBgColor = "#1F2937"; 
                        const headerRowBgColor = "#1F2937"; 
                        const titleRowPaddingY = 5;

                        const titleRowHeight = highScoreTitleFontSize + 2 * titleRowPaddingY;
                        const headerRowHeight = tableHeaderFontSize + 10; 
                        
                        const tableContentStartY = classificationTitleY - highScoreTitleFontSize * 0.5 - titleRowPaddingY; 
                        const tableBgEndY = canvasEl.height - tableBottomPadding;
                        const tableBgHeight = tableBgEndY - tableContentStartY;

                        const availableHeightForScores = tableBgHeight - titleRowHeight - headerRowHeight - (tableBorderWidth * 2);
                        let dynamicScoreRowHeight = highScoreEntryFontSize + 10; 
                        if (MAX_HIGH_SCORES > 0 && availableHeightForScores > 0) {
                            dynamicScoreRowHeight = Math.max(highScoreEntryFontSize + 4, availableHeightForScores / MAX_HIGH_SCORES);
                        }

                        if (tableBgHeight > 0) {
                            ctx.fillStyle = "#374151"; 
                            ctx.strokeStyle = tableBorderColor;
                            ctx.lineWidth = tableBorderWidth;
                            ctx.beginPath();
                            ctx.roundRect(tableRectX, tableContentStartY, tableRectWidth, tableBgHeight, tableCornerRadius);
                            ctx.fill();
                            ctx.stroke();
                        }
                        
                        const titleRowActualY = tableContentStartY;
                        ctx.fillStyle = titleRowBgColor;
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(tableRectX + tableBorderWidth / 2, titleRowActualY + tableBorderWidth / 2, tableRectWidth - tableBorderWidth, titleRowHeight);
                        ctx.clip(); 
                        ctx.beginPath();
                        ctx.roundRect(tableRectX, titleRowActualY, tableRectWidth, titleRowHeight + tableCornerRadius, [tableCornerRadius, tableCornerRadius, 0, 0]); 
                        ctx.fill();
                        ctx.restore();
                        
                        ctx.font = `${highScoreTitleFontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = "#8f66af";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(classificationTitleText, canvasEl.width / 2, titleRowActualY + titleRowHeight / 2);

                        let currentDrawingYForTable = titleRowActualY + titleRowHeight;
                        
                        const headerRowActualY = currentDrawingYForTable;
                        ctx.fillStyle = headerRowBgColor;
                        ctx.fillRect(tableRectX + tableBorderWidth/2, headerRowActualY, tableRectWidth - tableBorderWidth, headerRowHeight);

                        const headerTextY = headerRowActualY + headerRowHeight / 2;
                        // AJUSTE DE POSICIONES X PARA LA TABLA DE PUNTUACIONES
                        const rankX = tableRectX + tableRectWidth * 0.08;    // Para "Nº"
                        const scoreX = tableRectX + tableRectWidth * 0.27;   // Para "PUNTOS"
                        const lengthX = tableRectX + tableRectWidth * 0.50;  // Para valor secundario
                        const skinX = tableRectX + tableRectWidth * 0.79;   // Para "JUGADOR" (más espacio)

                        const headerFont = `${tableHeaderFontSize}px 'Press Start 2P'`;
                        const headerColor = "#F5F5F5";
                        ctx.font = headerFont;
                        ctx.fillStyle = headerColor;
                        ctx.textAlign = "center"; // Asegurar alineación central
                        ctx.textBaseline = "middle"; // Asegurar alineación vertical

                        ctx.fillText("Nº", rankX, headerTextY);
                        ctx.fillText("PUNTOS", scoreX, headerTextY);
                        const secondaryHeader = (gameMode === 'classification' || gameMode === 'freeMode') ? 'TIEMPO' : 'LONG.';
                        ctx.fillText(secondaryHeader, lengthX, headerTextY);
                        ctx.fillText("JUGADOR", skinX, headerTextY); // Usar el texto "JUGADOR"
                        currentDrawingYForTable = headerRowActualY + headerRowHeight;

                        const highScores = gameMode === 'freeMode' ? loadHighScores(difficulty) : loadClassificationHighScores(difficulty);
                        const entryFont = `${highScoreEntryFontSize}px 'Press Start 2P'`;
                        const defaultEntryColor = "#F5F5F5";
                        const highlightEntryColor = "#8f66af"; 
                        const blinkOffColor = "#5A6578"; 
                        
                        let newHighScoreEntryProcessedForVisuals = false; 

                        for (let i = 0; i < MAX_HIGH_SCORES; i++) { 
                            const scoreRowActualY = currentDrawingYForTable;
                            if (scoreRowActualY + dynamicScoreRowHeight > tableBgEndY - tableBorderWidth/2) break; 

                            const rowTextY = scoreRowActualY + dynamicScoreRowHeight / 2; 
                            
                            if (i > 0 || headerRowActualY + headerRowHeight < scoreRowActualY) {
                                ctx.strokeStyle = tableBorderColor; 
                                ctx.lineWidth = internalLineWidth; 
                                ctx.beginPath();
                                ctx.moveTo(tableRectX + tableBorderWidth / 2, scoreRowActualY); 
                                ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, scoreRowActualY);
                                ctx.stroke();
                            }
                            
                            if (highScores[i]) {
                                const entry = highScores[i];
                                let currentEntryColor = defaultEntryColor;
                                
                                let isThisTheNewRecordFromThisGame = isNewHighScore &&
                                                                entry.score === score &&
                                                                ((gameMode === 'classification' || gameMode === 'freeMode')
                                                                     ? entry.time === Math.floor(gameTimeElapsed / 1000)
                                                                     : entry.length === snake.length) &&
                                                                i === blinkAnimation.rowIndex &&
                                                                !newHighScoreEntryProcessedForVisuals;


                                if (blinkAnimation.active && isThisTheNewRecordFromThisGame) {
                                    const visible = Math.floor((Date.now() - blinkAnimation.startTime) / blinkAnimation.interval) % 2 === 0;
                                    currentEntryColor = visible ? highlightEntryColor : blinkOffColor;
                                } else if (isThisTheNewRecordFromThisGame && !blinkAnimation.active) { 
                                    currentEntryColor = highlightEntryColor;
                                } else if (isNewHighScore && i === blinkAnimation.rowIndex && !blinkAnimation.active) { 
                                    currentEntryColor = highlightEntryColor;
                                }
                                
                                ctx.fillStyle = currentEntryColor;
                                ctx.font = entryFont;
                                // textAlign y textBaseline ya están en "center" y "middle"
                                ctx.fillText(`${i + 1}.`, rankX, rowTextY);
                                ctx.fillText(`${entry.score}`, scoreX, rowTextY);
                                const secondaryValue = (gameMode === 'classification' || gameMode === 'freeMode') ? formatTime(entry.time) : entry.length;
                                ctx.fillText(`${secondaryValue}`, lengthX, rowTextY);
                                // Mostrar el nombre del jugador si está disponible, si no el nombre del skin
                                const playerDisplay = entry.playerName || SKIN_DISPLAY_NAMES[entry.skin] || entry.skin || '-';
                                ctx.fillText(playerDisplay, skinX, rowTextY);
                            } else {
                                ctx.fillStyle = defaultEntryColor;
                                ctx.font = entryFont;
                                ctx.fillText(`${i + 1}.`, rankX, rowTextY);
                                ctx.fillText("---", scoreX, rowTextY);
                                ctx.fillText("---", lengthX, rowTextY);
                                ctx.fillText("---", skinX, rowTextY); // Placeholder para skin
                            }
                            currentDrawingYForTable += dynamicScoreRowHeight; 
                        }
                        ctx.strokeStyle = tableBorderColor;
                        ctx.lineWidth = internalLineWidth; 
                        ctx.beginPath();
                        ctx.moveTo(tableRectX + tableBorderWidth / 2, titleRowActualY + titleRowHeight);
                        ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, titleRowActualY + titleRowHeight);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(tableRectX + tableBorderWidth / 2, headerRowActualY + headerRowHeight);
                        ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, headerRowActualY + headerRowHeight);
                        ctx.stroke();
                    }
                    ctx.textBaseline = "alphabetic"; 
                }
            }
        }
        
       function update() {
            if (gameOver || tileCountX <= 0 || tileCountY <= 0) return;
            updateSpeedBoost();
            updateMirrorEffect();
            refreshEffectReactions();

            direction = nextDirection; // Actualizar la dirección actual con la siguiente dirección almacenada

            let nextHeadX = snake[0].x;
            let nextHeadY = snake[0].y;
            switch (direction) {
                case "up":    nextHeadY--; break;
                case "down":  nextHeadY++; break;
                case "left":  nextHeadX--; break;
                case "right": nextHeadX++; break;
            }

            const willEatFood = currentFoodItem.x !== undefined && nextHeadX === currentFoodItem.x && nextHeadY === currentFoodItem.y;
            const willEatFalse = falseFoodItems.some(ff => ff.x === nextHeadX && ff.y === nextHeadY);
            const willEatLightning = lightningItems.some(li => li.x === nextHeadX && li.y === nextHeadY);
            const willEatMirror = mirrorItems.some(mi => mi.x === nextHeadX && mi.y === nextHeadY);
            if (willEatFood || willEatFalse || willEatLightning || willEatMirror) {
                setReaction('preEat');
            }

            if (nextHeadX < 0) nextHeadX = tileCountX - 1;
            else if (nextHeadX >= tileCountX) nextHeadX = 0;
            if (nextHeadY < 0) nextHeadY = tileCountY - 1;
            else if (nextHeadY >= tileCountY) nextHeadY = 0;

            if (!gameOver) {
                for (let i = 1; i < snake.length; i++) {
                    if (nextHeadX === snake[i].x && nextHeadY === snake[i].y) {
                        gameOver = true;
                        break;
                    }
                }
            }
            
            const nextHead = { x: nextHeadX, y: nextHeadY };
            let growth = 0; 
            if (currentFoodItem.x !== undefined && nextHead.x === currentFoodItem.x && nextHead.y === currentFoodItem.y) {
                let gained = POINTS_PER_FOOD;
                const rank = CLASSIFICATION_RANKS[difficulty] || 0;
                if ((gameMode === 'levels' && currentWorld >= 6) ||
                    (gameMode === 'classification' && rank >= 2) ||
                    (gameMode === 'freeMode' && freeModeSettings.streakReduction > 0)) {
                    gained *= streakMultiplier;
                    if (streakMultiplier < MAX_STREAK) { streakMultiplier += 0.5; }
                    if (streakMultiplier > MAX_STREAK) { streakMultiplier = MAX_STREAK; }
                    startStreakAnimation(streakMultiplier);
                }
                if (currentFoodItem.isGolden) gained *= 2;
                score += gained;
                if(areSfxEnabled) playSound('eat');
                scheduleEatReaction(currentFoodItem.isGolden ? 'eatGolden' : 'eat');

                growth = 1;
                clearTimeout(foodDisappearTimeoutId);
                clearInterval(foodVisualTimerIntervalId);
                foodTimeRemaining = 0;
                generateFood();

                if (gameMode === 'levels') {
                    const absoluteLevelIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
                    if (score >= LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1].targetScore) {
                        gameOver = true; // Level won by score
                    }
                } else if (gameMode === 'maze') {
                    while (mazeStarsEarned < MAZE_STAR_TARGETS.length && score >= MAZE_STAR_TARGETS[mazeStarsEarned]) {
                        mazeStarsEarned++;
                        if (mazeStarsEarned === MAZE_STAR_TARGETS.length) {
                            gameOver = true;
                            break;
                        } else {
                            displayTargetScore = MAZE_STAR_TARGETS[mazeStarsEarned];
                        }
                    }
                    drawStarProgress();
                    updateTargetScoreDisplay();
                }
            }

            if (gameOver) {
                finalizeGameOver();
                return;
            }
            for (let i = falseFoodItems.length - 1; i >= 0; i--) {
                const ff = falseFoodItems[i];
                if (nextHead.x === ff.x && nextHead.y === ff.y) {
                    score = Math.max(0, score - 25);
                    streakMultiplier = 1;
                    const rank = CLASSIFICATION_RANKS[difficulty] || 0;
                    if ((gameMode === 'levels' && currentWorld >= 6) ||
                        (gameMode === 'classification' && rank >= 2) ||
                        (gameMode === 'freeMode' && freeModeSettings.streakReduction > 0)) {
                        startStreakAnimation(streakMultiplier);
                    }
                    removeFalseFoodItem(ff);
                    if (areSfxEnabled) playSound('badEat');
                    scheduleEatReaction('eatFalse');
                }
            }
            for (let i = lightningItems.length - 1; i >= 0; i--) {
                const lt = lightningItems[i];
                if (nextHead.x === lt.x && nextHead.y === lt.y) {
                    activateSpeedBoost(lt.color);
                    removeLightningItem(lt);
                    if (areSfxEnabled) playSound('eat');
                    scheduleEatReaction('eatSpeed', SPEED_BOOST_DURATION - PRE_EAT_DELAY_MS);
                }
            }
            for (let i = mirrorItems.length - 1; i >= 0; i--) {
                const mi = mirrorItems[i];
                if (nextHead.x === mi.x && nextHead.y === mi.y) {
                    if (speedBoost.active) {
                        applySpeedChange(-speedBoost.change);
                        speedBoost = { active: false, color: '', change: 0, startTime: 0 };
                    }
                    controlsInverted = true;
                    mirrorEffect = { active: true, startTime: Date.now() };
                    score += POINTS_PER_MIRROR;
                    removeMirrorItem(mi);
                    if (areSfxEnabled) playSound('eat');
                    scheduleEatReaction('eatMirror', MIRROR_EFFECT_DURATION - PRE_EAT_DELAY_MS);
                }
            }
            for (const ob of obstacles) {
                if (nextHead.x === ob.x && nextHead.y === ob.y) {
                    gameOver = true;
                    break;
                }
            }
            if (gameOver) {
                finalizeGameOver();
                return;
            }

            snake.unshift(nextHead);
            if (growth === 0) { snake.pop(); }

            updateScoreDisplay(); 
            if (gameMode === 'freeMode' || gameMode === 'levels') { 
                updateTimeLengthDisplay(); 
            }
            draw();
        }
        
        function updateScoreDisplay() {
            scoreValueDisplay.textContent = score;
        }

        function updateCoinDisplay() {
            coinValueDisplay.textContent = totalCoins;
            if (selectorCoinValueDisplay) selectorCoinValueDisplay.textContent = totalCoins;
        }

        function updateGemDisplay() {
            if (selectorGemsValueDisplay) selectorGemsValueDisplay.textContent = totalGems;
        }

        function animateCoinGain(oldTotal, newTotal) {
            const diff = newTotal - oldTotal;
            if (diff <= 0) {
                coinValueDisplay.textContent = newTotal;
                if (selectorCoinValueDisplay) selectorCoinValueDisplay.textContent = newTotal;
                return;
            }
            const duration = Math.min(2000, diff * 60);
            const start = performance.now();
            if (areSfxEnabled) playSound('coinAdd', duration / 1000);
            function step(now) {
                const progress = Math.min(1, (now - start) / duration);
                const value = Math.floor(oldTotal + diff * progress);
                coinValueDisplay.textContent = value;
                if (selectorCoinValueDisplay) selectorCoinValueDisplay.textContent = value;
                if (progress < 1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function showEarnedCoinsMessage(amount) {
            if (!earnedCoinsMessage) return;
            earnedCoinsMessage.textContent = `+${amount}`;
            earnedCoinsMessage.classList.remove('hidden', 'hide');
            void earnedCoinsMessage.offsetWidth;
            earnedCoinsMessage.classList.add('show');
            setTimeout(() => {
                earnedCoinsMessage.classList.remove('show');
                earnedCoinsMessage.classList.add('hide');
                setTimeout(() => {
                    earnedCoinsMessage.classList.add('hidden');
                    earnedCoinsMessage.classList.remove('hide');
                }, 300);
            }, COIN_MESSAGE_DISPLAY_TIME);
        }

        function showInsufficientFundsToast(message = 'Monedas insuficientes') {
            if (!insufficientFundsToast) return;
            const valueBox = insufficientFundsToast.querySelector('.value-box');
            const originalText = valueBox ? valueBox.textContent : '';
            if (valueBox) valueBox.textContent = message;
            insufficientFundsToast.classList.remove('hidden');
            void insufficientFundsToast.offsetWidth;
            insufficientFundsToast.classList.add('show');
            setTimeout(() => {
                insufficientFundsToast.classList.remove('show');
                insufficientFundsToast.classList.add('hidden');
                if (valueBox) valueBox.textContent = originalText;
            }, 1000);
        }


        function saveLives() {
            localStorage.setItem('snakeGameLives', playerLives.toString());
            localStorage.setItem('snakeGameLifeQueue', JSON.stringify(lifeRestoreQueue));
        }

        function loadLives() {
            const storedLives = parseInt(localStorage.getItem('snakeGameLives'), 10);
            playerLives = Number.isFinite(storedLives) ? Math.min(MAX_LIVES, storedLives) : MAX_LIVES;
            try {
                const queue = JSON.parse(localStorage.getItem('snakeGameLifeQueue') || '[]');
                if (Array.isArray(queue)) lifeRestoreQueue = queue.map(n => parseInt(n, 10)).filter(n => Number.isFinite(n));
            } catch (e) {
                lifeRestoreQueue = [];
            }
            checkLifeRecovery(true);
        }

        function updateLivesDisplay() {
            if (livesValueDisplay) livesValueDisplay.textContent = playerLives;
            if (selectorLivesValueDisplay) selectorLivesValueDisplay.textContent = playerLives;
            if (progressLivesValueDisplay) progressLivesValueDisplay.textContent = playerLives;
        }

        function updateLifeTimerDisplay() {
            if (!(lifeTimerValueDisplay || selectorLifeTimerValueDisplay || progressLifeTimerValueDisplay)) return;
            if (playerLives >= MAX_LIVES || lifeRestoreQueue.length === 0) {
                if (lifeTimerValueDisplay) lifeTimerValueDisplay.textContent = 'Lleno';
                if (selectorLifeTimerValueDisplay) selectorLifeTimerValueDisplay.textContent = 'Lleno';
                if (progressLifeTimerValueDisplay) progressLifeTimerValueDisplay.textContent = 'Lleno';
            } else {
                const remaining = Math.max(0, Math.ceil((lifeRestoreQueue[0] - Date.now()) / 1000));
                if (lifeTimerValueDisplay) lifeTimerValueDisplay.textContent = formatTime(remaining);
                if (selectorLifeTimerValueDisplay) selectorLifeTimerValueDisplay.textContent = formatTime(remaining);
                if (progressLifeTimerValueDisplay) progressLifeTimerValueDisplay.textContent = formatTime(remaining);
            }
        }

        function checkLifeRecovery(initial = false) {
            const now = Date.now();
            while (lifeRestoreQueue.length > 0 && lifeRestoreQueue[0] <= now && playerLives < MAX_LIVES) {
                lifeRestoreQueue.shift();
                playerLives++;
            }
            if (playerLives > MAX_LIVES) playerLives = MAX_LIVES;
            if (playerLives >= MAX_LIVES) lifeRestoreQueue = [];
            if (initial) saveLives();
            updateLivesDisplay();
            updateLifeTimerDisplay();
        }

        function loseLife() {
            if (playerLives <= 0) return;
            playerLives--;
            const lastTime = lifeRestoreQueue.length > 0 ? lifeRestoreQueue[lifeRestoreQueue.length - 1] : Date.now();
            lifeRestoreQueue.push(lastTime + LIFE_RECHARGE_TIME);
            saveLives();
            updateLivesDisplay();
            updateLifeTimerDisplay();
        }

        function updateTargetScoreDisplay() {
            if (targetScoreValueDisplay && targetScoreDivider) {
                 if (gameMode === 'levels' || gameMode === 'maze') { 
                    // Use displayTargetScore which is updated at the start of a game or when settings change
                    targetScoreValueDisplay.textContent = displayTargetScore;
                    targetScoreValueDisplay.classList.remove('hidden');
                    targetScoreDivider.classList.remove('hidden');
                } else { 
                    targetScoreValueDisplay.classList.add('hidden');
                    targetScoreDivider.classList.add('hidden');
                }
            }
        }
        
        function updateTimeLengthDisplay() {
            if (!gameMode) {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            } else if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = Math.max(0, Math.ceil(gameTimeRemaining / 1000));
            } else if (gameMode === 'classification' || gameMode === 'freeMode') {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
            } else { // other modes (currently none)
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            }
        }

        function displayHighScoreInPanel() {
            const selectedDifficulty = (gameMode === 'freeMode') ? freeDifficulty : difficultySelector.value;
            const highScores = loadHighScores(selectedDifficulty);
            const hsSkinValueDisplay = document.getElementById("hs-skin-value");

            if (highScores.length > 0) {
                hsScoreValue.textContent = highScores[0].score;
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = SKIN_DISPLAY_NAMES[highScores[0].skin] || highScores[0].skin || '-';
                }
            } else {
                hsScoreValue.textContent = "-";
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = "-";
                }
            }
        }
        
        function updateGameModeUI() {

            if (selectorInfoBar) selectorInfoBar.classList.toggle('hidden', !showModeSelect);
            topInfoBar.classList.toggle('hidden', showModeSelect);

            if (showModeSelect) {
                if (scoreValueDisplay) scoreValueDisplay.classList.add('hidden');
                if (targetScoreDivider) targetScoreDivider.classList.add('hidden');
                if (targetScoreValueDisplay) targetScoreValueDisplay.classList.add('hidden');
                updateCoinDisplay();
                updateGemDisplay();
                updateLivesDisplay();
                updateLifeTimerDisplay();
            } else {
                if (gameMode === 'freeMode') {
                    if (scoreValueDisplay) scoreValueDisplay.classList.add('hidden');
                    if (targetScoreDivider) targetScoreDivider.classList.add('hidden');
                    if (targetScoreValueDisplay) targetScoreValueDisplay.classList.add('hidden');
                    if (lifeTimerValueDisplay) lifeTimerValueDisplay.classList.remove('hidden');
                    if (livesValueDisplay) livesValueDisplay.classList.remove('hidden');
                        if (pointsIconImg) {
                            pointsIconImg.src = 'https://i.imgur.com/WrI2XXx.png';
                            pointsIconImg.alt = 'Vidas';
                        }
                    updateLivesDisplay();
                    updateLifeTimerDisplay();
                } else {
                    if (scoreValueDisplay) scoreValueDisplay.classList.remove('hidden');
                    if (targetScoreDivider && targetScoreValueDisplay) updateTargetScoreDisplay();
                    if (lifeTimerValueDisplay) lifeTimerValueDisplay.classList.add('hidden');
                    if (livesValueDisplay) livesValueDisplay.classList.add('hidden');
                        if (pointsIconImg) {
                            pointsIconImg.src = 'https://i.imgur.com/COqXj9s.png';
                            pointsIconImg.alt = 'Puntos';
                        }
                }
            }

            const isGameCurrentlyRunning = !!gameIntervalId;
            const isSettingsPanelCurrentlyOpen = !settingsPanel.classList.contains("settings-panel-hidden");
            progressPanel.classList.remove('classification-mode');
            if (classificationRankingGroup) classificationRankingGroup.classList.add('hidden');

            // Set default settings header appearance
            if (settingsTitle) {
                settingsTitle.textContent = 'CONFIGURACION';
            }
            if (mazeInfoButton) mazeInfoButton.classList.add('hidden');
            if (classificationInfoButton) classificationInfoButton.classList.add('hidden');
            if (freeModeInfoButton) freeModeInfoButton.classList.add('hidden');

            if (!gameMode) {
                titlePanel.classList.remove('hidden');
                progressPanel.classList.add('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.add('hidden');
                if (progressLivesInfoGroup) progressLivesInfoGroup.classList.add('hidden');
                if (currentWorldInfoGroup) currentWorldInfoGroup.classList.remove('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = "No disponible";

                difficultyLabel.textContent = "Nivel:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                difficultyInfoButton.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                mazeInfoButton.classList.add('hidden');

                if (isSettingsPanelCurrentlyOpen) {
                    difficultySelector.disabled = true;
                    worldsSelector.disabled = true;
                    mazeLevelButtonsContainer.classList.add('disabled');
                    difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'levels') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Mundo:";
                progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                if (progressLivesInfoGroup) progressLivesInfoGroup.classList.remove('hidden');
                if (currentWorldInfoGroup) currentWorldInfoGroup.classList.add('hidden');
                updateLivesDisplay();
                updateLifeTimerDisplay();
                
                difficultyLabel.textContent = "Mundo Actual:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.remove('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                difficultyControlGroup.classList.add('hidden');
                if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
                skinControlGroups.forEach(g => g.classList.add('hidden'));
                foodControlGroups.forEach(g => g.classList.add('hidden'));
                difficultyInfoButton.classList.add('hidden');
                worldInfoButton.classList.remove('hidden');
                if (freeModeInfoButton) freeModeInfoButton.classList.add('hidden');
                mazeInfoButton.classList.add('hidden');
                populateWorldButtons();
                drawStarProgress();

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    worldButtonsContainer.classList.remove('disabled');
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    worldButtonsContainer.classList.add('disabled');
                     if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                     else difficultyControlGroup.classList.remove("interactive-mode");
                }
                if (settingsTitle) {
                    settingsTitle.textContent = 'MODO AVENTURA';
                }
            } else if (gameMode === 'freeMode') {
                // En el modo libre mantendremos visible el título del juego y ocultaremos
                // el panel de progreso con la dificultad y la máxima puntuación.
                titlePanel.classList.remove('hidden');
                if (settingsTitle) {
                    settingsTitle.textContent = 'MODO LIBRE';
                }
                progressPanel.classList.add('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.add('hidden');
                if (progressLivesInfoGroup) progressLivesInfoGroup.classList.add('hidden');
                if (currentWorldInfoGroup) currentWorldInfoGroup.classList.remove('hidden');

                // Actualizamos la dificultad aunque no se muestre actualmente
                progressPanelLeftLabel.textContent = "Dificultad:";
                progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[freeDifficulty] || freeDifficulty;

                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.remove('hidden');
                if (freeModeInfoButton) freeModeInfoButton.classList.remove('hidden');
                mazeInfoButton.classList.add('hidden');

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'classification') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.remove('hidden');
                progressPanel.classList.add('classification-mode');
                if (progressLivesInfoGroup) {
                    progressLivesInfoGroup.classList.remove('hidden');
                    updateLivesDisplay();
                    updateLifeTimerDisplay();
                }
                if (currentWorldInfoGroup) currentWorldInfoGroup.classList.add('hidden');

                progressPanelLeftLabel.textContent = "Dificultad:";
                progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;

                displayClassificationHighScoreInPanel();
                if (classificationRankingGroup) {
                    classificationRankingGroup.classList.remove('hidden');
                    populateClassificationRanking();
                }

                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.remove('hidden');
                mazeInfoButton.classList.add('hidden');
                if (freeModeInfoButton) freeModeInfoButton.classList.add('hidden');
                if (classificationInfoButton) classificationInfoButton.classList.remove('hidden');
                if (freeModeInfoButton) freeModeInfoButton.classList.add('hidden');
                if (settingsTitle) {
                    settingsTitle.textContent = 'MODO CLASIFICACION';
                }

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
                skinControlGroups.forEach(g => g.classList.add('hidden'));
                foodControlGroups.forEach(g => g.classList.add('hidden'));
                audioControlGroup.classList.add('hidden');
                musicVolumeControlGroup.classList.add('hidden');
                sfxVolumeControlGroup.classList.add('hidden');
                resetDataButton.classList.add('hidden');
            } else if (gameMode === 'maze') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');
                if (progressLivesInfoGroup) {
                    progressLivesInfoGroup.classList.remove('hidden');
                    updateLivesDisplay();
                    updateLifeTimerDisplay();
                }
                if (currentWorldInfoGroup) currentWorldInfoGroup.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = displayMazeLevel;
                drawStarProgress();

                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                difficultyControlGroup.classList.add('hidden');
                if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
                skinControlGroups.forEach(g => g.classList.add('hidden'));
                foodControlGroups.forEach(g => g.classList.add('hidden'));
                mazeLevelButtonsContainer.classList.remove('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.add('hidden');
                mazeInfoButton.classList.remove('hidden');
                if (freeModeInfoButton) freeModeInfoButton.classList.add('hidden');
                populateMazeLevelButtons();

                if (settingsTitle) {
                    settingsTitle.textContent = 'MODO LABERINTO';
                }

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    mazeLevelButtonsContainer.classList.remove('disabled');
                } else {
                    mazeLevelButtonsContainer.classList.add('disabled');
                }
            } else {
                titlePanel.classList.add('hidden');
                progressPanel.classList.add('hidden');
                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.remove('hidden');
                if (freeModeInfoButton) freeModeInfoButton.classList.add('hidden');
                mazeInfoButton.classList.add('hidden');
                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            }

            updateTargetScoreDisplay();

            if (!gameMode) {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            } else if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                     timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
                } else if (!gameOver) {
                     timeLengthValueEl.textContent = Math.max(0, Math.ceil(gameTimeRemaining / 1000));
                } else {
                     timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
                }
            } else if (gameMode === 'classification') {
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                    timeLengthValueEl.textContent = formatTime(0);
                } else {
                    timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
                }
            } else { // freeMode
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                    timeLengthValueEl.textContent = formatTime(0);
                } else {
                    timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
                }
            }
        }

function populateWorldsSelector() {
            worldsSelector.innerHTML = '';
            for (let i = 1; i <= TOTAL_WORLDS; i++) {
                const option = document.createElement('option');
                option.value = i;
                const name = WORLD_DISPLAY_NAMES[i - 1] || '';
                option.textContent = name ? `${i}.${name}` : `${i}`;
                option.disabled = i > maxUnlockedWorld;
                if (i === currentWorld) {
                    option.selected = true;
                }
                worldsSelector.appendChild(option);
            }
        }

function populateWorldButtons() {
            worldButtonsContainer.innerHTML = '';
            for (let i = 1; i <= TOTAL_WORLDS; i++) {
                const button = document.createElement('div');
                button.className = 'world-button';
                const worldImg = worldImagesConfig[i]?.cover || '';
                button.style.backgroundImage = `url('https://i.imgur.com/8Gp9hfW.png'), url('${worldImg}')`;
                button.style.backgroundSize = 'contain, 67%';
                button.style.backgroundRepeat = 'no-repeat';
                button.style.backgroundPosition = 'center, center 45%';

                const starsContainer = document.createElement('div');
                starsContainer.className = 'maze-stars';

                const completedLevels = levelsProgress.slice((i - 1) * LEVELS_PER_WORLD, i * LEVELS_PER_WORLD).filter(Boolean).length;
                for (let j = 0; j < LEVELS_PER_WORLD; j++) {
                    const star = document.createElement('div');
                    star.className = 'star ' + (j < completedLevels ? 'full' : 'empty');
                    starsContainer.appendChild(star);
                }

                button.appendChild(starsContainer);

                if (i > maxUnlockedWorld) {
                    button.classList.add('disabled');
                }

                button.addEventListener('click', () => {
                    if (i > maxUnlockedWorld) return;

                    currentWorld = i;
                    currentLevelInWorld = worldCurrentLevels[i - 1] || 1;
                    displayWorld = currentWorld;
                    displayLevelInWorld = currentLevelInWorld;
                    const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                    displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1].targetScore || 0;
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                    }
                    drawStarProgress();

                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;

                    saveGameSettings();

                    closeSettingsPanel();

                    requestAnimationFrame(draw);
                });

                addIconPressEvents(button, button);

                worldButtonsContainer.appendChild(button);
            }
        }

function populateMazeLevelButtons() {
            mazeLevelButtonsContainer.innerHTML = '';
            for (let i = 1; i <= MAZE_LEVEL_COUNT; i++) {
                const button = document.createElement('div');
                button.className = 'maze-level-button';

                const num = document.createElement('div');
                num.className = 'maze-level-number';
                num.textContent = i;

                const starsContainer = document.createElement('div');
                starsContainer.className = 'maze-stars';

                const starsEarned = mazeLevelStars[i - 1] || 0;
                for (let j = 0; j < MAZE_STAR_TARGETS.length; j++) {
                    const star = document.createElement('div');
                    star.className = 'star ' + (j < starsEarned ? 'full' : 'empty');
                    starsContainer.appendChild(star);
                }

                button.appendChild(num);
                button.appendChild(starsContainer);

                if (i > currentMazeLevel) {
                    button.classList.add('disabled');
                }

                button.addEventListener('click', () => {
                    if (i > currentMazeLevel) return;

                    displayMazeLevel = i;
                    mazePreviousStars = mazeLevelStars[i - 1] || 0;
                    mazeStarsEarned = mazePreviousStars;
                    if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                        displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                    } else {
                        displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                    }
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = displayMazeLevel;
                    }
                    drawStarProgress();

                    screenState.showMazeCover = true;
                    screenState.gameActuallyStarted = false;
                    screenState.mazeResultType = '';
                    restartMazeButton.classList.add('hidden');
                    startButtonWrapperEl.classList.remove('split');

                    saveGameSettings();

                    closeSettingsPanel();

                    requestAnimationFrame(draw);
                });

                // Press feedback similar to start button
                addIconPressEvents(button, button);

                mazeLevelButtonsContainer.appendChild(button);
            }
        }

        function drawStarProgress() {
            starProgressContainer.innerHTML = '';
            if (gameMode === 'levels') {
                const worldToDisplayStarsFor = (screenState.showCoverForWorld > 0 && !screenState.gameActuallyStarted)
                    ? displayWorld
                    : (gameOver ? displayWorld : currentWorld);
                const worldLevelStartIndex = (worldToDisplayStarsFor - 1) * LEVELS_PER_WORLD;
                for (let i = 0; i < LEVELS_PER_WORLD; i++) {
                    const levelIndexInTotal = worldLevelStartIndex + i;
                    const isCompleted = levelsProgress[levelIndexInTotal];
                    const star = document.createElement('div');
                    star.className = 'progress-star ' + (isCompleted ? 'full' : 'empty');
                    starProgressContainer.appendChild(star);
                }
            } else if (gameMode === 'maze') {
                for (let i = 0; i < MAZE_STAR_TARGETS.length; i++) {
                    const isEarned = i < mazeStarsEarned;
                    const star = document.createElement('div');
                    star.className = 'progress-star ' + (isEarned ? 'full' : 'empty');
                    starProgressContainer.appendChild(star);
                }
            }
        }
        
        async function ensureAudioContextRunning() {
            if (typeof Tone === 'undefined') return false;
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start(); 
                    console.log("Tone.js context (re)started/resumed by ensureAudioContextRunning.");
                    if (Tone.context.state === 'running' && !synthsInitialized) { 
                        initializeToneSynths();
                    }
                    return Tone.context.state === 'running';
                } catch (e) {
                    console.error("Error trying to start/resume Tone.js context in ensureAudioContextRunning:", e);
                    return false;
                }
            } else if (!synthsInitialized) { 
                 initializeToneSynths();
            }
            return true; 
        }
        
        function initializeToneSynths() {
            if (typeof Tone === 'undefined' || Tone.context.state !== 'running') {
                console.warn("Tone.js context not running. Synth initialization deferred or skipped.");
                synthsInitialized = false; 
                return;
            }
            if (synthsInitialized) return; 

            console.log("Initializing Tone.js Synths...");
            sfxGain = new Tone.Gain(1).toDestination();
            synthEat = new Tone.MonoSynth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.04, sustain: 0.01, release: 0.08 }, filterEnvelope: { attack: 0.002, decay: 0.01, sustain: 0, release: 0.02, baseFrequency: 1500, octaves: 1.5, exponent: 2 } }).connect(sfxGain);
            synthEat.volume.value = 0;
            synthEatNoise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 } }).connect(sfxGain);
            synthEatNoise.volume.value = -10;
            synthBadEat = new Tone.MonoSynth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.15 }, filterEnvelope: { attack: 0.002, decay: 0.02, sustain: 0, release: 0.05, baseFrequency: 500, octaves: 1.2, exponent: 2 } }).connect(sfxGain);
            synthBadEat.volume.value = 0;
            synthWarning = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).connect(sfxGain);
            synthWarning.volume.value = 0;
            synthTimeout = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).connect(sfxGain);
            synthTimeout.volume.value = 0;
            synthGameOver = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.3 } }).connect(sfxGain);
            synthGameOver.volume.value = 0;
            synthStartGame = new Tone.Synth({ oscillator: {type: 'triangle'}, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 } }).connect(sfxGain);
            synthStartGame.volume.value = 0;
            synthWin = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 } }).connect(sfxGain);
            synthWin.volume.value = -4; // lower victory sound volume
            synthCoinNoise = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 } }).connect(sfxGain);
            synthCoinNoise.volume.value = -8;
            synthCoinChime = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).connect(sfxGain);
            synthCoinChime.volume.value = -2;
            synthModeSwitch = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 } }).connect(sfxGain);
            synthModeSwitch.volume.value = -2;
            synthModeSelect = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.05 } }).connect(sfxGain);
            synthModeSelect.volume.value = -2;
            // synthSplashStart is initialized in window.onload
            if (synthSplashStart) {
                try {
                    synthSplashStart.disconnect();
                    synthSplashStart.connect(sfxGain);
                } catch (e) {
                    console.warn('Could not route splash start sound through sfxGain:', e);
                }
            }

            updateSfxVolume();

            synthsInitialized = true;
            console.log("Tone.js Synths initialized.");
        }


async function startGame(isRestart = false) {
    if (playerLives <= 0 && startButton.textContent !== "AJUSTES") {
        openOutOfLivesPanel();
        return;
    }
    isNewHighScore = false;
    blinkAnimation.active = false;
    blinkAnimation.rowIndex = -1;
    streakAnimation.active = false;
    gameOverByTimeout = false;
    gameOverByInactivity = false;

    // Reset any lingering speed boost or mirror effect from a previous game
    speedBoost = { active: false, color: '', change: 0, startTime: 0 };
    controlsInverted = false;

    mirrorEffect = { active: false, startTime: 0 };

    if (gameMode === 'maze') {
        if (isRestart && (screenState.mazeResultType === 'partial' || screenState.mazeResultType === 'perfect')) {
            displayMazeLevel = Math.max(1, currentMazeLevel - 1);
        } else if (screenState.mazeResultType === 'partial' || screenState.mazeResultType === 'perfect') {
            if (displayMazeLevel < currentMazeLevel) {
                displayMazeLevel = getNextIncompleteMazeLevel(displayMazeLevel);
            } else {
                displayMazeLevel = currentMazeLevel;
            }
        }
    }
            
            const wasOnWorldCompleteCoverForNewWorld = screenState.showWorldCompleteCover > 0 && startButton.textContent === "NUEVO MUNDO";
        
            // Reset all visual state flags that are managed before game loop starts
            screenState.showCoverForWorld = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showWorldCompleteCover = 0;
            screenState.showFreeModeCover = false;
            screenState.showFreeModeEnd = false;
            screenState.showMazeCover = false;
            screenState.mazeResultType = '';
            restartMazeButton.classList.add('hidden');
            startButtonWrapperEl.classList.remove('split');
        
            if (startButton.textContent === "AJUSTES") {
                openSettingsPanel();
                screenState.gameActuallyStarted = false; 
            } else {
                closeSettingsPanel(); 
                closeInfoPanel(); 
        
                if (gameMode === 'levels' && wasOnWorldCompleteCoverForNewWorld) {
                    // currentWorld and currentLevelInWorld are already set for the new world
                    screenState.showCoverForWorld = currentWorld; 
                    screenState.gameActuallyStarted = false; 

                    // Update display variables for the new world's cover screen
                    displayWorld = currentWorld;
                    displayLevelInWorld = currentLevelInWorld;
                    const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                    if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TOTAL_WORLDS * LEVELS_PER_WORLD) {
                        displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1].targetScore;
                    } else {
                        displayTargetScore = 0; // Should not happen if TOTAL_WORLDS is correct
                    }
                    score = 0; // Reset score when transitioning to new world cover
                    streakMultiplier = 1; // Reset streak
                    updateScoreDisplay(); // Update UI to show 0 score & x1 streak

                    // Update UI elements that depend on display variables
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                    }
                    drawStarProgress(); // Update stars for the new world being displayed

                } else {
                    screenState.gameActuallyStarted = true;
                }
            }
            
            if (!screenState.gameActuallyStarted) { 
                draw();
                if (selectedMode === 'freeMode') {
                    setTimeout(updateMainButtonStates, 0);
                } else {
                    updateMainButtonStates();
                }
                return;
            }
            
            // If we reach here, screenState.gameActuallyStarted is true.
            // Update display variables to the actual level being started
            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);

            if (gameMode === 'levels') {
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TOTAL_WORLDS * LEVELS_PER_WORLD) {
                    displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1].targetScore;
                } else { // Should only happen if all levels/worlds are completed
                    displayTargetScore = LEVEL_SETTINGS[TOTAL_WORLDS - 1][LEVELS_PER_WORLD - 1].targetScore;
                    console.warn("Attempting to start a level beyond defined targets. Using last target score.");
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            } else { // freeMode
                displayTargetScore = 0; // No target score in free mode
            }

            updateTargetScoreDisplay(); // Update UI with the target of the level to be played
            if (progressPanelLeftValue && gameMode === 'levels') { // Update progress panel UI
                progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
            } else if (progressPanelLeftValue && gameMode === 'maze') {
                progressPanelLeftValue.textContent = displayMazeLevel;
            } else if (progressPanelLeftValue && (gameMode === 'freeMode' || gameMode === 'classification')) {
                // El panel de #high-score-display ahora se encarga de su propio label.
                // progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;
            }
            drawStarProgress(); // Update stars for the current world being played


            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            if (audioContextStarted && areSfxEnabled) {
                 playSound('startGame');
            }

            let desiredMusic = inGameBackgroundMusicURL;
            if (gameMode === 'levels') {
                desiredMusic = WORLD_MUSIC_URLS[currentWorld] || inGameBackgroundMusicURL;
            } else if (gameMode === 'maze') {
                desiredMusic = MODE_MUSIC_URLS.maze;
            } else if (gameMode === 'freeMode') {
                desiredMusic = MODE_MUSIC_URLS.freeMode;
            } else if (gameMode === 'classification') {
                desiredMusic = MODE_MUSIC_URLS.classification;
            }
            let sourceChanged = false;
            if (inGameBackgroundMusic && inGameBackgroundMusic.src !== desiredMusic) {
                inGameBackgroundMusic.src = desiredMusic;
                sourceChanged = true;
            }

            if (generalBackgroundMusic) {
                generalBackgroundMusic.pause();
                console.log("Música general pausada (startGame).");
            }
            if (isMusicEnabled && inGameBackgroundMusic) {
                if (sourceChanged) {
                    inGameBackgroundMusic.currentTime = 0;
                }
                inGameBackgroundMusic.play().catch(e => console.error("Error al reproducir música de partida (startGame):", e));
                console.log("Música de partida iniciada (startGame).");
            } else if (inGameBackgroundMusic) {
                inGameBackgroundMusic.pause();
            }


            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                snakeSpeed = levelCfg.speed;
                initialSnakeLength = levelCfg.initialLength;
                MIRROR_EFFECT_DURATION = levelCfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            } else if (gameMode === 'freeMode') {
                const cfg = freeModeSettings;
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = cfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            } else if (gameMode === 'classification') {
                difficulty = difficultySelector.value;
                const cfg = DIFFICULTY_SETTINGS[difficulty];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = cfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            } else { // maze
                currentMazeDifficulty = getMazeDifficultyForLevel(displayMazeLevel);
                difficulty = currentMazeDifficulty;
                const cfg = DIFFICULTY_SETTINGS[currentMazeDifficulty];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = cfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            }

            applySkin(getSelectedSkin());
            
            resizeGameElements(); 
            if (tileCountX <= 0 || tileCountY <= 0) { 
                console.error("Pantalla demasiado pequeña para jugar.");
                updateMainButtonStates();
                return;
            }

            snake = [];
            let startX = Math.floor(tileCountX / 2);
            let startY = Math.floor(tileCountY / 2);
            if (gameMode === 'maze' &&
                (displayMazeLevel === 3 || displayMazeLevel === 13 ||
                 displayMazeLevel === 23 || displayMazeLevel === 33)) {
                startX = 1;
                startY = 1;
            }
            snakeSpawnRow = startY;
            for (let i = 0; i < initialSnakeLength; i++) {
                if (startX - i >= 0) { snake.push({ x: startX - i, y: startY }); }
                else { snake.push({ x: 0, y: startY }); }
            }
             if (snake.length === 0 && initialSnakeLength > 0) {
                console.error("Error al iniciar la serpiente. Pantalla muy pequeña.");
                updateMainButtonStates();
                return;
            }

            score = 0;
            streakMultiplier = 1; 
            gameOver = false; 
            direction = "right"; 
            nextDirection = "right"; // Asegurar que nextDirection también se reinicia
            
            if (gameMode === 'levels' || gameMode === 'maze') {
                gameTimeRemaining = LEVEL_TIME_LIMIT;
                // Target score already updated via displayTargetScore
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = setInterval(() => {
                    if (gameOver) { clearInterval(gameTimerIntervalId); return; }
                    gameTimeRemaining -= 1000;
                    updateTimeLengthDisplay();
                    if (gameTimeRemaining <= 0) {
                        if (!gameOver) {
                            gameOver = true;
                            gameOverByTimeout = true;
                            finalizeGameOver();
                        }
                        clearInterval(gameTimerIntervalId);
                    }
                }, 1000);
            } else if (gameMode === 'classification' || gameMode === 'freeMode') {
                gameTimeElapsed = 0;
                if (gameMode === 'freeMode') {
                    gameTimeRemaining = Infinity;
                }
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = setInterval(() => {
                    if (gameOver) { clearInterval(gameTimerIntervalId); return; }
                    gameTimeElapsed += 1000;
                    updateTimeLengthDisplay();
                }, 1000);
            } else {
                gameTimeElapsed = 0;
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
            }
            if (gameMode === "levels") {
                const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                if (cfg.falseFoodSpawnRange) {
                    startWorld4FalseFoodMechanics();
                } else {
                    stopWorld4FalseFoodMechanics();
                }
                if (cfg.obstacleCount && cfg.obstacleCount > 0) {
                    startWorld6Obstacles(cfg.obstacleCount);
                } else {
                    stopWorld6Obstacles();
                }
                if (cfg.lightningSpawnRange) {
                    startWorld6LightningMechanics();
                } else {
                    stopWorld6LightningMechanics();
                }
                if (cfg.mirrorSpawnRange) {
                    startWorld7MirrorMechanics();
                } else {
                    stopWorld7MirrorMechanics();
                }
            } else if (gameMode === 'classification') {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                stopWorld4FalseFoodMechanics();
                const rank = CLASSIFICATION_RANKS[difficultySelector.value] || 0;
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (rank >= 2) startWorld6LightningMechanics();
                if (rank >= 3) {
                    startWorld4FalseFoodMechanics();
                    const count = cfg.obstacleCount;
                    if (rank >= 4) {
                        startWorld8Obstacles(count);
                    } else {
                        startWorld6Obstacles(count);
                    }
                    startWorld7MirrorMechanics();
                }
            } else if (gameMode === 'maze') {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                stopWorld4FalseFoodMechanics();
                const rank = CLASSIFICATION_RANKS[currentMazeDifficulty] || 0;
                const cfg = DIFFICULTY_SETTINGS[currentMazeDifficulty] || {};
                if (rank >= 2) startWorld6LightningMechanics();
                if (rank >= 3) {
                    startWorld4FalseFoodMechanics();
                    // En modo laberinto no generamos obstáculos adicionales en
                    // dificultades veterano o legendario
                    startWorld7MirrorMechanics();
                }
                startMazeLevel();
            } else {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                stopWorld4FalseFoodMechanics();
                if (freeModeSettings.obstacleCount > 0) startWorld6Obstacles(freeModeSettings.obstacleCount);
                if (freeModeSettings.lightningSpawnRange) startWorld6LightningMechanics();
                if (freeModeSettings.falseFoodSpawnRange) startWorld4FalseFoodMechanics();
                if (freeModeSettings.mirrorSpawnRange) startWorld7MirrorMechanics();
            }
            
            generateFood(); 
            updateScoreDisplay();
            clearInterval(gameIntervalId); 
            gameIntervalId = setInterval(update, snakeSpeed); 

            updateMainButtonStates(); 
            
            difficultySelector.disabled = true;
            worldsSelector.disabled = true;
            audioToggleSelector.disabled = true;
            skinSelectors.forEach(sel => sel.disabled = true);
            foodSelectors.forEach(sel => sel.disabled = true);
            musicVolumeSlider.disabled = true;
            sfxVolumeSlider.disabled = true;
            difficultyControlGroup.classList.remove("interactive-mode");
            audioControlGroup.classList.remove("interactive-mode");
            skinControlGroups.forEach(g => g.classList.remove("interactive-mode"));
            foodControlGroups.forEach(g => g.classList.remove("interactive-mode"));
            musicVolumeControlGroup.classList.remove("interactive-mode");
            sfxVolumeControlGroup.classList.remove("interactive-mode");
            if (gameMode === 'freeMode') {
                lastMovementTime = Date.now();
                clearInterval(inactivityIntervalId);
                inactivityIntervalId = setInterval(() => {
                    if (gameMode === 'freeMode' && gameIntervalId && !gameOver && Date.now() - lastMovementTime >= FREE_MODE_INACTIVITY_LIMIT) {
                        gameOverByInactivity = true;
                        finalizeGameOver();
                    }
                }, 1000);
            }
            draw();
        }

        function changeDirection(newDirectionCmd) { // Renamed parameter for clarity
            if (gameOver) return;
            if (gameMode === 'freeMode') {
                lastMovementTime = Date.now();
            }
            // Invert controls if mirror effect active
            if (controlsInverted) {
                switch (newDirectionCmd) {
                    case "up": newDirectionCmd = "down"; break;
                    case "down": newDirectionCmd = "up"; break;
                    case "left": newDirectionCmd = "right"; break;
                    case "right": newDirectionCmd = "left"; break;
                }
            }
            // Solo actualizar nextDirection, no direction directamente
            switch (newDirectionCmd) {
                case "up":    if (direction !== "down")  nextDirection = "up"; break;
                case "down":  if (direction !== "up")    nextDirection = "down"; break;
                case "left":  if (direction !== "right") nextDirection = "left"; break;
                case "right": if (direction !== "left")  nextDirection = "right"; break;
            }
        }

        async function playSound(type, param = null) {
            if (!areSfxEnabled) return; 
            
            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            if (!audioContextStarted) {
                console.warn(`Audio context not running, cannot play sound: ${type}`);
                return;
            }
            // initializeToneSynths() is called by ensureAudioContextRunning if needed

            if (!synthsInitialized) { // Check again if initialization failed even after ensureAudioContextRunning
                 console.warn(`Synths not initialized, cannot play sound: ${type}`);
                return;
            }

            const now = Tone.now();
            try {
                if (type === 'eat') {
                    if (synthEat) { const baseNote = "D5"; const targetNote = "A4"; const duration = 0.07; synthEat.triggerAttack(baseNote, now); synthEat.frequency.linearRampToValueAtTime(targetNote, now + duration * 0.7); synthEat.triggerRelease(now + duration); }
                    if (synthEatNoise) { synthEatNoise.triggerAttackRelease("64n", now + 0.005); }
                } else if (type === 'badEat' && synthBadEat) {
                    const duration = 0.1;
                    synthBadEat.triggerAttack("G4", now);
                    synthBadEat.frequency.linearRampToValueAtTime("C4", now + duration * 0.7);
                    synthBadEat.triggerRelease(now + duration);
                    if (synthEatNoise) { synthEatNoise.triggerAttackRelease("64n", now + 0.005); }
                } else if (type === 'warning' && synthWarning) { synthWarning.triggerAttackRelease("A4", "32n", now);
                } else if (type === 'timeout' && synthTimeout) { synthTimeout.triggerAttackRelease("F#3", "8n", now);
                } else if (type === 'gameOver' && synthGameOver) { synthGameOver.triggerAttackRelease("G3", "8n", now); synthGameOver.triggerAttackRelease("E3", "8n", now + 0.15); synthGameOver.triggerAttackRelease("C3", "4n", now + 0.3);
                } else if (type === 'startGame' && synthStartGame) { synthStartGame.triggerAttackRelease("C4", "16n", now); synthStartGame.triggerAttackRelease("E4", "16n", now + 0.1); synthStartGame.triggerAttackRelease("G4", "8n", now + 0.2); 
                } else if (type === 'win' && synthWin) {
                    const tempo = 0.12;
                    synthWin.triggerAttackRelease("G4", "16n", now);
                    synthWin.triggerAttackRelease("G4", "16n", now + tempo * 1);
                    synthWin.triggerAttackRelease("C5", "16n", now + tempo * 2);
                    synthWin.triggerAttackRelease("E5", "8n", now + tempo * 3);
                    synthWin.triggerAttackRelease("C5", "16n", now + tempo * 5);
                    synthWin.triggerAttackRelease("G5", "4n", now + tempo * 6);
                } else if (type === 'coinAdd' && synthCoinNoise && synthCoinChime) {
                    const duration = typeof param === 'number' ? param : 1;
                    synthCoinNoise.triggerAttackRelease(duration, now);
                    synthCoinChime.triggerAttackRelease("C6", "16n", now + Math.max(0, duration - 0.1));
                } else if (type === 'modeSwitch' && synthModeSwitch) {
                    synthModeSwitch.triggerAttackRelease('C5', '16n', now);
                } else if (type === 'modeSelect' && synthModeSelect) {
                    synthModeSelect.triggerAttackRelease('G4', '16n', now);
                    synthModeSelect.triggerAttackRelease('C5', '16n', now + 0.1);
                }
            } catch (error) { console.error("Error al reproducir sonido con Tone.js:", error); }
        }
        
        function updateMusicVolume() {
            const sliderValue = parseInt(musicVolumeSlider.value);
            if (musicVolumeValue) {
                musicVolumeValue.textContent = sliderValue;
            }
            // For HTML5 Audio, volume is 0.0 to 1.0
            const actualVolume = (sliderValue / 100) * MAX_ACTUAL_SLIDER_MAPPED_VOLUME;
            if (generalBackgroundMusic) {
                generalBackgroundMusic.volume = actualVolume;
            }
            if (inGameBackgroundMusic) {
                inGameBackgroundMusic.volume = actualVolume;
            }
            saveGameSettings();
        }

        function updateSfxVolume() {
            const sliderValue = parseInt(sfxVolumeSlider.value);
            if (sfxVolumeValue) {
                sfxVolumeValue.textContent = sliderValue;
            }
            if (sfxGain) {
                sfxGain.gain.value = sliderValue / 100;
            }
            saveGameSettings();
        }

        musicVolumeSlider.addEventListener('input', updateMusicVolume);
        sfxVolumeSlider.addEventListener('input', updateSfxVolume);

        audioToggleSelector.addEventListener('change', async function() {
            const audioSetting = this.value;
            isMusicEnabled = (audioSetting === 'all' || audioSetting === 'music_only');
            areSfxEnabled = (audioSetting === 'all' || audioSetting === 'sfx_only');

            musicVolumeSlider.disabled = (audioSetting === 'off' || audioSetting === 'sfx_only');
            sfxVolumeSlider.disabled = (audioSetting === 'off' || audioSetting === 'music_only');
            if (isMusicEnabled && !gameIntervalId) {
                musicVolumeControlGroup.classList.add("interactive-mode");
            } else {
                musicVolumeControlGroup.classList.remove("interactive-mode");
            }
            if (areSfxEnabled && !gameIntervalId) {
                sfxVolumeControlGroup.classList.add("interactive-mode");
            } else {
                sfxVolumeControlGroup.classList.remove("interactive-mode");
            }

            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            // initializeToneSynths() is called by ensureAudioContextRunning if needed
            
            if (!audioContextStarted && (isMusicEnabled || areSfxEnabled)) { // If context still not started
                console.warn("Audio context could not be unlocked by user interaction via toggle.");
            }


            if (isMusicEnabled) { // Using HTML5 Audio
                updateMusicVolume();
                updateSfxVolume();
                updateSfxVolume();
                if (gameIntervalId) { // Game is active
                    if (generalBackgroundMusic) generalBackgroundMusic.pause();
                    if (inGameBackgroundMusic && inGameBackgroundMusic.paused) {
                         inGameBackgroundMusic.play().catch(e => console.error("Error al reproducir música de juego (toggle ON):", e));
                    }
                } else { // Menu or game over
                    if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
                    if (generalBackgroundMusic && generalBackgroundMusic.paused) {
                         generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (toggle ON):", e));
                    }
                }
            } else {
                if (generalBackgroundMusic) generalBackgroundMusic.pause();
                if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
            }
            if (!isMusicEnabled) updateSfxVolume();
            saveGameSettings();
        });


        skinSelectors.forEach(sel => sel.addEventListener('change', function() {
            skinSelectors.forEach(s => { if (s !== this) s.value = this.value; });
            applySkin(this.value);
            saveGameSettings();
            updateProfileSelectedItems();
        }));

        foodSelectors.forEach(sel => sel.addEventListener('change', function() {
            foodSelectors.forEach(f => { if (f !== this) f.value = this.value; });
            applyFood(this.value);
            saveGameSettings();
            updateProfileSelectedItems();
        }));

        sceneSelectors.forEach(sel => sel.addEventListener('change', function() {
            sceneSelectors.forEach(f => { if (f !== this) f.value = this.value; });
            applyScene(this.value);
            saveGameSettings();
            updateProfileSelectedItems();
        }));

        playerNameSelectors.forEach(sel => sel.addEventListener('change', function() {
            const previous = currentPlayerName;
            const keepDifficulty = difficultySelector.value;
            saveGameSettings(); // Save previous profile
            currentPlayerName = this.value;
            if (!playerProfiles[currentPlayerName]) {
                playerProfiles[currentPlayerName] = createDefaultProfile(currentPlayerName);
            }
            playerNameSelectors.forEach(s => { if (s !== this) s.value = this.value; });
            applyProfile(playerProfiles[currentPlayerName]);
            if (gameMode === 'classification') {
                difficultySelector.value = keepDifficulty;
                classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(keepDifficulty);
            }
            const savedCoins = parseInt(localStorage.getItem('snakeGameCoins'), 10);
            totalCoins = Number.isFinite(savedCoins) && savedCoins >= 0 ? savedCoins : 0;

            if (!gameIntervalId) {
                if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                } else if (gameMode === 'levels') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    drawStarProgress();
                }
            }

            updateCoinDisplay();
            updateGemDisplay();
            updateGameModeUI();
            requestAnimationFrame(draw);
            saveGameSettings();
        }));

        function addNewPlayerFromInput() {
            const newName = newPlayerNameInput.value.trim().slice(0, 10);
            if (newName) {
                if (!playerProfiles[newName]) {
                    playerProfiles[newName] = createDefaultProfile(newName);
                }
                updatePlayerNameSelectors(newName);
                currentPlayerName = newName;
                newPlayerNameInput.value = '';
                const keepDifficulty = difficultySelector.value;
                applyProfile(playerProfiles[currentPlayerName]);
                if (gameMode === 'classification') {
                    difficultySelector.value = keepDifficulty;
                    classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(keepDifficulty);
                }
                updateCoinDisplay();
                updateGemDisplay();
                updateGameModeUI();
                requestAnimationFrame(draw);
                saveGameSettings();
            }
        }

        if (confirmAddPlayerButton) {
            confirmAddPlayerButton.addEventListener('click', addNewPlayerFromInput);
        }
        if (newPlayerNameInput) {
            newPlayerNameInput.addEventListener('keyup', function(e) { if (e.key === 'Enter') addNewPlayerFromInput(); });
            newPlayerNameInput.addEventListener('blur', addNewPlayerFromInput);
            newPlayerNameInput.addEventListener('input', function() {
                if (this.value.length > 10) this.value = this.value.slice(0, 10);
            });
        }
        if (deletePlayerNameButton) {
            deletePlayerNameButton.addEventListener('click', function() {
                if (Object.keys(playerProfiles).length <= 1) return;
                const nameToDelete = getSelectedPlayerName();
                if (nameToDelete === 'Snake') return;
                openDeleteConfirm(nameToDelete);
            });
        }

        difficultySelector.addEventListener('change', function() {
            const oldIndex = classificationDifficultyIndex;
            difficulty = this.value;
            classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(this.value);
            if (!gameIntervalId) {
                const cfg = (gameMode === 'freeMode') ? freeModeSettings : DIFFICULTY_SETTINGS[difficulty];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
            }
            // updateTargetScoreDisplay(); // No target score in free mode based on difficulty
            if (gameMode === 'freeMode') { // Update high score display if difficulty changes in free mode
                displayHighScoreInPanel();
            } else if (gameMode === 'classification') {
                displayClassificationHighScoreInPanel();
                populateClassificationRanking();
                // También actualizamos la dificultad mostrada en pantalla
                if (progressPanelLeftValue) {
                    progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficulty] || difficulty;
                }
            }
            if (gameMode === 'classification' &&
                screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                classificationTransitionFrom = oldIndex;
                if (classificationDifficultyIndex === oldIndex) {
                    classificationTransitionDir = 0;
                    classificationTransitionStart = null;
                } else {
                    classificationTransitionDir = (classificationDifficultyIndex > oldIndex) ? 1 : -1;
                    classificationTransitionStart = performance.now();
                }
                requestAnimationFrame(draw);
            }
            saveGameSettings();
        });

        worldsSelector.addEventListener('change', function() {
            if (gameMode === 'levels') {
                const newSelectedWorld = parseInt(this.value);
                if (newSelectedWorld > maxUnlockedWorld) {
                    this.value = currentWorld.toString(); // Revert if trying to select a locked world
                    return;
                }

                currentWorld = newSelectedWorld;
                currentLevelInWorld = worldCurrentLevels[newSelectedWorld - 1] || 1;

                // Update display variables to reflect the new selection
                displayWorld = currentWorld;
                displayLevelInWorld = currentLevelInWorld;
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TOTAL_WORLDS * LEVELS_PER_WORLD) {
                    displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1].targetScore;
                } else {
                    displayTargetScore = 0;
                }
                updateTargetScoreDisplay(); // Update UI for target score
                if (progressPanelLeftValue) { // Update UI for progress panel
                    progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                }
                drawStarProgress(); // Update stars for the newly selected world


                if (!gameIntervalId) {
                    const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                    snakeSpeed = levelCfg.speed;
                    initialSnakeLength = levelCfg.initialLength;
                }
                
                screenState.showCoverForWorld = currentWorld;
                screenState.gameActuallyStarted = false; 
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;

                saveGameSettings(); 
                
                closeSettingsPanel(); 

                requestAnimationFrame(draw);
            }
        });


        

        function handleStartClick() {
            if (showModeSelect) {
                if (MODE_SELECT_ORDER[modeSelectIndex] === 'intro') return;
                introOptionAvailable = false; // remove intro option after selecting a mode
                if (areSfxEnabled) playSound('modeSelect');
                const selectedMode = MODE_SELECT_ORDER[modeSelectIndex];
                gameMode = selectedMode;
                showModeSelect = false;
                modeTransitionStart = null;

                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
                screenState.mazeResultType = '';
                screenState.gameActuallyStarted = false;

                if (selectedMode === 'levels') {
                    screenState.showCoverForWorld = currentWorld;
                } else if (selectedMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    openFreeSettingsPanel();
                } else if (selectedMode === 'classification') {
                    screenState.showClassificationCover = true;
                    classificationDifficultyIndex = 0;
                    const initDiff = CLASSIFICATION_DIFFICULTY_ORDER[classificationDifficultyIndex];
                    difficultySelector.value = initDiff;
                    difficultySelector.dispatchEvent(new Event('change'));
                } else {
                    screenState.showMazeCover = true;
                }
                updateGameModeUI();
                if (selectedMode === 'freeMode') {
                    // Delay help display so the free settings panel finishes opening
                    setTimeout(() => maybeShowInitialHelpForMode(selectedMode), 300);
                } else {
                    maybeShowInitialHelpForMode(selectedMode);
                }
                draw();
                if (selectedMode === 'freeMode') {
                    setTimeout(updateMainButtonStates, 0);
                } else {
                    updateMainButtonStates();
                }
            } else {
                startGame(false);
            }
        }

        function handleBackButtonClick() {
            if (showModeSelect) {
                // Return to splash screen
                showModeSelect = false;
                introOptionAvailable = true;
                modeTransitionStart = null;
                gameMode = '';
                if (gameContainer) gameContainer.classList.add('hidden');
                if (splashScreen) splashScreen.classList.remove('hidden');
            } else {
                // Return to mode selection
                showModeSelect = true;
                modeTransitionStart = null;
                introOptionAvailable = true;
                modeSelectIndex = 0;
                if (gameMode === 'classification' || gameMode === 'freeMode') {
                    clearGameTimersAndMusic();
                    gameTimeElapsed = 0;
                }
                gameMode = '';

                // Cancel any in-progress transitions
                worldTransitionStart = null;
                classificationTransitionStart = null;
                mazeTransitionStart = null;
                worldTransitionDir = 0;
                classificationTransitionDir = 0;
                mazeTransitionDir = 0;

                // Hide all cover images
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showFreeModeEnd = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
                screenState.mazeResultType = '';
                screenState.gameActuallyStarted = false;

                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
                draw();
            }
            updateGameModeUI();
            updateMainButtonStates();
        }

        function displayClassificationHighScoreInPanel() {
            const selectedDifficulty = difficultySelector.value;
            const highScores = loadClassificationHighScores(selectedDifficulty);
            const hsSkinValueDisplay = document.getElementById("hs-skin-value");

            if (highScores.length > 0) {
                hsScoreValue.textContent = highScores[0].score;
                if (hsSkinValueDisplay) {
                    const displayName = highScores[0].playerName || SKIN_DISPLAY_NAMES[highScores[0].skin] || highScores[0].skin || '-';
                    hsSkinValueDisplay.textContent = displayName;
                }
            } else {
                hsScoreValue.textContent = "-";
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = "-";
                }
            }
        }

        function populateClassificationRanking() {
            if (!classificationRankingList) return;
            const selectedDifficulty = difficultySelector.value;
            const scores = loadClassificationHighScores(selectedDifficulty);
            classificationRankingList.innerHTML = '';

            for (let i = 0; i < MAX_HIGH_SCORES; i++) {
                const entry = scores[i];
                const row = document.createElement('tr');
                const playerDisplay = entry ? (entry.playerName || SKIN_DISPLAY_NAMES[entry.skin] || entry.skin || '-') : '---';
                const scoreVal = entry ? entry.score : '---';
                const timeVal = entry ? formatTime(entry.time) : '---';
                row.innerHTML = `<td>${i + 1}.</td><td>${scoreVal}</td><td>${timeVal}</td><td>${playerDisplay}</td>`;
                classificationRankingList.appendChild(row);
            }
        }


        document.addEventListener("keydown", (e) => {
            const isSettingsOpen = !settingsPanel.classList.contains("settings-panel-hidden");
            const isInfoOpen = !infoPanel.classList.contains("info-panel-hidden");
            const isSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden");

            if (!isSettingsOpen && !isInfoOpen && !isSpecificInfoOpen) {
                const key = e.key.toLowerCase();
                if (screenState.showCoverForWorld && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                    if (key === 'arrowleft' || key === 'a') { startWorldTransition(-1); e.preventDefault(); return; }
                    if (key === 'arrowright' || key === 'd') { startWorldTransition(1); e.preventDefault(); return; }
                    if (key === 'enter') { if (displayWorld <= maxUnlockedWorld) startGame(false); e.preventDefault(); return; }
                } else if (screenState.showMazeCover && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                    if (key === 'arrowleft' || key === 'a') { startMazeTransition(-1); e.preventDefault(); return; }
                    if (key === 'arrowright' || key === 'd') { startMazeTransition(1); e.preventDefault(); return; }
                    if (key === 'enter') { if (displayMazeLevel <= currentMazeLevel) startGame(false); e.preventDefault(); return; }
                }
                if (gameOver && e.key !== "Enter" && gameIntervalId === null) return;
                let newDirectionCmd = null; // Use newDirectionCmd to align with function parameter
                switch (key) {
                    case "arrowup": case "w": newDirectionCmd = "up"; break;
                    case "arrowdown": case "s": newDirectionCmd = "down"; break;
                    case "arrowleft": case "a": newDirectionCmd = "left"; break;
                    case "arrowright": case "d": newDirectionCmd = "right"; break;
                    case "enter": if (gameOver || !gameIntervalId) { startGame(false); } break;
                }
                if (newDirectionCmd) { changeDirection(newDirectionCmd); }
                if (["arrowup", "arrowdown", "arrowleft", "arrowright", "w", "a", "s", "d"].includes(key)) { e.preventDefault(); }
            } else if (isSpecificInfoOpen) {
                 if (e.key === "Escape") { closeSpecificInfoPanel(); }
            } else if (isSettingsOpen) {
                 if (e.key === "Escape") { closeSettingsPanel(); }
            } else if (isInfoOpen) {
                 if (e.key === "Escape") { closeInfoPanel(); }
            }
        });

        // D-Pad Button Press Feedback
        [upButton, downButton, leftButton, rightButton].forEach(button => {
            button.addEventListener("mousedown", () => {
                if (gameIntervalId) button.classList.add("d-pad-button-pressed");
            });
            button.addEventListener("mouseup", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("mouseleave", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("touchstart", (e) => {
                e.preventDefault();
                if (gameIntervalId) button.classList.add("d-pad-button-pressed");
                changeDirection(button.id.replace('-button', ''));
            });
            button.addEventListener("touchend", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("touchcancel", () => button.classList.remove("d-pad-button-pressed"));
        });

        // Icon Button Press Feedback
        function addIconPressEvents(btn, icon) {
            if (!btn || !icon) return;

            const shouldIgnore = () => btn.disabled || btn.classList.contains('disabled');
            const addPressed = () => {
                if (!shouldIgnore()) icon.classList.add('icon-button-pressed');
            };
            const removePressed = () => icon.classList.remove('icon-button-pressed');

            btn.addEventListener('mousedown', addPressed);
            btn.addEventListener('mouseup', removePressed);
            btn.addEventListener('mouseleave', removePressed);
            btn.addEventListener('touchstart', addPressed);
            btn.addEventListener('touchend', removePressed);
            btn.addEventListener('touchcancel', removePressed);
        }

        function saveUnlockedFoods() {
            localStorage.setItem('snakeGameUnlockedFoods', JSON.stringify(unlockedFoods));
        }

        function loadUnlockedFoods() {
            try {
                const data = JSON.parse(localStorage.getItem('snakeGameUnlockedFoods') || '{}');
                unlockedFoods = { apple: true, ...data };
            } catch (e) {
                unlockedFoods = { apple: true };
            }
        }

        function saveUnlockedSkins() {
            localStorage.setItem('snakeGameUnlockedSkins', JSON.stringify(unlockedSkins));
        }

        function loadUnlockedSkins() {
            try {
                const data = JSON.parse(localStorage.getItem('snakeGameUnlockedSkins') || '{}');
                unlockedSkins = { snake: true, ...data };
            } catch (e) {
                unlockedSkins = { snake: true };
            }
        }

        function saveUnlockedScenes() {
            localStorage.setItem('snakeGameUnlockedScenes', JSON.stringify(unlockedScenes));
        }

        function loadUnlockedScenes() {
            try {
                const data = JSON.parse(localStorage.getItem('snakeGameUnlockedScenes') || '{}');
                unlockedScenes = { classic: true, ...data };
            } catch (e) {
                unlockedScenes = { classic: true };
            }
        }

        function saveGems() {
            localStorage.setItem('snakeGameGems', totalGems.toString());
        }

        function updateFoodSelectorAvailability() {
            if (!foodSelectors.length) return;
            foodSelectors.forEach(sel => {
                Array.from(sel.options).forEach(opt => {
                    opt.disabled = !unlockedFoods[opt.value];
                });
                if (!unlockedFoods[sel.value]) {
                    sel.value = 'apple';
                }
            });
            const current = foodSelectors[0].value;
            if (!unlockedFoods[current]) {
                foodSelectors.forEach(sel => sel.value = 'apple');
                applyFood('apple');
            }
        }

        function updateSkinSelectorAvailability() {
            if (!skinSelectors.length) return;
            skinSelectors.forEach(sel => {
                Array.from(sel.options).forEach(opt => {
                    opt.disabled = !unlockedSkins[opt.value];
                });
                if (!unlockedSkins[sel.value]) {
                    sel.value = 'snake';
                }
            });
            const current = skinSelectors[0].value;
            if (!unlockedSkins[current]) {
                skinSelectors.forEach(sel => sel.value = 'snake');
                applySkin('snake');
            }
        }

        function updateSceneSelectorAvailability() {
            if (!sceneSelectors.length) return;
            sceneSelectors.forEach(sel => {
                Array.from(sel.options).forEach(opt => {
                    opt.disabled = !unlockedScenes[opt.value];
                });
                if (!unlockedScenes[sel.value]) {
                    sel.value = 'classic';
                }
            });
            const current = sceneSelectors[0].value;
            if (!unlockedScenes[current]) {
                sceneSelectors.forEach(sel => sel.value = 'classic');
                applyScene('classic');
            }
        }

        function updateProfileSelectedItems() {
            if (profileSelectedSkin) {
                profileSelectedSkin.innerHTML = '';
                profileSelectedSkin.className = 'store-item purchased profile-clickable';
                const img = document.createElement('img');
                img.className = 'store-item-img';
                img.src = SKINS[getSelectedSkin()]?.snakeHeadAsset?.upDown?.src || '';
                profileSelectedSkin.appendChild(img);
            }
            if (profileSelectedFood) {
                profileSelectedFood.innerHTML = '';
                profileSelectedFood.className = 'store-item purchased profile-clickable';
                const img = document.createElement('img');
                img.className = 'store-item-img';
                img.src = FOODS[getSelectedFood()]?.asset?.src || '';
                profileSelectedFood.appendChild(img);
            }
            if (profileSelectedScene) {
                profileSelectedScene.innerHTML = '';
                profileSelectedScene.className = 'store-item purchased profile-clickable scene-item';
                const img = document.createElement('img');
                img.className = 'store-item-img scene-img-full';
                img.src = SCENES[getSelectedScene()]?.icon || '';
                profileSelectedScene.appendChild(img);
            }
        }

        function populateProfileFoodTab() {
            if (!profileFoodUnlocked || !profileFoodLocked) return;
            profileFoodUnlocked.innerHTML = '';
            profileFoodLocked.innerHTML = '';
            FOOD_ORDER.forEach(key => {
                const item = document.createElement('div');
                item.className = 'store-item';
                const img = document.createElement('img');
                img.className = 'store-item-img';
                img.src = FOODS[key]?.asset?.src || '';
                item.appendChild(img);
                if (unlockedFoods[key]) {
                    item.classList.add('purchased', 'profile-clickable');
                    item.addEventListener('click', () => openSelectConfirm('food', key, 'select'));
                } else {
                    item.classList.add('locked');
                    item.addEventListener('click', () => openSelectConfirm('food', key, 'store'));
                }
                addIconPressEvents(item, item);
                (unlockedFoods[key] ? profileFoodUnlocked : profileFoodLocked).appendChild(item);
            });
        }

        function populateProfileSkinTab() {
            if (!profileSkinUnlocked || !profileSkinLocked) return;
            profileSkinUnlocked.innerHTML = '';
            profileSkinLocked.innerHTML = '';
            SKIN_ORDER.forEach(key => {
                const item = document.createElement('div');
                item.className = 'store-item';
                const img = document.createElement('img');
                img.className = 'store-item-img';
                img.src = SKINS[key]?.snakeHeadAsset?.upDown?.src || '';
                item.appendChild(img);
                if (unlockedSkins[key]) {
                    item.classList.add('purchased', 'profile-clickable');
                    item.addEventListener('click', () => openSelectConfirm('skin', key, 'select'));
                } else {
                    item.classList.add('locked');
                    item.addEventListener('click', () => openSelectConfirm('skin', key, 'store'));
                }
                addIconPressEvents(item, item);
                (unlockedSkins[key] ? profileSkinUnlocked : profileSkinLocked).appendChild(item);
            });
        }

        function populateProfileSceneTab() {
            if (!profileSceneUnlocked || !profileSceneLocked) return;
            profileSceneUnlocked.innerHTML = '';
            profileSceneLocked.innerHTML = '';
            SCENE_ORDER.forEach(key => {
                const item = document.createElement('div');
                item.className = 'store-item scene-item';
                const img = document.createElement('img');
                img.className = 'store-item-img scene-img-full';
                img.src = SCENES[key]?.icon || '';
                item.appendChild(img);
                if (unlockedScenes[key]) {
                    item.classList.add('purchased', 'profile-clickable');
                    item.addEventListener('click', () => openSelectConfirm('scene', key, 'select'));
                } else {
                    item.classList.add('locked');
                    item.addEventListener('click', () => openSelectConfirm('scene', key, 'store'));
                }
                addIconPressEvents(item, item);
                (unlockedScenes[key] ? profileSceneUnlocked : profileSceneLocked).appendChild(item);
            });
        }

        let selectInfo = null;
        function openSelectConfirm(type, key, action) {
            selectInfo = { type, key, action };
            if (selectConfirmationText) {
                let name;
                if (type === 'food') name = FOOD_DISPLAY_NAMES[key];
                else if (type === 'skin') name = SKIN_DISPLAY_NAMES[key];
                else name = SCENE_DISPLAY_NAMES[key];
                selectConfirmationText.textContent = action === 'select' ? `¿Usar ${name}?` : `¿Ver ${name} en la tienda?`;
            }
            selectConfirmationPanel.classList.add('centered-panel');
            togglePanel(selectConfirmationPanel, selectConfirmationPanel.querySelector('.panel-content'), true);
            if (modalOverlay) modalOverlay.classList.remove('hidden');
        }

        function confirmSelect() {
            if (!selectInfo) { closeSelectConfirm(); return; }
            if (selectInfo.action === 'select') {
                if (selectInfo.type === 'food') {
                    foodSelectors.forEach(sel => sel.value = selectInfo.key);
                    applyFood(selectInfo.key);
                } else if (selectInfo.type === 'skin') {
                    skinSelectors.forEach(sel => sel.value = selectInfo.key);
                    applySkin(selectInfo.key);
                } else {
                    sceneSelectors.forEach(sel => sel.value = selectInfo.key);
                    applyScene(selectInfo.key);
                }
                saveGameSettings();
                updateProfileSelectedItems();
                switchProfileTab('general');
            } else if (selectInfo.action === 'store') {
                let targetTab = 'general';
                if (selectInfo.type === 'food') targetTab = 'comida';
                else if (selectInfo.type === 'skin') targetTab = 'disfraces';
                else targetTab = 'escenarios';
                closeSelectConfirm();
                closeProfileMenu();
                // wait for the profile panel closing animation to finish before
                // showing the store, otherwise the store panel may not appear
                setTimeout(() => openStoreMenuWithTab(targetTab), 310);
                return;
            }
            closeSelectConfirm();
        }

        function closeSelectConfirm() {
            togglePanel(selectConfirmationPanel, selectConfirmationPanel.querySelector('.panel-content'), false);
            selectConfirmationPanel.classList.remove('centered-panel');
            if (modalOverlay) modalOverlay.classList.add('hidden');
            selectInfo = null;
        }

        function openStoreMenuWithTab(tab) {
            openStoreMenu();
            storeTab = tab;
            storeTabButtons.forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`#store-tab-${tab}`);
            if (btn) btn.classList.add('active');
            populateStoreItems();
        }

        addIconPressEvents(configButton, configButtonIcon);
        addIconPressEvents(backButton, backButtonIcon);
        addIconPressEvents(restartMazeButton, restartMazeButtonIcon);
        addIconPressEvents(modeLeftButton, modeLeftButtonIcon);
        addIconPressEvents(modeRightButton, modeRightButtonIcon);
        addIconPressEvents(startButton, startButton);
        addIconPressEvents(applyFreeSettingsBottomButton, applyFreeSettingsBottomButton);
        addIconPressEvents(resetDataButton, resetDataButton);
        addIconPressEvents(confirmResetYesButton, confirmResetYesButton);
        addIconPressEvents(confirmResetNoButton, confirmResetNoButton);
        addIconPressEvents(confirmPurchaseYesButton, confirmPurchaseYesButton);
        addIconPressEvents(confirmPurchaseNoButton, confirmPurchaseNoButton);
        addIconPressEvents(confirmDeleteYesButton, confirmDeleteYesButton);
        addIconPressEvents(confirmDeleteNoButton, confirmDeleteNoButton);
        addIconPressEvents(confirmSelectYesButton, confirmSelectYesButton);
        addIconPressEvents(confirmSelectNoButton, confirmSelectNoButton);
        addIconPressEvents(profileSelectedSkin, profileSelectedSkin);
        addIconPressEvents(profileSelectedFood, profileSelectedFood);
        addIconPressEvents(profileSelectedScene, profileSelectedScene);
        addIconPressEvents(closeSettingsButton, closeSettingsButton);
        addIconPressEvents(closeFreeSettingsButton, closeFreeSettingsButton);
        addIconPressEvents(closeInfoButton, closeInfoButton);
        addIconPressEvents(closeSpecificInfoButton, closeSpecificInfoButton);
        addIconPressEvents(closeConfigMenuButton, closeConfigMenuButton);
        addIconPressEvents(closeGenericMenuButton, closeGenericMenuButton);
        addIconPressEvents(closeProfilePanelButton, closeProfilePanelButton);
        addIconPressEvents(closeStorePanelButton, closeStorePanelButton);
        addIconPressEvents(closeOutOfLivesPanelButton, closeOutOfLivesPanelButton);
        addIconPressEvents(getLivesStoreButton, getLivesStoreButton);
        addIconPressEvents(getLivesBonusesButton, getLivesBonusesButton);

        // Original click listeners for D-Pad 
        upButton.addEventListener("click", () => changeDirection("up"));
        downButton.addEventListener("click", () => changeDirection("down"));
        leftButton.addEventListener("click", () => changeDirection("left"));
        rightButton.addEventListener("click", () => changeDirection("right"));

        function startModeTransition(dir) {
            if (modeTransitionStart !== null) return;
            modeTransitionDir = dir;
            modeTransitionFrom = modeSelectIndex;

            do {
                modeSelectIndex = (modeSelectIndex + dir + MODE_SELECT_ORDER.length) % MODE_SELECT_ORDER.length;
                if (introOptionAvailable && MODE_SELECT_ORDER[modeSelectIndex] !== 'intro') {
                    introOptionAvailable = false; // once user moves away from intro, remove it
                }
            } while (!introOptionAvailable && MODE_SELECT_ORDER[modeSelectIndex] === 'intro');

            modeTransitionStart = performance.now();
            draw();
        }

        function startClassificationTransition(dir) {
            if (classificationTransitionStart !== null) return;
            classificationTransitionDir = dir;
            classificationTransitionFrom = classificationDifficultyIndex;
            classificationDifficultyIndex = (classificationDifficultyIndex + dir + CLASSIFICATION_DIFFICULTY_ORDER.length) % CLASSIFICATION_DIFFICULTY_ORDER.length;
            const newDiff = CLASSIFICATION_DIFFICULTY_ORDER[classificationDifficultyIndex];
            difficultySelector.value = newDiff;
            difficultySelector.dispatchEvent(new Event('change'));
            updateGameModeUI();
            saveGameSettings();
            classificationTransitionStart = performance.now();
            if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                requestAnimationFrame(draw);
            }
        }
        function startWorldTransition(dir) {
            if (worldTransitionStart !== null) return;
            worldTransitionDir = dir;
            worldTransitionFrom = displayWorld;
            displayWorld = ((displayWorld - 1 + dir + TOTAL_WORLDS) % TOTAL_WORLDS) + 1;
            if (displayWorld <= maxUnlockedWorld) {
                currentWorld = displayWorld;
                currentLevelInWorld = worldCurrentLevels[currentWorld - 1] || 1;
                const absoluteIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
                displayLevelInWorld = currentLevelInWorld;
                displayTargetScore = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1].targetScore || 0;
                if (!gameIntervalId) {
                    const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                    snakeSpeed = cfg.speed;
                    initialSnakeLength = cfg.initialLength;
                }
                saveGameSettings();
            } else {
                // Al mostrar la portada de un mundo bloqueado, aseguramos que el
                // nivel visualizado sea siempre 1 y se muestre su puntuación objetivo
                displayLevelInWorld = 1;
                const absoluteIndex = (displayWorld - 1) * LEVELS_PER_WORLD;
                displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][0].targetScore || 0;
            }
            screenState.showCoverForWorld = displayWorld;
            screenState.showWorldCompleteCover = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showFreeModeCover = false;
            updateGameModeUI();
            worldTransitionStart = performance.now();
            if (!screenState.gameActuallyStarted) {
                requestAnimationFrame(draw);
            }
        }

        function startMazeTransition(dir) {
            if (mazeTransitionStart !== null) return;
            mazeTransitionDir = dir;
            mazeTransitionFrom = displayMazeLevel;
            displayMazeLevel = ((displayMazeLevel - 1 + dir + MAZE_LEVEL_COUNT) % MAZE_LEVEL_COUNT) + 1;

            mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
            mazeStarsEarned = mazePreviousStars;
            if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
            } else {
                displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
            }
            if (progressPanelLeftValue) {
                progressPanelLeftValue.textContent = displayMazeLevel;
            }
            drawStarProgress();

            screenState.showMazeCover = true;
            screenState.mazeResultType = '';
            updateGameModeUI();
            saveGameSettings();
            mazeTransitionStart = performance.now();
            if (!screenState.gameActuallyStarted) {
                requestAnimationFrame(draw);
            }
        }


        modeLeftButton.addEventListener("click", () => {
            if (showModeSelect) {
                startModeTransition(-1);
            } else if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                startClassificationTransition(-1);
            } else if (screenState.showCoverForWorld && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                startWorldTransition(-1);
            } else if (screenState.showMazeCover && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                startMazeTransition(-1);
            }
            if (areSfxEnabled) playSound('modeSwitch');
        });
        modeRightButton.addEventListener("click", () => {
            if (showModeSelect) {
                startModeTransition(1);
            } else if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                startClassificationTransition(1);
            } else if (screenState.showCoverForWorld && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                startWorldTransition(1);
            } else if (screenState.showMazeCover && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                startMazeTransition(1);
            }
            if (areSfxEnabled) playSound('modeSwitch');
        });

        startButton.addEventListener("click", handleStartClick);
        restartMazeButton.addEventListener("click", () => {
            if (areSfxEnabled) playSound('modeSwitch');
            startGame(true);
        });
        
        window.addEventListener('resize', resizeGameElements);
        window.addEventListener('beforeunload', saveGameSettings);
        window.addEventListener('pagehide', saveGameSettings);
        
        function saveGameSettings() {
            const profile = playerProfiles[currentPlayerName] || createDefaultProfile(currentPlayerName);
            profile.name = currentPlayerName;
            profile.difficulty = difficultySelector.value;
            profile.skin = getSelectedSkin();
            profile.food = getSelectedFood();
            profile.scene = getSelectedScene();
            profile.audioGeneral = audioToggleSelector.value;
            profile.musicVolume = musicVolumeSlider.value;
            profile.sfxVolume = sfxVolumeSlider.value;
            profile.gameMode = gameMode;
            profile.currentWorld = currentWorld;
            profile.currentLevelInWorld = currentLevelInWorld;
            profile.maxUnlockedWorld = maxUnlockedWorld;
            profile.levelsProgress = levelsProgress;
            profile.worldCurrentLevels = worldCurrentLevels;
            profile.currentMazeLevel = currentMazeLevel;
            profile.mazeLevelStars = mazeLevelStars;
            profile.freeModeSettings = freeModeSettings;
            playerProfiles[currentPlayerName] = profile;
            savePlayerProfiles();
            localStorage.setItem('snakeGameCoins', totalCoins.toString());
            localStorage.setItem('snakeGameGems', totalGems.toString());
            saveUnlockedSkins();
            saveUnlockedFoods();
            saveUnlockedScenes();
            localStorage.setItem('snakePlayerNames', JSON.stringify(Object.keys(playerProfiles)));
            localStorage.setItem('snakeGamePlayerName', currentPlayerName);
            console.log("Configuraciones guardadas en localStorage.");
        }

        function loadGameSettings() {
            loadPlayerProfiles();
            updatePlayerNameSelectors();
            const savedPlayerName = localStorage.getItem('snakeGamePlayerName');
            if (savedPlayerName && playerProfiles[savedPlayerName]) {
                currentPlayerName = savedPlayerName;
            } else {
                currentPlayerName = Object.keys(playerProfiles)[0];
            }
            const savedCoins = parseInt(localStorage.getItem('snakeGameCoins'), 10);
            totalCoins = Number.isFinite(savedCoins) && savedCoins >= 0 ? savedCoins : 0;
            const savedGems = parseInt(localStorage.getItem('snakeGameGems'), 10);
            totalGems = Number.isFinite(savedGems) && savedGems >= 0 ? savedGems : 0;
            loadUnlockedFoods(); // Load foods before applying profile
            loadUnlockedSkins();
            loadUnlockedScenes();
            updateFoodSelectorOptions(playerProfiles[currentPlayerName]?.food || 'apple');
            updateSceneSelectorOptions(playerProfiles[currentPlayerName]?.scene || 'classic');
            updatePlayerNameSelectors(currentPlayerName);
            applyProfile(playerProfiles[currentPlayerName]);
            updateSfxVolume();
            updateFoodSelectorAvailability();
            updateSkinSelectorAvailability();
            updateSceneSelectorAvailability();
            populateStoreItems();

            // Always start with no mode selected
            gameMode = '';

            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            modeSelectIndex = MODE_SELECT_ORDER.indexOf(gameMode);

            if (gameMode === 'levels') {
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TOTAL_WORLDS * LEVELS_PER_WORLD) {
                    displayTargetScore = LEVEL_SETTINGS[displayWorld - 1][displayLevelInWorld - 1].targetScore;
                } else { // Default if out of bounds (e.g., after completing all levels)
                    displayTargetScore = LEVEL_SETTINGS[TOTAL_WORLDS - 1][LEVELS_PER_WORLD -1].targetScore;
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            } else {
                displayTargetScore = 0; // No target score for free mode
            }


            difficulty = difficultySelector.value;
            const cfg = DIFFICULTY_SETTINGS[difficulty];
            snakeSpeed = cfg.speed;
            initialSnakeLength = cfg.initialLength;
            currentSkin = getSelectedSkin();
            currentFood = getSelectedFood();
            currentPlayerName = getSelectedPlayerName();
            
            isMusicEnabled = (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'music_only');
            areSfxEnabled = (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'sfx_only');
            
            if(musicVolumeValue) musicVolumeValue.textContent = musicVolumeSlider.value; 

            console.log("Configuraciones cargadas de localStorage y aplicadas a selectores.");
            updateGameModeUI(); // This will use the newly set display variables
            updateCoinDisplay();
            updateGemDisplay();
        }


        async function initializeGameLogic() { 
            if (!canvasEl) { 
                console.error("Elemento Canvas no encontrado en initializeGameLogic.");
                return;
            }
            if (!ctx) { 
                 ctx = canvasEl.getContext("2d");
                 if (!ctx) {
                    console.error("Fallo al obtener el contexto 2D del canvas en initializeGameLogic.");
                    return; 
                 }
            }
            
            // HTML5 Audio objects are now created in window.onload
            // Volume is also applied there via updateMusicVolume()
            // Tone.js synths (except splash) are initialized via ensureAudioContextRunning -> initializeToneSynths

            if (typeof Audio !== 'undefined') {
                // Music playback logic based on current game state
                const isSettingsOpen = settingsPanel && !settingsPanel.classList.contains("settings-panel-hidden");
                const isInfoOpen = infoPanel && !infoPanel.classList.contains("info-panel-hidden");
                if (isMusicEnabled && !gameIntervalId && !gameOver && !isSettingsOpen && !isInfoOpen && !screenState.showCoverForWorld && !screenState.showWorldCompleteCover && !screenState.showLevelCompleteCover && !screenState.showDefeatCoverForWorld && !screenState.showFreeModeCover && !screenState.showClassificationCover && !screenState.showMazeCover && !screenState.mazeResultType) {
                    if (inGameBackgroundMusic && !inGameBackgroundMusic.paused) {
                        inGameBackgroundMusic.pause();
                    }
                    if (generalBackgroundMusic && generalBackgroundMusic.paused) {
                        generalBackgroundMusic.play().catch(e => console.warn("Reproducción automática de música general (initializeGameLogic) fallida:", e));
                    }
                } else if (!isMusicEnabled || screenState.showCoverForWorld || screenState.showWorldCompleteCover || screenState.showLevelCompleteCover || screenState.showDefeatCoverForWorld || screenState.showTimeoutCover || screenState.showFreeModeCover || screenState.showClassificationCover || screenState.showMazeCover || screenState.mazeResultType) { // Pause if music disabled or any cover shown
                    if (generalBackgroundMusic) generalBackgroundMusic.pause();
                    if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
                }
            }


            requestAnimationFrame(() => {
                resizeGameElements(); 
                draw();                 
                updateMainButtonStates(); 
            });

            applySkin(currentSkin); // Apply skin based on loaded settings
            applyFood(currentFood);
            applyScene(currentScene);

            // Reset screen states for a fresh start after splash
            screenState.gameActuallyStarted = false; 
            screenState.showWorldCompleteCover = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showFreeModeCover = false;
            screenState.showFreeModeEnd = false;
            screenState.showClassificationCover = false;

            // Set initial display state based on current gameMode
            // but ensure correct cover screen is shown
            if (gameMode === 'levels') {
                screenState.showCoverForWorld = currentWorld; // currentWorld from loaded settings
            } else if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = true;
                screenState.showFreeModeEnd = false;
                // Ensure gameOver is false if free mode cover is shown before first game
                if (snake.length === 0) gameOver = false;
            } else if (gameMode === 'classification') {
                screenState.showClassificationCover = true;
                // Ensure gameOver is false if free mode cover is shown before first game
                if (snake.length === 0) gameOver = false;
            } else if (gameMode === 'maze') {
                screenState.showMazeCover = true;
            }
            updateGameModeUI(); // Refresh UI based on potentially new screenState

        }

        window.onload = () => {
            loadSkinImages();
            loadWorldImages();
            loadModeSelectionImages();
            loadGameSettings(); // Loads settings including audio preferences and volume
            loadLives();
            setInterval(checkLifeRecovery, 1000);

            // Initialize HTML5 Audio Players
            if (typeof Audio !== 'undefined') {
                if (!generalBackgroundMusic) {
                    generalBackgroundMusic = new Audio(generalBackgroundMusicURL);
                    generalBackgroundMusic.loop = true;
                    console.log("Reproductor de música general (HTML5 Audio) creado en window.onload.");
                }
                if (!inGameBackgroundMusic) {
                    inGameBackgroundMusic = new Audio(inGameBackgroundMusicURL);
                    inGameBackgroundMusic.loop = true;
                    console.log("Reproductor de música de partida (HTML5 Audio) creado en window.onload.");
                }
                // Apply loaded volume settings. updateMusicVolume is safe to call.
                // It reads from musicVolumeSlider.value which is set by loadGameSettings.
                updateMusicVolume();
                updateSfxVolume();
            } else {
                console.warn("HTML5 Audio no soportado, música de fondo desactivada (chequeo en window.onload).");
                isMusicEnabled = false; // Ensure this is set if Audio is not supported
                areSfxEnabled = (audioToggleSelector.value === 'sfx_only'); // Keep SFX if it was sfx_only
                if (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'music_only') {
                    audioToggleSelector.value = areSfxEnabled ? 'sfx_only' : 'off';
                }
                Array.from(audioToggleSelector.options).forEach(option => {
                   if (option.value === 'all' || option.value === 'music_only') option.disabled = true;
                });
                musicVolumeSlider.disabled = true;
                if (musicVolumeControlGroup) musicVolumeControlGroup.classList.remove("interactive-mode");
                sfxVolumeSlider.disabled = true;
                if (sfxVolumeControlGroup) sfxVolumeControlGroup.classList.remove("interactive-mode");
            }

            const splashStartButtonEl = document.getElementById('splash-start-button');
            const splashTopImageEl = document.getElementById('splash-top-image');
            const splashBottomImageEl = document.getElementById('splash-bottom-image');
            const splashInfoButtonEl = document.getElementById('splash-info-button');
            const splashSettingsButtonEl = document.getElementById('splash-settings-button');

            function attachSplashButtonEvents(btnEl, onClick) {
                if (!btnEl) return;
                btnEl.addEventListener('mousedown', () => btnEl.classList.add('splash-button-pressed'));
                btnEl.addEventListener('mouseup', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('mouseleave', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('touchstart', () => btnEl.classList.add('splash-button-pressed'));
                btnEl.addEventListener('touchend', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('touchcancel', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('click', onClick);
            }

// Initialize synthSplashStart (Tone.Player) here
            if (typeof Tone !== 'undefined') {
                synthSplashStart = new Tone.Player({
                    url: "https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/f8cf11c2f8447c929e260b8ad8b417d1edc6048c/start-game-v2.mp3",
                    onload: () => { console.log("Sonido del botón de inicio del splash cargado (Tone.Player)."); },
                    onerror: (error) => { console.error("Error cargando sonido del botón de inicio del splash (Tone.Player):", error); }
                }).toDestination();
                synthSplashStart.volume.value = -3.1; // Adjust volume as needed for Tone.Player
                // We no longer call initializeToneSynths() directly here.
                // ensureAudioContextRunning (on first click) will handle it.
            }

            attachSplashButtonEvents(splashInfoButtonEl, () => {
                panelOpenedFromSplash = true;
                if (gameContainer) gameContainer.classList.remove('hidden');
                openInfoPanel();
            });

            attachSplashButtonEvents(splashSettingsButtonEl, () => {
                panelOpenedFromSplash = true;
                if (gameContainer) gameContainer.classList.remove('hidden');
                openSettingsPanel();
            });



            if (splashStartButtonEl) {
                splashStartButtonEl.addEventListener('mousedown', () => {
                    splashStartButtonEl.classList.add('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('mouseup', () => {
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('mouseleave', () => { 
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchstart', (e) => {
                    splashStartButtonEl.classList.add('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchend', () => {
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchcancel', () => { 
                     splashStartButtonEl.classList.remove('splash-button-pressed');
                });

                splashStartButtonEl.addEventListener('click', async () => {
                    console.log("Splash start button CLICK event triggered.");
                    try {
                        splashStartButtonEl.classList.remove('splash-button-pressed'); // Ensure visual state resets

                        const audioContextStarted = await ensureAudioContextRunning(); // This is key for Tone.js
                        if (audioContextStarted) {
                             if (areSfxEnabled && synthSplashStart && synthSplashStart.loaded) { // synthSplashStart is Tone.Player
                                synthSplashStart.start(); // Play the preloaded sound
                             } else if (areSfxEnabled) {
                                 console.warn("Splash sound not played: SFX disabled, synth not loaded, or synth undefined.");
                             }
                        } else {
                            console.warn("Tone.js context could not be started by splash button click.");
                        }

                        if (splashScreen) splashScreen.classList.add('hidden');
                        if (gameContainer) gameContainer.classList.remove('hidden');
                        modeSelectIndex = 0;
                        showModeSelect = true;
                        introOptionAvailable = true; // reset intro visibility on fresh start
                        modeTransitionStart = null;
                        screenState.showCoverForWorld = 0;
                        screenState.showLevelCompleteCover = 0;
                        screenState.showWorldCompleteCover = 0;
                        screenState.showDefeatCoverForWorld = 0;
                        screenState.showTimeoutCover = false;
                        screenState.showFreeModeCover = false;
                        screenState.showMazeCover = false;
                        screenState.mazeResultType = '';
                        initializeGameLogic(); // This will handle playing HTML5 audio if enabled
                        draw();
                        updateMainButtonStates();
                    } catch (error) {
                        console.error("Error within splash start button click handler:", error);
                    }
                });
            } else {
                console.error("Botón de inicio del splash no encontrado!");
                if (splashScreen) splashScreen.classList.add('hidden');
                if (gameContainer) gameContainer.classList.remove('hidden');
                initializeGameLogic();
            }
        };
    </script>
</body>
</html>
