<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <title>Snake Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Variable de ancho máximo para sincronizar Splash y juego */
        :root {
            --game-max-width: 520px;
        }

        @media (hover: hover) and (pointer: fine) {
            :root {
                --game-max-width: min(75vmin, 700px);
            }
        }

        /* Estilos base del cuerpo y contenedor del juego */
        html {
            height: 100%;
            overflow: hidden; 
        }
        body {
            height: 100%;
            font-family: 'Press Start 2P', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;   
            background-color: #111827; 
            color: #f5f5f5; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden; 
            touch-action: none;
        }

        /* Color violeta para textos en negrita */
        strong {
            color: #8f66af;
        }

        .hidden {
            display: none !important;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111827;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #splash-content {
            width: 100%;
            max-width: var(--game-max-width);
            height: 100%;
            display: flex;
            background-color: #02010a;
            background-image: url(https://i.imgur.com/rYyiiMo.png);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-radius: 12px;
            box-sizing: border-box;
        }

        #splash-top-image {
            width: 95%;
            max-width: var(--game-max-width); /* Límite para PC, un poco más grande que el juego */
            height: auto;
            object-fit: contain;
            box-sizing: border-box;
        }

        #splash-start-button {
            cursor: pointer;
            width: auto;
            height: auto;
            max-width: min(55vw, 150px); /* Responsivo pero con límite en PC */
            object-fit: contain;
            z-index: 2001;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        #splash-start-button.splash-button-pressed,
        #splash-info-button.splash-button-pressed,
        #splash-settings-button.splash-button-pressed {
            transform: scale(0.90) translateY(2px);
            filter: brightness(0.7);
        }

        #splash-button-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 25px;
            padding-top: 10px;
        }

        #splash-info-button,
        #splash-settings-button {
            cursor: pointer;
            width: auto;
            height: auto;
            max-width: min(20vw, 70px);
            object-fit: contain;
            z-index: 2001;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        #splash-bottom-image {
            width: 100%;
            max-width: var(--game-max-width); /* Límite para PC, un poco más grande que el juego */
            height: auto;
            max-height: calc(25vh + 60px);
            object-fit: contain;
            box-sizing: border-box;
            padding-top: 40px;
            padding-bottom: 40px;
        }


        .game-container {
            text-align: center;
            background-color: #1F2937;
            padding-top: 10px;
            padding-left: 10px;
            padding-right: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            width: 100%;
            max-width: var(--game-max-width);
            box-sizing: border-box;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #play-area { position: relative; }

        #top-info-bar {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            width: 100%;
            margin: 0 auto 5px auto;
            position: relative;
            z-index: 10;
        }

        #top-info-bar .info-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 10px;
            min-width: 80px;
            min-height: 55px;
            box-sizing: border-box;
            text-align: center;
        }
        #top-info-bar .info-label {
            font-size: 0.65em;
            color: #a0aec0;
            margin-bottom: 4px;
            display: block;
            line-height: 1.1;
            word-break: break-word;
        }
        #top-info-bar .info-value {
            font-size: 0.85em;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            line-height: 1.3;
        }

        #top-info-bar.selector-mode .info-group {
            background-color: transparent;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        #top-info-bar.selector-mode #coins-info-group {
            background-image: url('https://i.imgur.com/lQ4ltzt.png');
            position: relative;
        }
        #top-info-bar.selector-mode #points-info-group {
            background-image: url('https://i.imgur.com/vPzvx4U.png');
        }
        #top-info-bar.selector-mode #time-info-group {
            background-image: url('https://i.imgur.com/P16YAd1.png');
        }
        #top-info-bar.selector-mode #coins-info-group .flex {
            position: absolute;
            top: 50%;
            left: 60%;
            transform: translate(-50%, -50%);
        }
        #top-info-bar.selector-mode .info-label,
        #top-info-bar.selector-mode .coin-icon {
            display: none;
        }

        #title-panel {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px 10px;
            min-height: 55px;
            width: 100%;
            margin: 0 auto 5px auto;
            position: relative;
            z-index: 10;
        }
        #title-panel h2 {
            font-size: 1.4em;
            margin: 0;
            color: #8f66af;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #title-image {
            max-height: 45px;
            width: auto;
            max-width: 90%;
        }

        #main-info-title img,
        #specific-info-title img {
            max-height: 45px;
            width: auto;
            max-width: 90%;
        }

#settings-title img {
    max-height: 45px;
    width: auto;
    max-width: 90%;
}

        #progress-panel {
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 8px;
            width: 100%;
            margin: 0 auto 5px auto; 
            position: relative;
            z-index: 10; 
        }

        #current-world-info-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 10px;
            grid-column: 1 / 2;
            min-width: 80px;
            min-height: 55px;
            box-sizing: border-box;
            text-align: center;
            cursor: pointer;
        }
         #current-world-info-group .info-label { 
            font-size: 0.65em; 
            color: #a0aec0; 
            margin-bottom: 4px; 
            display: block; 
            line-height: 1.1;
        }
        #current-world-info-group .info-value {
            font-size: 0.85em;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
        }
        #progress-panel.classification-mode #current-world-info-group .info-value {
            margin-top: 4px;  
            font-size: 0.7em;
        }

        #star-progress-wrapper {
            grid-column: 2 / 4;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 10px;
            min-height: 55px;
            box-sizing: border-box;
            text-align: center;
        }

        #star-progress-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px; 
            padding: 0; 
            justify-items: center;
            align-items: center;
            width: 100%; 
            max-width: 260px; 
        }
        .progress-star {
            width: 38px;
            height: 38px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .progress-star.full {
            background-image: url('https://i.imgur.com/mJU2iIm.png');
        }
        .progress-star.empty {
            background-image: url('https://i.imgur.com/M4FDVgp.png');
        }

        /* --- INICIO DE CSS CORREGIDO PARA #high-score-display --- */
        #high-score-display {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            gap: 2px;
            width: 100%;
            line-height: 1.2;
            /* font-size: 0.85em; <- Eliminado para usar rem en hijos */
        }
        #high-score-display #hs-main-label { 
            font-size: 0.75rem;  /* Cambiado a rem */
            color: #a0aec0; 
            margin-bottom: 5px;
            display: block; 
            line-height: 1.1;
            text-align: center;
        }
        #hs-values-container { 
            display: flex;
            flex-direction: row;
            align-items: baseline;
            justify-content: center;
            gap: 2px;
            white-space: nowrap;
        }
        #high-score-display .hs-value { 
            color: #f5f5f5; 
            font-family: 'Press Start 2P', sans-serif;
            font-size: 0.65rem; /* Cambiado a rem */
        }
        #high-score-display .hs-label-unit { 
            color: #a0aec0; 
            font-size: 0.5rem; /* Cambiado a rem */
            margin-left: 2px; 
            margin-right: 4px;
        }
        #high-score-display .hs-separator {
            margin-right: 3px;
            color: #a0aec0;
            font-size: 0.6rem; /* Cambiado a rem */
        }
        #high-score-display #hs-skin-value.hs-value {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: baseline;
        }


        canvas {
            background-color: #374151; 
            border: 4px solid #4b5563; 
            display: block; 
            margin: 0 auto 5px auto; 
            max-width: 100%; 
            border-radius: 8px; 
            aspect-ratio: 1 / 1; 
        }

        #mobile-controls {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            margin: 0 auto;
            padding: 0 0px;
            box-sizing: border-box;
            flex-direction: column;
            flex-grow: 1;
        }


@media (hover: hover) and (pointer: fine) {
    #mobile-controls { display: none; }
    #play-area {
        display: grid;
        grid-template-rows: auto 1fr auto;
        flex-grow: 1;
        position: relative;
    }
            #gameCanvas {
                justify-self: center;
                align-self: center;
                margin-bottom: 0;
            }
            #setup-controls { margin-top: 5px; }
        }

        #d-pad-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; 
            grid-template-rows: 1fr 1fr;   
            gap: 8px; 
            width: 100%;
            min-height: 120px; 
            height: 100%; 
        }

        .control-button {
            background-color: #8f66af;
            border: 3px solid #2d1d3a;
            border-radius: 8px;
            color: #F3F3F3;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2px;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            box-shadow: inset 0 10px 6px #D6BCE9;
            text-shadow: -1px -1px 0 #2d1d3a,
                         1px -1px 0 #2d1d3a,
                        -1px 1px 0 #2d1d3a,
                         1px 1px 0 #2d1d3a;
        }
        .d-pad-button-pressed { 
            transform: scale(0.95) translateY(1px);
            filter: brightness(0.8);
        }
        
        #up-button    { 
            grid-column: 2; 
            grid-row: 1; 
        } 
        #left-button  { 
            grid-column: 1; 
            grid-row: 1 / span 2; 
        } 
        #right-button { 
            grid-column: 3; 
            grid-row: 1 / span 2; 
        } 
        #down-button  { 
            grid-column: 2; 
            grid-row: 2; 
        } 

        .control-button:hover { filter: brightness(0.95); }
        
        .arrow-svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .control-button .arrow-svg path {
            fill: #47315F;
            stroke: #C1A4D4;
            stroke-width: .3;
            stroke-linejoin: round;
        }
        .arrow-icon {
            width: 100%;
            height: 100%;
            display: block;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .mode-nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: transparent;
            border: none;
            padding: 0;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff3e1;
            cursor: pointer;
            z-index: 20;
        }
        #mode-left-button { left: 10px; }
        #mode-right-button { right: 10px; }
        
        #setup-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-top: 5px;
            margin-top: auto;
            margin-bottom: 0px;
            position: relative;
            width: 100%;
        }
        
        .control-row { 
            display: flex;
            align-items: stretch; 
            gap: 8px; 
            width: 100%;
            flex-wrap: wrap; 
            justify-content: center; 
        }
        
        .control-group {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 12px;
            flex: 1;
            min-width: 100px;
            box-sizing: border-box;
            transition: background-color 0.2s ease;
            min-height: 50px;
        }

        /* Extra space below the music and SFX volume sliders */
        #music-volume-control-group,
        #sfx-volume-control-group {
            padding-bottom: 12px;
        }

        .control-label-icon-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-top: 4px;
            margin-bottom: 6px;
        }

        .control-label {
            font-size: 0.7em;
            color: #a0aec0;
            display: block;
            line-height: 1.1;
            text-align: left;
            flex-grow: 1;
            margin-right: 0;
        }
        
        .setting-info-button {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            background-color: #384152;
            border: none;
            border-radius: 8px;
            padding: 0;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 38px;
            box-sizing: border-box;
        }
        .setting-info-icon {
            width: 24px;
            height: 24px;
            fill: #f5f5f5;
        }

        .setting-info-button[data-setting] .setting-info-icon {
            height: 70%;
            width: auto;
            display: block;
            fill: initial;
        }

        .setting-info-button:disabled .setting-info-icon {
            filter: brightness(0.4);
        }

        /* Semi-transparent navigation arrows */
        .mode-nav-button .arrow-icon {
            opacity: 0.6;
        }

        .coin-icon {
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }


        #earnedCoinsMessage {
            position: absolute;
            top: 50%;
            left: 100%;
            transform: translateX(10px) translateY(-50%);
            color: #8f66af;
            font-size: 0.7em;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
        }

        #earnedCoinsMessage.show {
            opacity: 1;
            transform: translateX(0) translateY(-50%);
        }

        #earnedCoinsMessage.hide {
            opacity: 0;
            transform: translateX(-10px) translateY(-50%);
        }


        #difficultySelector, #worldsSelector, #audioToggleSelector, #skinSelector, #foodSelector, #playerNameSelector, #free-difficulty-selector {
            padding: 4px 6px;
            width: calc(100% - 50px);
            font-size: 0.75em;
            border: none;
            border-radius: 4px;
            background-color: transparent;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            text-align: left;
            height: 38px;
            box-sizing: border-box;
            -moz-appearance: none;
            -webkit-appearance: none;
            appearance: none;
            margin-top: 4px;
            margin-bottom: 0;
        }
        
        #difficultySelector option, #worldsSelector option, #audioToggleSelector option, #skinSelector option, #foodSelector option, #playerNameSelector option, #free-difficulty-selector option {
            background-color: #374151;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            text-align: left; 
        }
        
        #difficultySelector, #worldsSelector, #audioToggleSelector, #skinSelector, #foodSelector, #playerNameSelector, #free-difficulty-selector {
            text-align-last: left;
        }
        select option {
            direction: ltr; 
        }


        #difficultySelector:focus, #worldsSelector:focus, #audioToggleSelector:focus, #skinSelector:focus, #foodSelector:focus, #playerNameSelector:focus, #free-difficulty-selector:focus {
            outline: 1px solid #8f66af; 
            box-shadow: none; 
        }
        #difficultySelector:disabled, #worldsSelector:disabled, #audioToggleSelector:disabled, #skinSelector:disabled, #foodSelector:disabled, #playerNameSelector:disabled, #free-difficulty-selector:disabled, #musicVolumeSlider:disabled, #sfxVolumeSlider:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        #newPlayerNameInput {
            padding: 4px 6px;
            width: calc(100% - 50px);
            font-size: 0.75em;
            border: 1px solid #8f66af;
            border-radius: 4px;
            background-color: transparent;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            box-sizing: border-box;
            height: 38px;
            margin-top: 4px;
            margin-bottom: 0;
        }
        #newPlayerNameInput:focus {
            outline: 1px solid #8f66af;
            box-shadow: none;
        }

        #free-settings-panel input[type="number"] {
            padding: 4px 6px;
            width: 100%;
            font-size: 0.75em;
            border: none;
            border-radius: 4px;
            background-color: transparent;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            box-sizing: border-box;
            margin-top: 4px;
            margin-bottom: 0;
        }

        #free-settings-panel input[type="number"]:focus {
            outline: 1px solid #8f66af;
            box-shadow: none;
        }

        .range-inputs {
            display: flex;
            gap: 8px;
        }
        .range-inputs input[type="number"] {
            flex: 1;
        }
        
        .control-group.interactive-mode { 
            background-color: #4A5568; 
        }
        .control-group.interactive-mode:hover {
            background-color: #5A6578; 
            cursor: pointer;
        }
        .control-group.interactive-mode:hover #difficultySelector,
        .control-group.interactive-mode:hover #worldsSelector,
        .control-group.interactive-mode:hover #audioToggleSelector,
        .control-group.interactive-mode:hover #skinSelector,
        .control-group.interactive-mode:hover #foodSelector,
        .control-group.interactive-mode:hover #musicVolumeSlider,
        .control-group.interactive-mode:hover #sfxVolumeSlider {
            cursor: pointer;
        }

        .control-group.dimmed {
            filter: brightness(0.6);
        }

        #musicVolumeSlider {
            -webkit-appearance: none;
            appearance: none;
            width: calc(100% - 50px);
            height: 8px;
            background: #4B5563;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-top: 4px;
            margin-bottom: 0;
        }
        #sfxVolumeSlider {
            -webkit-appearance: none;
            appearance: none;
            width: calc(100% - 50px);
            height: 8px;
            background: #4B5563;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-top: 4px;
            margin-bottom: 0;
        }
        #musicVolumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
        }
        #sfxVolumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
        }
        #musicVolumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        #sfxVolumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        .settings-range {
            -webkit-appearance: none;
            appearance: none;
            width: calc(100% - 50px);
            height: 8px;
            background: #4B5563;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
            margin-top: 15px;
            margin-bottom: 5px;
        }
        .control-group .settings-range:not(:last-of-type) {
            margin-bottom: 15px;
        }
        .settings-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
        }
        .settings-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #8f66af;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        #classification-ranking-group {
            /* allow panel to expand with ranking */
        }
        #classification-ranking-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.6rem;
            color: #f5f5f5;
            border-radius: 8px;
            overflow: hidden;
        }
        #classification-ranking-table th,
        #classification-ranking-table td {
            padding: 10px 4px;
            border: 1px solid #5F3F79;
            text-align: center;
        }
        #classification-ranking-table th {
            background-color: #ba9bc9;
        }
        #classification-ranking-table .title-row th {
            background-color: #A366C4;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4B5563;
            transition: .4s;
            border-radius: 24px;
        }
        .slider.round:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        .switch input:checked + .slider.round {
            background-color: #8f66af;
        }
        .switch input:checked + .slider.round:before {
            transform: translateX(16px);
        }

        #action-buttons-row {
            justify-content: center; 
            min-height: 65px; 
        }
        .action-button-wrapper { 
            background-color: transparent !important; 
            padding: 0 !important; 
            min-height: auto !important;
            min-width: auto; 
            display: flex; 
        }
        #back-button-wrapper { display: none; }
        #start-button-wrapper {
            flex-grow: 1;
            display: flex;
            gap: 4px;
        }
        #start-button-wrapper.split #startButton { flex-grow: 2; }
        #start-button-wrapper.split #restartMazeButton { flex-grow: 1; }
        #config-button-wrapper { display: none; }


        #startButton, #restartMazeButton, #configButton, #backButton {
            padding: 10px 15px;
            font-size: 0.85em;
            color: #f5f5f5;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            height: 65px;
            font-family: 'Press Start 2P', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        #startButton {
            background-color: #8f66af;
            color: #F3F3F3;
            border: 3px solid #2d1d3a;
            box-shadow:
                inset 0 10px 6px #D6BCE9,
                4px 4px 6px #442F58;
            text-shadow: -1px -1px 0 #2d1d3a,
                         1px -1px 0 #2d1d3a,
                        -1px 1px 0 #2d1d3a,
                         1px 1px 0 #2d1d3a;
        }
        #restartMazeButton {
            padding: 0;
            background-color: transparent;
            flex: 0 0 auto;
            width: auto;
            min-width: 0;
        }
        #configButton, #backButton {
            background-color: #384152;
            min-width: 65px;
        }

        #startButton:hover {
            filter: brightness(0.95);
        }

        #startButton:disabled {
            filter: brightness(0.6);
            cursor: not-allowed;
        }
        #restartMazeButton:disabled,
        #configButton:disabled,
        #backButton:disabled {
            cursor: not-allowed;
        }
        #configButton:disabled #configButtonIcon,
        #backButton:disabled #backButtonIcon,
        #restartMazeButton:disabled #restartMazeButtonIcon {
            filter: brightness(0.7);
        }
        #backButton { padding: 0; background-color: transparent; flex: 0 0 auto; width: auto; min-width: 0; }
        #backButtonIcon { height: 100%; width: auto; display: block; transition: transform 0.05s ease-out, filter 0.05s ease-out; }
        #restartMazeButtonIcon { height: 100%; width: auto; display: block; transition: transform 0.05s ease-out, filter 0.05s ease-out; }
        #configButton { padding: 0; background-color: transparent; flex: 0 0 auto; width: auto; min-width: 0; }
        #configButtonIcon { height: 100%; width: auto; display: block; transition: transform 0.05s ease-out, filter 0.05s ease-out; }
        .icon-button-pressed {
            transform: scale(0.90) translateY(2px);
            filter: brightness(0.7);
        }
        #startButton.icon-button-pressed,
        #resetDataButton.icon-button-pressed,
        #confirmResetYes.icon-button-pressed,
        #confirmResetNo.icon-button-pressed {
            filter: brightness(0.5);
        }
        .config-svg,
        .info-svg {
            height: 100%;
            width: auto;
            fill: currentColor;
            display: block;
        }

        .settings-panel-hidden, .info-panel-hidden, .specific-info-panel-hidden, .free-settings-panel-hidden, .reset-panel-hidden {
            display: none !important;
        }
        #settings-panel, #info-panel, #specific-info-panel, #free-settings-panel, #reset-confirmation-panel {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background-color: #1F2937;
            padding: 15px;
            border-radius: 12px;
            box-shadow:
                inset 0 0 0 4px #8f66af,
                inset 0 4px 6px #D6BCE9,
                4px 4px 6px #442F58,
                0 10px 30px rgba(0,0,0,0.6);
            z-index: 2100;
            width: 100%;
            max-width: var(--game-max-width);
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 2px solid #2d1d3a;
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

.panel-content {
            overflow-y: auto;
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding-right: 0;
        }
        .scroll-padding { padding-right: 4px; }

        #info-panel,
        #specific-info-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }
        #maze-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 48px;
            height: 48px;
            margin-right:30px;
        }
        #maze-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #world-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 48px;
            height: 48px;
            margin-right:30px;
        }
        #world-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #classification-info-button {
            position: static;
            top: auto;
            right: auto;
            transform: none;
            background-color: transparent;
            width: 48px;
            height: 48px;
            margin-right:30px;
        }
        #classification-info-button .setting-info-icon {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #free-settings-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }
        #settings-panel {
            max-height: 90vh;
            box-sizing: border-box;
        }

        .centered-panel {
            top: 50%;
        }
        #settings-panel.centered-panel,
        #info-panel.centered-panel,
        #specific-info-panel.centered-panel,
        #free-settings-panel.centered-panel,
        #reset-confirmation-panel.centered-panel {
            transform: translate(-50%, -50%) scale(0.95);
        }
        #settings-panel.centered-panel.panel-visible,
        #info-panel.centered-panel.panel-visible,
        #specific-info-panel.centered-panel.panel-visible,
        #free-settings-panel.centered-panel.panel-visible,
        #reset-confirmation-panel.centered-panel.panel-visible {
            transform: translate(-50%, -50%) scale(1);
        }
        #settings-panel.panel-visible,
        #info-panel.panel-visible,
        #specific-info-panel.panel-visible,
        #free-settings-panel.panel-visible,
        #reset-confirmation-panel.panel-visible {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

         #specific-info-panel {
            z-index: 2101;
        }
        .settings-header, .info-header, .specific-info-header, .reset-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #8f66af;
            margin-bottom: 3px;
        }
        .settings-header h2, .info-header h2, .specific-info-header h2, .reset-header h2 {
            font-size: 1.4em;
            margin: 0;
        }
        .settings-header .header-title-group {
            display: flex;
            align-items: center;
            gap: 0;
        }
        #free-settings-panel .settings-header h2 {
            font-size: 1.1em;
        }
        #close-settings-button, #close-info-button, #close-specific-info-button, #close-free-settings-button {
            background: none;
            border: none;
            color: #f5f5f5;
            font-size: 2em; 
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        #close-settings-button:hover, #close-info-button:hover, #close-specific-info-button:hover, #close-free-settings-button:hover {
            color: #8f66af;
        }
        #settings-panel .control-group {
            background-color: #374151;
            min-width: unset;
            width:100%;
        }
        #settings-panel #classification-ranking-group {
            background-color: transparent;
        }
        #free-settings-panel .control-group {
            flex: none;
            width: 100%;
        }

        #free-settings-panel .panel-content {
            padding-right: 10px;
        }

        /* Primer título/texto en cada contenedor del modo libre */
        #free-settings-panel .control-group > label.control-label:first-child,
        #free-settings-panel .control-group > .control-label-icon-row:first-child > label.control-label {
            font-size: 0.85em;
            color: #F3F3F3;
        }

        /* Estilos para el contenido del panel de información */
        #info-panel-content {
            line-height: 1.6;
            overflow-y: auto;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-right: 10px;
        }
        #specific-info-content {
            line-height: 1.6;
            overflow-y: auto;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-right: 0;
        }
        .info-header h2#main-info-title,
        #info-panel-content h4,
        #specific-info-content h4 {
            font-size: 1em;
            color: #8f66af;
            margin-top: 6px;
            margin-bottom: 3px;
            text-align: left;
        }
         #specific-info-content h3 {
            font-size: 0.8em;
            color: #f5f5f5;
            margin-bottom: 6px;
            text-align: center;
        }
        #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul {
            font-size: 0.8em;
            margin-bottom: 6px;
            text-align: justify;
        }
        #info-panel-content ul, #specific-info-content ul {
            list-style-type: disc; 
            list-style-position: inside;
            padding-left: 5px;
        }
        #info-panel-content li, #specific-info-content li {
            margin-bottom: 6px;
        }
        /* Estilos de scroll unificados para todos los paneles */
        #info-panel-content::-webkit-scrollbar,
        #specific-info-content::-webkit-scrollbar,
        #settings-panel .panel-content::-webkit-scrollbar,
        #info-panel .panel-content::-webkit-scrollbar,
        #specific-info-panel .panel-content::-webkit-scrollbar,
        #free-settings-panel .panel-content::-webkit-scrollbar,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        #info-panel-content::-webkit-scrollbar-track,
        #specific-info-content::-webkit-scrollbar-track,
        #settings-panel .panel-content::-webkit-scrollbar-track,
        #info-panel .panel-content::-webkit-scrollbar-track,
        #specific-info-panel .panel-content::-webkit-scrollbar-track,
        #free-settings-panel .panel-content::-webkit-scrollbar-track,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-track {
            background: #2d1d3a;
            border-radius: 4px;
        }
        #info-panel-content::-webkit-scrollbar-thumb,
        #specific-info-content::-webkit-scrollbar-thumb,
        #settings-panel .panel-content::-webkit-scrollbar-thumb,
        #info-panel .panel-content::-webkit-scrollbar-thumb,
        #specific-info-panel .panel-content::-webkit-scrollbar-thumb,
        #free-settings-panel .panel-content::-webkit-scrollbar-thumb,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-thumb {
            background: #442F58;
            border-radius: 4px;
        }
        #info-panel-content::-webkit-scrollbar-thumb:hover,
        #info-panel-content::-webkit-scrollbar-thumb:active,
        #specific-info-content::-webkit-scrollbar-thumb:hover,
        #specific-info-content::-webkit-scrollbar-thumb:active,
        #settings-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #settings-panel .panel-content::-webkit-scrollbar-thumb:active,
        #info-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #info-panel .panel-content::-webkit-scrollbar-thumb:active,
        #specific-info-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #specific-info-panel .panel-content::-webkit-scrollbar-thumb:active,
        #free-settings-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #free-settings-panel .panel-content::-webkit-scrollbar-thumb:active,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-thumb:hover,
        #reset-confirmation-panel .panel-content::-webkit-scrollbar-thumb:active {
            background: #8f66af;
        }


        @media screen and (max-width: 600px) {
            /* --- INICIO DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */
            /* Ya no necesitamos reducir el font-size base del contenedor #high-score-display */
            
            #high-score-display #hs-main-label { font-size: 0.7rem; }
            #hs-values-container { gap: 3px; } 
            #high-score-display .hs-value { font-size: 0.7rem; }
            #high-score-display .hs-label-unit { font-size: 0.45rem; }
            #high-score-display .hs-separator { font-size: 0.55rem; }
            #high-score-display #hs-skin-value.hs-value { max-width: 85px; }
            /* --- FIN DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */


            #top-info-bar .info-group { min-height: 50px; padding: 6px; min-width: 70px;}
            #top-info-bar .info-label { font-size: 0.6em; }
            #top-info-bar .info-value { font-size: 0.8em; }

            #title-panel { min-height: 50px; padding: 6px; }

            #current-world-info-group { min-height: 50px; padding: 6px; min-width: 70px; cursor: pointer;}
            #current-world-info-group .info-label { font-size: 0.6em; }
            #current-world-info-group .info-value { font-size: 0.8em; }
            #progress-panel.classification-mode #current-world-info-group .info-value { font-size: 0.7em; }
            #star-progress-wrapper { min-height: 50px; padding: 6px;}
            .progress-star { width: 30px; height: 30px; }
            #star-progress-container { max-width: 200px; gap: 10px;}


            #d-pad-container {
                min-height: 110px; 
                gap: 6px;
            }
            .arrow-svg { width: 70%; height: 70%; }
            .arrow-icon { width: 100%; height: 100%; }
            
             #startButton, #restartMazeButton, #configButton, #backButton {
                 font-size: 0.75em;
                 height: 55px;
            }
            #restartMazeButton, #configButton, #backButton {
                min-width: 55px;
            }

            #settings-panel, #info-panel, #specific-info-panel, #free-settings-panel {
                width: calc(100% - 20px);
                padding: 20px;
            }
            .settings-header h2, .info-header h2, .specific-info-header h2 {
                font-size: 1.1em;
            }
            #free-settings-panel .settings-header h2 {
                font-size: 0.90em;
                text-align: left;
                white-space: nowrap;
            }
             #settings-panel .control-group {
                min-height: 50px;
                justify-content: space-between;
                padding-top: 6px;
                padding-bottom: 6px;
            }
             #settings-panel #difficultySelector,
             #settings-panel #worldsSelector,
             #settings-panel #audioToggleSelector,
             #settings-panel #skinSelector,
             #settings-panel #foodSelector,
             #settings-panel #playerNameSelector,
             #settings-panel #musicVolumeSlider {
                font-size: 0.65em;
                margin-top: 2px;
                margin-bottom: 0;
             }
             #settings-panel .control-label-icon-row {
                margin-top: 4px;
                margin-bottom: 0;
             }
             .setting-info-button {
                width: 36px;
                height: 32px;
             }
             .setting-info-button[data-setting] .setting-info-icon {
                height: 100%;
                width: auto;
             }


            .info-header h2#main-info-title, #specific-info-content h3 { font-size: 0.95em; }
            #info-panel-content h4, #specific-info-content h4 { font-size: 0.95em; }
            #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul { font-size: 0.75em; }
        }
         @media screen and (max-width: 400px) { 
            /* --- INICIO DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */
            /* Tampoco necesitamos tocar el font-size del contenedor */

            #high-score-display #hs-main-label { font-size: 0.6rem; margin-bottom: 2px;}
            #hs-values-container { gap: 2px; }
            #high-score-display .hs-value { font-size: 0.6rem; }
            #high-score-display .hs-label-unit { font-size: 0.4rem; }
            #high-score-display .hs-separator { font-size: 0.45rem; }
            #high-score-display #hs-skin-value.hs-value { max-width: 70px; }
            /* --- FIN DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */


             #top-info-bar .info-label { font-size: 0.55em; }
             #top-info-bar .info-value { font-size: 0.7em; }
             #top-info-bar .info-group { min-width: 60px;}

            #current-world-info-group .info-label { font-size: 0.55em; }
            #current-world-info-group .info-value { font-size: 0.7em; }
            #progress-panel.classification-mode #current-world-info-group .info-value { font-size: 0.6em; }
            #current-world-info-group { min-width: 60px; cursor: pointer;}
            .progress-star { width: 24px; height: 24px; }
            #star-progress-container { max-width: 170px; gap: 8px;}


            #d-pad-container {
                min-height: 100px; 
                gap: 5px;
            }
            .arrow-svg { width: 70%; height: 70%; }
            .arrow-icon { width: 100%; height: 100%; }

             #startButton, #restartMazeButton, #configButton, #backButton {
                 font-size: 0.7em;
                 height: 50px;
            }
            #restartMazeButton, #configButton, #backButton {
                min-width: 50px;
            }
            .config-svg,
            .info-svg {
                height: 100%;
                width: auto;
            }
            #settings-panel, #info-panel, #specific-info-panel, #free-settings-panel {
                padding: 15px;
            }
            .info-header h2#main-info-title, #specific-info-content h3 { font-size: 0.85em; }
            #info-panel-content h4, #specific-info-content h4 { font-size: 0.85em; }
            #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul { font-size: 0.7em; }
        }

        @media screen and (min-width: 600px) {
            #settings-panel #difficultySelector,
            #settings-panel #worldsSelector,
            #settings-panel #audioToggleSelector,
            #settings-panel #skinSelector,
            #settings-panel #foodSelector {
            height: 30px;
            margin-top: 2px;
            margin-bottom: 0;
        }
        }

        #settings-panel #resetDataButton {
            background-color: #dc2626;
            color: #F3F3F3;
            border: 3px solid #7f1d1d;
            box-shadow:
                inset 0 10px 6px #f87171,
                4px 4px 6px #7f1d1d;
            text-shadow: -1px -1px 0 #7f1d1d,
                         1px -1px 0 #7f1d1d,
                        -1px 1px 0 #7f1d1d,
                         1px 1px 0 #7f1d1d;
            border-radius: 8px;
            padding: 10px 15px;
            font-family: "Press Start 2P", sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            text-align: center;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 65px;
            box-sizing: border-box;
        }

#settings-panel #resetDataButton:hover { filter: brightness(0.95); }

        #free-settings-panel #apply-free-settings-bottom {
            background-color: #8f66af;
            color: #F3F3F3;
            border: 3px solid #2d1d3a;
            box-shadow:
                inset 0 10px 6px #D6BCE9,
                4px 4px 6px #442F58;
            text-shadow: -1px -1px 0 #2d1d3a,
                         1px -1px 0 #2d1d3a,
                        -1px 1px 0 #2d1d3a,
                         1px 1px 0 #2d1d3a;
            border-radius: 8px;
            padding: 10px 15px;
            font-family: 'Press Start 2P', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%;
            text-align: center;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 65px;
            box-sizing: border-box;
        }
        #free-settings-panel #apply-free-settings-bottom:hover { filter: brightness(0.95); }
        #free-settings-panel #apply-free-settings-bottom:disabled {
            filter: brightness(0.6);
            cursor: not-allowed;
        }
        #free-settings-panel #apply-free-settings-bottom.icon-button-pressed {
            filter: brightness(0.5);
        }

        #reset-confirmation-panel { z-index: 2102; }

        .reset-panel-hidden { display: none !important; }

        #reset-confirmation-panel p { text-align: center; margin: 0 0 10px 0; }
        #reset-confirmation-panel .reset-buttons { display: flex; gap: 15px; }
        #reset-confirmation-panel .reset-buttons button {
            flex: 1;
            padding: 10px 15px;
            font-size: 0.85em;
            color: #F3F3F3;
            border-radius: 8px;
            font-family: "Press Start 2P", sans-serif;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            height: 65px;
            box-sizing: border-box;
        }
        #confirmResetYes {
            background-color: #b91c1c;
            border: 3px solid #7f1d1d;
            box-shadow:
                inset 0 10px 6px #f87171,
                4px 4px 6px #7f1d1d;
            text-shadow: -1px -1px 0 #7f1d1d,
                         1px -1px 0 #7f1d1d,
                        -1px 1px 0 #7f1d1d,
                         1px 1px 0 #7f1d1d;
        }
        #confirmResetYes:hover { filter: brightness(0.95); }
        #confirmResetNo {
            background-color: #4CAF50;
            border: 3px solid #1b5e20;
            box-shadow:
                inset 0 10px 6px #81c784,
                4px 4px 6px #1b5e20;
            text-shadow: -1px -1px 0 #1b5e20,
                         1px -1px 0 #1b5e20,
                        -1px 1px 0 #1b5e20,
                         1px 1px 0 #1b5e20;
        }
        #confirmResetNo:hover { filter: brightness(0.95); }

        /* --- Estilo de botones para selección de niveles en modo laberinto --- */
        .maze-level-button {
          width: 100px;
          height: 100px;
          background-image: url('https://i.imgur.com/XVbQCVX.png');
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center;
          position: relative;
          cursor: pointer;
          transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .maze-level-button:hover {
          filter: brightness(0.95);
        }

        .maze-level-button.icon-button-pressed {
          filter: brightness(0.5);
        }

        .maze-level-button.disabled {
          pointer-events: none;
          opacity: 0.7;
          filter: grayscale(100%);
        }

        /* --- Estilo de botones para selección de mundos en modo aventura --- */
        .world-button {
          width: 150px;
          height: 150px;
          background-image: url('https://i.imgur.com/8Gp9hfW.png');
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center;
          position: relative;
          cursor: pointer;
          transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        .world-button:hover { filter: brightness(0.95); }
        .world-button.icon-button-pressed { filter: brightness(0.5); }
        .world-button.disabled {
          pointer-events: none;
          opacity: 0.7;
          filter: grayscale(100%);
        }

        #mazeLevelButtonsContainer.disabled {
          pointer-events: none;
          opacity: 0.7;
        }

        #worldButtonsContainer.disabled {
          pointer-events: none;
          opacity: 0.7;
        }

        .maze-level-number {
          position: absolute;
          top: 42%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 1.4rem;
          color: #C084FC;
          text-shadow: 1px 1px 2px black;
          font-family: 'Press Start 2P', sans-serif;
        }

        .maze-stars {
          position: absolute;
          bottom: 11px;
          left: 0;
          right: 0;
          display: flex;
          justify-content: center;
          gap: 2px;
        }

        .world-button .maze-stars {
          bottom: 11px;
          gap: 5px;
        }

        .maze-stars .star {
          width: 14px;
          height: 14px;
          background-size: cover;
        }

        .world-button .maze-stars .star {
          width: 18px;
          height: 18px;
        }

        .maze-stars .star.full {
          background-image: url('https://i.imgur.com/mJU2iIm.png');
        }

        .maze-stars .star.empty {
          background-image: url('https://i.imgur.com/M4FDVgp.png');
        }

        @media screen and (min-width: 800px) {
            #splash-content { padding: 0px 0; }
            #splash-top-image { max-height: 50vh; }
            #splash-start-button {
                max-height: 20vh;
            }
            #splash-info-button, #splash-settings-button {
                max-height: 12vh;
            }
            #splash-bottom-image {
                max-height: 100vh;
                padding-top: 30px;
                padding-bottom: 20px;
            }
        }
    </style>
</head>
<body>
        <div id="splash-screen">
            <div id="splash-content">
                <img id="splash-top-image" src="https://i.imgur.com/kG4NmSM.png" alt="Logotipo superior del splash" onerror="this.src='https://placehold.co/600x200/02030D/FFFFFF?text=Splash+Top+Error'; console.error('Error loading splash-top-image');">
                <div id="splash-button-row">
                    <img id="splash-info-button" src="https://i.imgur.com/rWe7Ylp.png" alt="Información inicial" onerror="this.src='https://placehold.co/80x80/02030D/FFFFFF?text=Info+Error'; console.error('Error loading splash-info-button');">
                    <img id="splash-start-button" src="https://i.imgur.com/HqNpn3w.png" alt="Botón de iniciar juego" onerror="this.src='https://placehold.co/300x100/02030D/FFFFFF?text=Start+Error'; console.error('Error loading splash-start-button');">
                    <img id="splash-settings-button" src="https://i.imgur.com/YIBroBG.png" alt="Ajustes generales" onerror="this.src='https://placehold.co/80x80/02030D/FFFFFF?text=Settings+Error'; console.error('Error loading splash-settings-button');">
                </div>
                <img id="splash-bottom-image" src="https://i.imgur.com/YJ1xHZO.png" alt="Imagen inferior del splash" onerror="this.src='https://placehold.co/600x150/02030D/FFFFFF?text=Splash+Bottom+Error'; console.error('Error loading splash-bottom-image');">
            </div>
        </div>

    <div class="game-container hidden">
        <div id="title-panel" class="hidden"><img id="title-image" src="https://i.imgur.com/CZa88Hk.png" alt="Snake Mobile" onerror="this.src='https://placehold.co/300x80/02030D/FFFFFF?text=Title+Error'; console.error('Error loading title-image');"></div>
        <div id="progress-panel" class="hidden">
            <div id="current-world-info-group">
                <span id="progress-panel-left-label" class="info-label">Nivel:</span> <span id="progress-panel-left-value" class="info-value">1</span> </div>
            <div id="star-progress-wrapper">
                 <div id="star-progress-container" class="hidden">
                 </div>
                 <div id="high-score-display" class="hidden">
                    <span id="hs-main-label" class="info-label">Máxima puntuación</span>
                    <div id="hs-values-container">
                        <span id="hs-score-value" class="hs-value">-</span>
                        <span class="hs-label-unit">Puntos</span>
                        <span class="hs-separator hs-value">|</span>
                        <span id="hs-skin-value" class="hs-value">-</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="play-area">

        <div id="top-info-bar">
            <div id="coins-info-group" class="info-group">
                <span class="info-label">Monedas:</span>
                <div class="flex items-center justify-center relative">
                    <svg class="coin-icon" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="9" fill="#FCD34D" stroke="#D97706" stroke-width="2" />
                    </svg>
                    <span id="coinValue" class="info-value">0</span>
                    <span id="earnedCoinsMessage" class="earned-coins-msg hidden">+0</span>
                </div>
            </div>
            <div id="points-info-group" class="info-group">
                <span class="info-label">Puntos:</span>
                <div class="flex items-center justify-center relative">
        <span id="livesValue" class="info-value absolute left-0 pl-3 hidden">5</span>
                    <span id="scoreValue" class="info-value">0</span>
                    <span id="target-score-divider" class="info-value mx-1 hidden">/</span>
                    <span id="targetScoreValue" class="info-value hidden">0</span>
                    <span id="lifeTimerValue" class="info-value hidden">Lleno</span>
                </div>
            </div>
            <div id="time-info-group" class="info-group">
                <span id="timeLengthLabel" class="info-label">Tiempo:</span>
                <span id="timeLengthValue" class="info-value">60</span>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        <button id="mode-left-button" class="mode-nav-button hidden" aria-label="Modo anterior">
            <img id="mode-left-button-icon" class="arrow-icon" src="https://i.imgur.com/pDjzolV.png" alt="Anterior" onerror="this.src='https://placehold.co/50x50/02030D/FFFFFF?text=Err';">
        </button>
        <button id="mode-right-button" class="mode-nav-button hidden" aria-label="Modo siguiente">
            <img id="mode-right-button-icon" class="arrow-icon" src="https://i.imgur.com/kwtquW9.png" alt="Siguiente" onerror="this.src='https://placehold.co/50x50/02030D/FFFFFF?text=Err';">
        </button>

        <div id="setup-controls"> 
        <div id="settings-panel" class="settings-panel-hidden">
                <div class="settings-header">
                    <div class="header-title-group">
                        <h2 id="settings-title"><img id="settings-title-img" src="https://i.imgur.com/IAfhEaH.png" alt="Configuración"></h2>
                        <button id="maze-info-button" class="setting-info-button hidden" data-setting="mazeLevel" aria-label="Información del modo laberinto">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                        <button id="world-info-button" class="setting-info-button hidden" aria-label="Información del mundo">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                        <button id="classification-info-button" class="setting-info-button hidden" aria-label="Información del modo clasificación" data-setting="difficulty">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <button id="close-settings-button" aria-label="Cerrar configuración">&times;</button>
                </div>
                <div class="panel-content">
                <div id="worldButtonsContainer" class="hidden flex flex-wrap justify-center gap-4"></div>
                <div id="mazeLevelButtonsContainer" class="hidden flex flex-wrap justify-center gap-4"></div>
                <div class="control-row" id="player-row">
                    <div id="player-select-control-group" class="control-group hidden">
                        <div class="control-label-icon-row">
                            <label class="control-label" for="playerNameSelector">Jugador:</label>
                            <button id="delete-player-name-button" class="setting-info-button" aria-label="Eliminar jugador">
                                <img class="setting-info-icon" src="https://i.imgur.com/w5E6xdU.png" alt="Eliminar" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                            </button>
                        </div>
                        <select id="playerNameSelector">
                            <option value="Snake" selected>Snake</option>
                            <option value="GamiSnake">GamiSnake</option>
                        </select>
                    </div>
                    <div id="add-player-control-group" class="control-group hidden">
                        <div class="control-label-icon-row">
                            <label class="control-label" for="newPlayerNameInput">Añadir</label>
                            <button id="confirm-add-player-button" class="setting-info-button" aria-label="Confirmar nuevo nombre">
                                <img class="setting-info-icon" src="https://i.imgur.com/ZGgSVye.png" alt="Añadir" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                            </button>
                        </div>
                        <input id="newPlayerNameInput" type="text" maxlength="10">
                    </div>
                </div>
                <div class="control-row" id="classification-select-row">
                    <div class="control-group" id="player-name-control-group">
                        <div class="control-label-icon-row">
                            <label class="control-label" for="playerNameSelector">Jugador:</label>
                            <button class="setting-info-button" data-setting="playerName" aria-label="Información sobre nombre del jugador">
                                <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                            </button>
                        </div>
                        <select id="playerNameSelector"></select>
                    </div>
                    <div class="control-group" id="difficulty-control-group">
                        <div class="control-label-icon-row">
                            <label class="control-label" id="difficulty-label" for="difficultySelector">Dificultad:</label>
                            <button id="difficulty-info-button" class="setting-info-button" data-setting="difficulty" aria-label="Información sobre dificultad">
                                <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                            </button>
                        </div>
                        <select id="difficultySelector">
                            <option value="principiante" selected>Novato</option>
                            <option value="explorador">Explorador</option>
                            <option value="veterano">Veterano</option>
                            <option value="legendario">Legendario</option>
                        </select>
                        <select id="worldsSelector" class="hidden">
                        </select>
                    </div>
                </div>
                <div class="control-group hidden" id="classification-ranking-group">
                    <table id="classification-ranking-table">
                        <thead>
                            <tr class="title-row">
                                <th colspan="4">CLASIFICACIÓN</th>
                            </tr>
                            <tr>
                                <th>Nº</th>
                                <th>PUNTOS</th>
                                <th>TIEMPO</th>
                                <th>JUGADOR</th>
                            </tr>
                        </thead>
                        <tbody id="classification-ranking-list"></tbody>
                    </table>
                </div>
                <div class="control-group" id="skin-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="skinSelector">Disfraz:</label>
                        <button class="setting-info-button" data-setting="skin" aria-label="Información sobre disfraces">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="skinSelector">
                        <option value="snake" selected>Snake</option>
                        <option value="rubiSnake">RubiSnake</option>
                        <option value="aitorSnake">AitorSnake</option>
                        <option value="noemiSnake">NoemiSnake</option>
                        <option value="maraSnake">MaraSnake</option>
                        <option value="almuSnake">AlmuSnake</option>
                        <option value="mimiSnake">MimiSnake</option>
                    </select>
                </div>
                <div class="control-group" id="food-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="foodSelector">Comestible:</label>
                        <button class="setting-info-button" data-setting="food" aria-label="Información sobre comestibles">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="foodSelector">
                        <option value="apple" selected>Manzana</option>
                        <option value="croqueta">Croqueta</option>
                        <option value="aguacate">Aguacate</option>
                        <option value="sushi">Sushi</option>
                        <option value="lotus">Lotus</option>
                        <option value="cerveza">Cerveza</option>
                        <option value="pan">Pan</option>
                        <option value="oreo">Oreo</option>
                    </select>
                </div>
                <div class="control-group" id="audio-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="audioToggleSelector">Audio General:</label>
                        <button class="setting-info-button" data-setting="audioGeneral" aria-label="Información sobre audio general">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="audioToggleSelector">
                        <option value="all" selected>Activado</option>
                        <option value="music_only">Sólo Música</option>
                        <option value="sfx_only">Sólo Efectos</option>
                        <option value="off">Desactivado</option>
                    </select>
                </div>
                <div class="control-group" id="music-volume-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="musicVolumeSlider">Volumen Música: <span id="musicVolumeValue">50</span>%</label>
                        <button class="setting-info-button" data-setting="musicVolume" aria-label="Información sobre volumen de música">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <input type="range" id="musicVolumeSlider" min="0" max="100" value="50">
                </div>
                <div class="control-group" id="sfx-volume-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="sfxVolumeSlider">Volumen Efectos: <span id="sfxVolumeValue">75</span>%</label>
                        <button class="setting-info-button" data-setting="sfxVolume" aria-label="Información sobre volumen de efectos">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <input type="range" id="sfxVolumeSlider" min="0" max="100" value="75">
                </div>
                <div class="control-group" id="resetDataButton">Reiniciar datos del juego</div>
                </div>
            </div>

            <div id="free-settings-panel" class="free-settings-panel-hidden">
                <div class="settings-header">
                    <h2>Personaliza tu juego</h2>
                    <button id="close-free-settings-button" aria-label="Cerrar ajustes">&times;</button>
                </div>
                <div class="panel-content">
                <div class="control-group" id="free-difficulty-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="free-difficulty-selector">Configuración:</label>
                        <button id="free-difficulty-info-button" class="setting-info-button" data-setting="freeDifficulty" aria-label="Información sobre dificultad libre">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="free-difficulty-selector">
                        <option value="personalizado" selected>Personalizado</option>
                        <option value="principiante">Novato</option>
                        <option value="explorador">Explorador</option>
                        <option value="veterano">Veterano</option>
                        <option value="legendario">Legendario</option>
                    </select>
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="playerNameSelector">Jugador:</label>
                        <button class="setting-info-button" data-setting="playerName" aria-label="Información sobre nombre del jugador">
                            <img class="setting-info-icon" src="https://i.imgur.com/rWe7Ylp.png" alt="info" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                        </button>
                    </div>
                    <select id="playerNameSelector"></select>
                </div>
                <div class="control-group">
                    <label class="control-label" for="free-speed-input">Velocidad: <span id="free-speed-value">67</span>%</label>
                    <input type="range" class="settings-range" id="free-speed-input" min="0" max="100" step="5" value="67">
                </div>
                <div class="control-group">
                    <label class="control-label" for="free-length-input">Tamaño inicial: <span id="free-length-value">10</span></label>
                    <input type="range" class="settings-range" id="free-length-input" min="3" max="50" value="10">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Comida dorada (x2)</label>
                        <label class="switch"><input type="checkbox" id="free-golden-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-golden-chance-input">Probabilidad: <span id="free-golden-chance-value">10</span>%</label>
                    <input type="range" class="settings-range" id="free-golden-chance-input" min="5" max="100" step="5" value="10">
                    <label class="control-label" for="free-golden-lifespan-input">Duración(s): <span id="free-golden-lifespan-value">4</span></label>
                    <input type="range" class="settings-range" id="free-golden-lifespan-input" min="4" max="8" step="0.5" value="4">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Rayos (+Velocidad)</label>
                        <label class="switch"><input type="checkbox" id="free-lightning-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-lightning-range">Intervalo(s): <span id="free-lightning-range-display">4 - 8</span></label>
                    <input type="range" class="settings-range" id="free-lightning-range" min="0" max="16" step="0.5" value="4">
                    <label class="control-label" for="free-lightning-lifespan">Duración(s): <span id="free-lightning-lifespan-value">5</span></label>
                    <input type="range" class="settings-range" id="free-lightning-lifespan" min="4" max="10" step="0.5" value="5">
                    <label class="control-label" for="free-red-chance">Probabilidad SuperRayo: <span id="free-red-chance-value">25</span>%</label>
                    <input type="range" class="settings-range" id="free-red-chance" min="0" max="100" step="5" value="25">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Desaparición comida</label>
                        <label class="switch"><input type="checkbox" id="free-lifespan-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-lifespan-input">Tiempo(s): <span id="free-lifespan-value">7.5</span></label>
                    <input type="range" class="settings-range" id="free-lifespan-input" min="4" max="8" step="0.5" value="7.5">
                </div>
                <div class="control-group" id="streak-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Racha (x1 - x5)</label>
                        <label class="switch"><input type="checkbox" id="free-streak-toggle" checked><span class="slider round"></span></label>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Comida falsa</label>
                        <label class="switch"><input type="checkbox" id="free-false-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-false-range">Intervalo(s): <span id="free-false-range-display">4 - 8</span></label>
                    <input type="range" class="settings-range" id="free-false-range" min="0" max="16" step="0.5" value="4">
                    <label class="control-label" for="free-false-lifespan">Duración(s): <span id="free-false-lifespan-value">5</span></label>
                    <input type="range" class="settings-range" id="free-false-lifespan" min="4" max="10" step="0.5" value="5">
                </div>
                <div class="control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label">Espejos</label>
                        <label class="switch"><input type="checkbox" id="free-mirror-toggle" checked><span class="slider round"></span></label>
                    </div>
                    <label class="control-label" for="free-mirror-range">Intervalo(s): <span id="free-mirror-range-display">4 - 8</span></label>
                    <input type="range" class="settings-range" id="free-mirror-range" min="0" max="16" step="0.5" value="4">
                    <label class="control-label" for="free-mirror-lifespan">Duración(s): <span id="free-mirror-lifespan-value">5</span></label>
                    <input type="range" class="settings-range" id="free-mirror-lifespan" min="4" max="10" step="0.5" value="5">
                    <label class="control-label" for="free-mirror-effect">Duración efecto(s): <span id="free-mirror-effect-value">3</span></label>
                    <input type="range" class="settings-range" id="free-mirror-effect" min="3" max="10" step="0.5" value="3">
                </div>
                <div class="control-group">
                    <label class="control-label" for="free-obstacle-count">Obstáculos: <span id="free-obstacle-count-value">5</span></label>
                    <input type="range" class="settings-range" id="free-obstacle-count" min="0" max="50" value="5">
                </div>
                <div class="control-group" id="apply-free-settings-bottom">Guardar</div>
                </div>
            </div>

            <div id="info-panel" class="info-panel-hidden">
                <div class="info-header">
                    <h2 id="main-info-title"><img src="https://i.imgur.com/CZa88Hk.png" alt="Snake Mobile" onerror="this.src='https://placehold.co/300x80/02030D/FFFFFF?text=Title+Error'; console.error('Error loading main-info-title image');"></h2>
                    <button id="close-info-button" aria-label="Cerrar información">&times;</button>
                </div>
                <div id="info-panel-content">
                    <p>¡Prepárate para la clásica diversión de la serpiente con un toque moderno y desafiante!¡Cada partida es una nueva oportunidad para superarte!</p>

                    <h4>Cómo Jugar</h4>
                    <p>Tan fácil como utilizar los controles en pantalla (En PC las flechas de dirección o "WASD") para guiar a tu serpiente. Devora comida, crece lo máximo posible, suma puntos y acumula monedas que te permitirán desbloquear increíbles recompensas. ¡Pero cuidado! No choques contra tu propio cuerpo o la partida terminará. </p>

                    <h4>Tipos de juego</h4>
                    <p>Accede a la pantalla principal para conocer los diferentes tipos de juego: <strong>Aventura</strong>, <strong>Laberinto</strong>, <strong>Clasificación</strong> y <strong>Libre</strong>. Para más información, puedes pulsar sobre los iconos que te irás encontrando durante el juego.</p>
                    <p style="text-align: center; margin-top: 6px;"><strong>¡Diviértete y que crezca la serpiente!</strong></p>
                </div>
            </div>

            <div id="specific-info-panel" class="specific-info-panel-hidden">
                <div class="specific-info-header">
                    <h2 id="specific-info-title">Detalle del Ajuste</h2>
                    <button id="close-specific-info-button" aria-label="Cerrar detalle">&times;</button>
                </div>
                <div id="specific-info-content">
                 </div>
            </div>
            <div id="reset-confirmation-panel" class="reset-panel-hidden">
                <div class="reset-header">
                    <h2>Reiniciar</h2>
                </div>
                <div class="panel-content">
                    <p>Esta decisión eliminará todos tus progresos y puntuaciones</p>
                    <p>¿Estás seguro de que deseas eliminar todos los datos del juego?</p>
                    <div class="reset-buttons">
                        <button id="confirmResetYes">Sí</button>
                        <button id="confirmResetNo">No</button>
                    </div>
                </div>
            </div>

            <div class="control-row" id="action-buttons-row">
                    <button id="backButton" aria-label="Volver">
                        <img id="backButtonIcon" src="https://i.imgur.com/1WrBpTQ.png" alt="Volver" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                    </button>
                <div class="action-button-wrapper" id="start-button-wrapper">
                    <button id="startButton">Empezar</button>
                    <button id="restartMazeButton" class="hidden" aria-label="Reiniciar">
                        <img id="restartMazeButtonIcon" src="https://i.imgur.com/i4m4tSV.png" alt="Reiniciar"
                             onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                    </button>
                </div>
                <button id="configButton" aria-label="Configuración">
                    <img id="configButtonIcon" src="https://i.imgur.com/9HHOgFe.png" alt="Configuración" onerror="this.src='https://placehold.co/24x24/02030D/FFFFFF?text=Err';">
                </button>
            </div>
        </div>
        </div>
        
        <div id="mobile-controls">
            <div id="d-pad-container">
                <button id="up-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
                </button>
                <button id="left-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M15.41 7.41L10.83 12l4.58 4.59L14 18l-6-6 6-6z"/></svg>
                </button>
                <button id="right-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                </button>
                <button id="down-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </button>
            </div>
        </div>

        </div>

    <script>
        // Helper function to adjust hex color by a percentage (lighten)
        function adjustColor(hex, percent) {
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);

            // Add white (lighten)
            r = Math.round(r + (255 - r) * percent);
            g = Math.round(g + (255 - g) * percent);
            b = Math.round(b + (255 - b) * percent);

            r = Math.min(255, Math.max(0, r));
            g = Math.min(255, Math.max(0, g));
            b = Math.min(255, Math.max(0, b));

            const toHex = (c) => {
                const hexVal = c.toString(16);
                return hexVal.length === 1 ? "0" + hexVal : hexVal;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // Draws an image tinted with a given color onto the main context
        function drawImageWithTint(ctx, img, x, y, w, h, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tctx = tempCanvas.getContext('2d');
            tctx.drawImage(img, 0, 0, w, h);
            tctx.globalCompositeOperation = 'source-atop';
            tctx.fillStyle = color;
            tctx.fillRect(0, 0, w, h);
            tctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(tempCanvas, x, y);
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Selección de elementos del DOM
        const splashScreen = document.getElementById("splash-screen"); 
        const canvasEl = document.getElementById("gameCanvas"); 
        let ctx; 
        const gameContainer = document.querySelector('.game-container'); 
        const coinValueDisplay = document.getElementById("coinValue");
        const earnedCoinsMessage = document.getElementById("earnedCoinsMessage");
        const scoreValueDisplay = document.getElementById("scoreValue");
        const livesValueDisplay = document.getElementById("livesValue");
        const lifeTimerValueDisplay = document.getElementById("lifeTimerValue");
        const targetScoreDivider = document.getElementById("target-score-divider");
        const targetScoreValueDisplay = document.getElementById("targetScoreValue");
        const timeLengthLabelEl = document.getElementById("timeLengthLabel");
        const timeLengthValueEl = document.getElementById("timeLengthValue");
        const startButton = document.getElementById("startButton");
        const restartMazeButton = document.getElementById("restartMazeButton");
        const restartMazeButtonIcon = document.getElementById("restartMazeButtonIcon");
        const startButtonWrapperEl = document.getElementById("start-button-wrapper");
        const difficultySelector = document.getElementById("difficultySelector");
        const worldsSelector = document.getElementById("worldsSelector");
        const worldButtonsContainer = document.getElementById("worldButtonsContainer");
        const mazeLevelButtonsContainer = document.getElementById("mazeLevelButtonsContainer");
        const difficultyLabel = document.getElementById("difficulty-label");
        const settingsTitleImg = document.getElementById("settings-title-img");
        const audioToggleSelector = document.getElementById("audioToggleSelector");
        const skinSelector = document.getElementById("skinSelector");
        const foodSelector = document.getElementById("foodSelector");
        const playerNameSelectors = document.querySelectorAll("#playerNameSelector");
        const confirmAddPlayerButton = document.getElementById("confirm-add-player-button");
        const deletePlayerNameButton = document.getElementById("delete-player-name-button");
        const newPlayerNameInput = document.getElementById("newPlayerNameInput");
        const playerSelectControlGroup = document.getElementById("player-select-control-group");
        const playerNameControlGroup = document.getElementById("player-name-control-group");
        const addPlayerControlGroup = document.getElementById("add-player-control-group");
        const difficultyControlGroup = document.getElementById("difficulty-control-group");
        const audioControlGroup = document.getElementById("audio-control-group");
        const skinControlGroup = document.getElementById("skin-control-group");
        const foodControlGroup = document.getElementById("food-control-group");
        const sfxVolumeSlider = document.getElementById("sfxVolumeSlider");
        const sfxVolumeValue = document.getElementById("sfxVolumeValue");
        const sfxVolumeControlGroup = document.getElementById("sfx-volume-control-group");
        const musicVolumeSlider = document.getElementById("musicVolumeSlider");
        const musicVolumeValue = document.getElementById("musicVolumeValue");
        const musicVolumeControlGroup = document.getElementById("music-volume-control-group");
        const classificationRankingGroup = document.getElementById("classification-ranking-group");
        const classificationRankingList = document.getElementById("classification-ranking-list");

        const difficultyInfoButton = document.getElementById("difficulty-info-button");
        const worldInfoButton = document.getElementById("world-info-button");
        if (worldInfoButton) worldInfoButton.removeAttribute('data-setting');
        const mazeInfoButton = document.getElementById("maze-info-button");
        const classificationInfoButton = document.getElementById("classification-info-button");
        
        const progressPanel = document.getElementById("progress-panel");
        const titlePanel = document.getElementById("title-panel"); 
        const progressPanelLeftLabel = document.getElementById("progress-panel-left-label");
        const progressPanelLeftValue = document.getElementById("progress-panel-left-value");
        const starProgressContainer = document.getElementById("star-progress-container");
        const highScoreDisplay = document.getElementById("high-score-display");
        const hsScoreValue = document.getElementById("hs-score-value");
        // Se obtendrá hsSkinValue dentro de la función displayHighScoreInPanel

        const currentWorldInfoGroup = document.getElementById("current-world-info-group");


        const upButton = document.getElementById("up-button");
        const leftButton = document.getElementById("left-button");
        const downButton = document.getElementById("down-button");
        const rightButton = document.getElementById("right-button");
        const settingsPanel = document.getElementById("settings-panel");
        const freeSettingsPanel = document.getElementById("free-settings-panel");
        const configButton = document.getElementById("configButton");
        const configButtonIcon = document.getElementById("configButtonIcon");
        const closeSettingsButton = document.getElementById("close-settings-button");
        const closeFreeSettingsButton = document.getElementById("close-free-settings-button");
        const applyFreeSettingsBottomButton = document.getElementById("apply-free-settings-bottom");
        const freeDifficultySelector = document.getElementById("free-difficulty-selector");

        const backButton = document.getElementById("backButton");
        const backButtonIcon = document.getElementById("backButtonIcon");
        const infoPanel = document.getElementById("info-panel");
        const infoPanelContent = document.getElementById("info-panel-content");
        const closeInfoButton = document.getElementById("close-info-button");
        const topInfoBar = document.getElementById('top-info-bar');
        const setupControls = document.getElementById('setup-controls');
        const actionButtonsRow = document.getElementById('action-buttons-row');

        const resetDataButton = document.getElementById("resetDataButton");
        const resetConfirmPanel = document.getElementById("reset-confirmation-panel");
        const confirmResetYesButton = document.getElementById("confirmResetYes");
        const confirmResetNoButton = document.getElementById("confirmResetNo");

        const settingsPanelContent = settingsPanel.querySelector('.panel-content');
        const freeSettingsPanelContent = freeSettingsPanel.querySelector('.panel-content');
        const resetConfirmPanelContent = resetConfirmPanel.querySelector('.panel-content');

        const modeLeftButton = document.getElementById("mode-left-button");
        const modeRightButton = document.getElementById("mode-right-button");
        const modeLeftButtonIcon = document.getElementById("mode-left-button-icon");
        const modeRightButtonIcon = document.getElementById("mode-right-button-icon");

        // New DOM elements for specific info panel
        const specificInfoPanel = document.getElementById("specific-info-panel");
        const specificInfoTitle = document.getElementById("specific-info-title");
        const specificInfoContent = document.getElementById("specific-info-content");
        const closeSpecificInfoButton = document.getElementById("close-specific-info-button");

        const freeSpeedInput = document.getElementById("free-speed-input");
        const freeSpeedValue = document.getElementById("free-speed-value");
        const freeLifespanInput = document.getElementById("free-lifespan-input");
        const freeLifespanValue = document.getElementById("free-lifespan-value");
        const freeLifespanToggle = document.getElementById("free-lifespan-toggle");
        const freeLengthInput = document.getElementById("free-length-input");
        const freeLengthValue = document.getElementById("free-length-value");
        const freeGoldenChanceInput = document.getElementById("free-golden-chance-input");
        const freeGoldenChanceValue = document.getElementById("free-golden-chance-value");
        const freeGoldenLifespanInput = document.getElementById("free-golden-lifespan-input");
        const freeGoldenLifespanValue = document.getElementById("free-golden-lifespan-value");
        const freeGoldenToggle = document.getElementById("free-golden-toggle");
        const freeLightningRange = document.getElementById("free-lightning-range");
        const freeLightningRangeDisplay = document.getElementById("free-lightning-range-display");
        const freeLightningLifespan = document.getElementById("free-lightning-lifespan");
        const freeLightningLifespanValue = document.getElementById("free-lightning-lifespan-value");
        const freeRedChance = document.getElementById("free-red-chance");
        const freeRedChanceValue = document.getElementById("free-red-chance-value");
        const freeLightningToggle = document.getElementById("free-lightning-toggle");
        const freeStreakToggle = document.getElementById("free-streak-toggle");
        const freeFalseRange = document.getElementById("free-false-range");
        const freeFalseRangeDisplay = document.getElementById("free-false-range-display");
        const freeFalseLifespan = document.getElementById("free-false-lifespan");
        const freeFalseLifespanValue = document.getElementById("free-false-lifespan-value");
        const freeFalseToggle = document.getElementById("free-false-toggle");
        const freeMirrorRange = document.getElementById("free-mirror-range");
        const freeMirrorRangeDisplay = document.getElementById("free-mirror-range-display");
        const freeMirrorLifespan = document.getElementById("free-mirror-lifespan");
        const freeMirrorLifespanValue = document.getElementById("free-mirror-lifespan-value");
        const freeMirrorEffect = document.getElementById("free-mirror-effect");
        const freeMirrorEffectValue = document.getElementById("free-mirror-effect-value");
        const freeMirrorToggle = document.getElementById("free-mirror-toggle");
        const freeObstacleCount = document.getElementById("free-obstacle-count");
        const freeObstacleCountValue = document.getElementById("free-obstacle-count-value");
        const freeObstacleGroup = freeObstacleCount ? freeObstacleCount.closest('.control-group') : null;

function setupSlider(slider, display) {
    if (slider && display) {
        slider.addEventListener('input', () => { display.textContent = slider.value; });
        display.textContent = slider.value;
    }
}

        function setupRangeSlider(slider, display) {
            if (slider && display) {
                const update = () => {
                    const val = parseFloat(slider.value);
                    display.textContent = `${val} - ${val + 4}`;
                };
                slider.addEventListener('input', update);
                update();
            }
        }

        function setupToggle(toggle, inputs) {
            if (!toggle) return;
            const arr = Array.isArray(inputs) ? inputs : [inputs];
            const container = toggle.closest('.control-group');
            const update = () => {
                arr.forEach(inp => { if (inp) inp.disabled = !toggle.checked; });
                if (container) {
                    container.classList.toggle('dimmed', !toggle.checked);
                }
            };
            toggle.addEventListener('change', update);
            update();
        }

        setupSlider(freeSpeedInput, freeSpeedValue);
        setupSlider(freeLifespanInput, freeLifespanValue);
        setupSlider(freeLengthInput, freeLengthValue);
        setupSlider(freeGoldenChanceInput, freeGoldenChanceValue);
        setupSlider(freeGoldenLifespanInput, freeGoldenLifespanValue);
        setupRangeSlider(freeLightningRange, freeLightningRangeDisplay);
        setupSlider(freeLightningLifespan, freeLightningLifespanValue);
        setupSlider(freeRedChance, freeRedChanceValue);
        setupRangeSlider(freeFalseRange, freeFalseRangeDisplay);
        setupSlider(freeFalseLifespan, freeFalseLifespanValue);
        setupRangeSlider(freeMirrorRange, freeMirrorRangeDisplay);
        setupSlider(freeMirrorLifespan, freeMirrorLifespanValue);
        setupSlider(freeMirrorEffect, freeMirrorEffectValue);
        setupSlider(freeObstacleCount, freeObstacleCountValue);
        if (freeObstacleCount && freeObstacleGroup) {
            const updateObstacleGroup = () => {
                if (freeObstacleGroup) {
                    freeObstacleGroup.classList.toggle('dimmed', parseInt(freeObstacleCount.value, 10) === 0);
                }
            };
            freeObstacleCount.addEventListener('input', updateObstacleGroup);
            updateObstacleGroup();
        }

        setupToggle(freeLifespanToggle, freeLifespanInput);
        setupToggle(freeGoldenToggle, [freeGoldenChanceInput, freeGoldenLifespanInput]);
        setupToggle(freeLightningToggle, [freeLightningRange, freeLightningLifespan, freeRedChance]);
        setupToggle(freeStreakToggle);
        setupToggle(freeFalseToggle, [freeFalseRange, freeFalseLifespan]);
        setupToggle(freeMirrorToggle, [freeMirrorRange, freeMirrorLifespan, freeMirrorEffect]);


        function updateFreeSettingsLockState() {
            if (!freeSettingsPanelContent) return;
            const isCustom = freeDifficulty === 'personalizado';
            const groups = freeSettingsPanelContent.querySelectorAll('.control-group');
            groups.forEach(g => {
                if (g.id === 'free-difficulty-control-group') return;
                g.classList.toggle('dimmed', !isCustom);
                g.querySelectorAll('input, select, button.setting-info-button').forEach(el => {
                    if (el.classList.contains("setting-info-button") && el.dataset.setting === "playerName") return;
                    el.disabled = !isCustom;
                });
            });
            if (applyFreeSettingsBottomButton) {
                applyFreeSettingsBottomButton.classList.toggle('dimmed', !isCustom);
                applyFreeSettingsBottomButton.disabled = !isCustom;
            }
        }


        // --- INICIO: Declaración de Objetos Image ---
        const classicSnakeHeadLeftImg = new Image(); 
        const classicSnakeHeadDownImg = new Image(); 
        const classicFoodImg = new Image();
        const snakeBodyTexture = new Image(); 

        const rubiSnakeHeadUpDownImg = new Image();
        const rubiSnakeHeadLeftImg = new Image();
        const rubiSnakeFoodImg = new Image();

        const aitorSnakeHeadUpDownImg = new Image();
        const aitorSnakeHeadLeftImg = new Image();
        const aitorSnakeFoodImg = new Image();

        const noemiSnakeHeadUpDownImg = new Image();
        const noemiSnakeHeadLeftImg = new Image();
        const noemiSnakeFoodImg = new Image();

        const maraSnakeHeadUpDownImg = new Image();
        const maraSnakeHeadLeftImg = new Image();
        const maraSnakeFoodImg = new Image();

        const almuSnakeHeadUpDownImg = new Image(); 
        const almuSnakeHeadLeftImg = new Image();   
        const almuSnakeFoodImg = new Image();   

        const mimiSnakeHeadUpDownImg = new Image();
        const mimiSnakeHeadLeftImg = new Image();
        const mimiSnakeFoodImg = new Image();

        const oreoFoodImg = new Image();
        const obstacleImg = new Image();
        const lightningYellowImg = new Image();
        const lightningRedImg = new Image();

        const mazeModeCoverImg = new Image();
        const mazeLevelCoverImg = new Image();
        const mazeFailImg = new Image();
        const mazePartialImg = new Image();
        const mazePerfectImg = new Image();
        const mazeCompleteImg = new Image();
        const mazeFinalImg = new Image();
        const mazeAllStarsImg = new Image();
        const timeoutImg = new Image();
        const starFullImg = new Image();
        const starEmptyImg = new Image();

        const worldCoverImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const worldCompleteImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const levelCompleteImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const defeatImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const freeModeCoverImg = new Image();
        const freeModeEndImg = new Image();
        const freeModeInactivityImg = new Image();
        const classificationModeCoverImg = new Image();
        const classificationDifficultyImages = {
            principiante: new Image(),
            explorador: new Image(),
            veterano: new Image(),
            legendario: new Image()
        };
        const modeSelectIntroImg = new Image();
        const modeSelectLevelsImg = new Image();
        const modeSelectFreeImg = new Image();
        const modeSelectClassificationImg = new Image();
        const modeSelectMazeImg = new Image();

        const worldImagesConfig = {
            1: { cover: 'https://i.imgur.com/XuoZro6.png', complete: 'https://i.imgur.com/pw2ebzf.png', level: 'https://i.imgur.com/gijG9ec.png', defeat: 'https://i.imgur.com/FZTIteF.png' },
            2: { cover: 'https://i.imgur.com/RUDshhv.png', complete: 'https://i.imgur.com/mkxGkJA.png', level: 'https://i.imgur.com/aXJoj0F.png', defeat: 'https://i.imgur.com/4DPMHU2.png' },
            3: { cover: 'https://i.imgur.com/fMBXP4Z.png', complete: 'https://i.imgur.com/aYOQ8Gx.png', level: 'https://i.imgur.com/WUfSzpY.png', defeat: 'https://i.imgur.com/0OmpfWR.png' },
            4: { cover: 'https://i.imgur.com/3bpQJ2c.png', complete: 'https://i.imgur.com/TRmh4s7.png', level: 'https://i.imgur.com/2ZlgclU.png', defeat: 'https://i.imgur.com/Y4kPsNM.png' },
            5: { cover: 'https://i.imgur.com/EYXaoSC.png', complete: 'https://i.imgur.com/R79ud6T.png', level: 'https://i.imgur.com/YULiGZW.png', defeat: 'https://i.imgur.com/yiH7BqX.png' },
            6: { cover: 'https://i.imgur.com/TUUOl01.png', complete: 'https://i.imgur.com/NXcBoXQ.png', level: 'https://i.imgur.com/bUUIGGt.png', defeat: 'https://i.imgur.com/iYpiKB7.png' },
            7: { cover: 'https://i.imgur.com/vEqjfil.png', complete: 'https://i.imgur.com/paNousf.png', level: 'https://i.imgur.com/GniQn3h.png', defeat: 'https://i.imgur.com/3FilGNV.png' },
            8: { cover: 'https://i.imgur.com/e1PtokJ.png', complete: 'https://i.imgur.com/TI5ptAd.png', level: 'https://i.imgur.com/YtiDSF1.png', defeat: 'https://i.imgur.com/ADe82lc.png' },
            9: { cover: 'https://i.imgur.com/DNGzDhl.png', complete: 'https://i.imgur.com/PlPwmLh.png', level: 'https://i.imgur.com/IY7T8Jm.png', defeat: 'https://i.imgur.com/6Bc4w92.png' },
            10: { cover: 'https://i.imgur.com/g3uQW4f.png', complete: 'https://i.imgur.com/rFUKAbD.png', level: 'https://i.imgur.com/7iK51vy.png', defeat: 'https://i.imgur.com/dd6Zkda.png' }
        };

        let worldImagesLoaded = 0;
        const totalWorldImagesToLoad = Object.keys(worldImagesConfig).length * 4 + 17;
        // --- FIN: Declaración de Objetos Image ---

        // --- Música de fondo y SFX ---
        let generalBackgroundMusic; 
        let inGameBackgroundMusic;  
        const generalBackgroundMusicURL = 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/1ffc16f7db7280cf31d5e7209c5c23e7d533d1e3/Instrumental%20fondo%20-%20Recuerdos%20Pixelados%20(1).mp3';
        const inGameBackgroundMusicURL = 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Valle%20del%20despertar%20-%20Serpiente%20de%20Ne%C3%B3n.mp3';

        const WORLD_MUSIC_URLS = {
            1: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Valle%20del%20despertar%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            2: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Cueva%20del%20crecimiento%20-%20La%20Serpiente%20de%20Ne%C3%B3n.mp3',
            3: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Templo%20de%20la%20Agilidad-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            4: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Hambre%20Voraz%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            5: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Doble%20o%20nada%2C%20comestibles%20dorados%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            6: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Racha%20demoledora%20-%20La%20serpiente%20de%20ne%C3%B3n.mp3',
            7: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Bosque%20de%20los%20enga%C3%B1os%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            8: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Jard%C3%ADn%20de%20los%20Peligros%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            9: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Lago%20del%20Reflejo%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            10:'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Final%20Inesperado%20-%20serpiente%20de%20ne%C3%B3n.mp3'
        };

        const MODE_MUSIC_URLS = {
            maze: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/9705ce5b286f197add7dd7f2bb767edf09594ef9/Serpiente%20de%20Ne%C3%B3n%20(3).mp3',
            freeMode: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/bc07b0e83b7df448cb82a9a6b8a5ae4196d06758/Modo%20libre%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            classification: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/ecfea23c17b11d743d5bade6b5ef8e025ea1fff6/Modo%20clasificaci%C3%B3n%20-%20Serpiente%20de%20Ne%C3%B3n.mp3'
        };
        let synthSplashStart; 
        const MAX_ACTUAL_SLIDER_MAPPED_VOLUME = 0.5;


        // Configuración del juego
        let GRID_SIZE = 20;
        const TILE_COUNT = 20;
        let tileCountX = TILE_COUNT;
        let tileCountY = TILE_COUNT;
        const DEFAULT_INITIAL_SNAKE_LENGTH = 3; // Used for free mode
        let initialSnakeLength = DEFAULT_INITIAL_SNAKE_LENGTH;
        const MAX_STREAK = 5;
        const STREAK_ANIMATION_DURATION = 1000; // ms that streak value is shown above head
        
        // Mapping for difficulty display names
        const DIFFICULTY_DISPLAY_NAMES = {
            personalizado: "Personalizado",
            principiante: "Novato",
            explorador: "Explorador",
            veterano: "Veterano",
            legendario: "Legendario"
        };

        // Mapping para nombres de jugadores en el ranking
        const SKIN_DISPLAY_NAMES = {
            snake: "Snake",
            Snake: "Snake",
            rubiSnake: "RubiSnake",
            aitorSnake: "AitorSnake",
            noemiSnake: "NoemiSnake",
            maraSnake: "MaraSnake",
            almuSnake: "AlmuSnake",
            mimiSnake: "MimiSnake"
        };

        // Nombres descriptivos de cada mundo
        const WORLD_DISPLAY_NAMES = [
            "Valle del Despertar",
            "Cueva del Crecimiento",
            "Templo de la Agilidad",
            "Hambre Voraz",
            "Doble o nada",
            "Racha demoledora",
            "Bosque de los Engaños",
            "Jardín de los Peligros",
            "Lago del Reflejo",
            "Final Inesperado"
        ];


        // --- LEVELS MODE CONFIG ---
        const LEVELS_PER_WORLD = 5;
        const TOTAL_WORLDS = 10;
        const LEVEL_TIME_LIMIT = 60000;
        const TARGET_SCORES_LEVELS = [
            // World 1
            25, 50, 100, 150, 200,
            // World 2
            25, 50, 100, 150, 200,
            // World 3
            50, 100, 150, 200, 250,
            // World 4
            50, 100, 150, 200, 250,
            // World 5
            100, 150, 200, 250, 300,
            // World 6
            200, 300, 400, 500, 600,
            // World 7
            200, 300, 400, 500, 600,
            // World 8
            300, 400, 500, 600, 700,
            // World 9
            300, 400, 500, 600, 700,
            // World 10
            400, 500, 600, 700, 800,
        ];

        // Star thresholds for Maze Mode (puntos objetivo para cada estrella)
        const MAZE_STAR_TARGETS = [25, 50, 100, 150, 200];
        let mazeStarsEarned = 0;

        const MAZE_LEVEL_COUNT = 10;
        let currentMazeLevel = 1;
        let mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
        let mazePreviousStars = 0; // Stars achieved before starting the current run

        const MAZE_LAYOUTS = {
            // Nivel 1 - bloques en las esquinas
            1: [
                { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 },
                { x: 18, y: 0 }, { x: 19, y: 0 }, { x: 19, y: 1 },
                { x: 0, y: 18 }, { x: 0, y: 19 }, { x: 1, y: 19 },
                { x: 19, y: 18 }, { x: 19, y: 19 }, { x: 18, y: 19 }
            ],
            // Nivel 2 - cuatro bloques centrales de 2x2
            2: [
                { x: 5, y: 5 }, { x: 6, y: 5 }, { x: 5, y: 6 }, { x: 6, y: 6 },
                { x: 13, y: 5 }, { x: 14, y: 5 }, { x: 13, y: 6 }, { x: 14, y: 6 },
                { x: 5, y: 13 }, { x: 6, y: 13 }, { x: 5, y: 14 }, { x: 6, y: 14 },
                { x: 13, y: 13 }, { x: 14, y: 13 }, { x: 13, y: 14 }, { x: 14, y: 14 }
            ],
            // Nivel 3 - cruz que divide en cuadrantes
            3: (() => {
                const res = [];
                for (let i = 0; i < 12; i++) res.push({ x: i + 4, y: 10 });
                for (let i = 0; i < 12; i++) res.push({ x: 10, y: i + 4 });
                return res;
            })(),
            // Nivel 4 - dos muros verticales con hueco central
            4: (() => {
                const res = [];
                for (let y = 1; y < 19; y++) { if (y !== 9 && y !== 10) res.push({ x: 6, y }); }
                for (let y = 1; y < 19; y++) { if (y !== 9 && y !== 10) res.push({ x: 13, y }); }
                return res;
            })(),
            // Nivel 5 - rectángulo interior con aperturas en cruz
            5: (() => {
                const res = [];
                for (let i = 0; i < 10; i++) { const x = 5 + i; if (x !== 10) res.push({ x, y: 5 }); }
                for (let i = 0; i < 10; i++) { const x = 5 + i; if (x !== 10) res.push({ x, y: 14 }); }
                for (let i = 0; i < 8; i++) { const y = 6 + i; if (y !== 10) res.push({ x: 5, y }); }
                for (let i = 0; i < 8; i++) { const y = 6 + i; if (y !== 10) res.push({ x: 14, y }); }
                return res;
            })(),
            // Nivel 6 - muro vertical con bordes izquierdo e inferior
            6: (() => {
                const res = [];
                for (let x = 0; x < 20; x++) {
    if (x !== 10) res.push({ x, y: 19 });  // bordes inferior, omite x=10
};
                for (let y = 0; y < 20; y++) {
    if (y !== 10) res.push({ x: 0, y });   // borde izquierdo, omite y=10
};
                for (let y = 5; y <= 9; y++) res.push({ x: 10, y });
                for (let y = 11; y <= 15; y++) res.push({ x: 10, y });
                return res;
            })(),
            // Nivel 7 - marco alrededor de los bordes con dos líneas horizontales
            7: (() => {
                const res = [];
                for (let i=0;i<20;i++) {
                    if (i !== 10) {
                        res.push({ x: i, y: 0 });
                        res.push({ x: i, y: 19 });
                    }
                }
                for (let i=1;i<19;i++) {
                    if (i !== 10) { res.push({x:0,y:i}); res.push({x:19,y:i}); }
                }
                for (let i=0;i<12;i++) { const x = i+4; if (x !== 10) res.push({ x, y: 8 }); }
                for (let i=0;i<12;i++) { const x = i+4; if (x !== 10) res.push({ x, y: 12 }); }
                return res;
            })(),
            // Nivel 8 - líneas horizontales y verticales desplazadas
            8: (() => {
                const res = [];
                for (let y = 0; y <= 9; y++) res.push({ x: 5, y });
                for (let y = 11; y <= 19; y++) res.push({ x: 15, y });
                for (let x = 0; x <= 10; x++) res.push({ x, y: 13 });
                for (let x = 10; x <= 19; x++) res.push({ x, y: 7 });
                return res;
            })(),
            // Nivel 9 - franjas horizontales
            9: (() => {
                const res = [];
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 4 });
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 8 });
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 12 });
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 16 });
                return res;
            })(),
            // Nivel 10 - franjas horizontales con Marco exterior con huecos
            10: (() => {
                const res = [];
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 4 });
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 8 });
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 12 });
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 16 });
            // Marco exterior con huecos
                for (let i = 0; i < 20; i++) { if (i !== 1 && i !== 18)  res.push({ x: i,  y: 0  }); }  // arriba
                for (let i = 0; i < 20; i++) { if (i !== 1 && i !== 18) res.push({ x: i,  y: 19 }); }  // abajo
                for (let i = 1; i < 19; i++) { if (i !== 10) res.push({ x: 0,  y: i  }); }  // izquierda
                for (let i = 1; i < 19; i++) { if (i !== 10) res.push({ x: 19, y: i  }); }  // derecha
                return res;
            })()
        };
        const LEVEL_SETTINGS = [
            // World 1 - Valle del Despertar
            [
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 }
            ],
            // World 2 - Cueva del Crecimiento
            [
                { speed: 190, initialLength: 10, initialLifespan: 0 },
                { speed: 190, initialLength: 15, initialLifespan: 0 },
                { speed: 190, initialLength: 20, initialLifespan: 0 },
                { speed: 190, initialLength: 25, initialLifespan: 0 },
                { speed: 190, initialLength: 30, initialLifespan: 0 }
            ],
            // World 3 - Templo de la Agilidad
            Array(5).fill({ speed: 150, initialLength: 6, initialLifespan: 0 }),
            // World 4 - Hambre Voraz
            [
                { speed: 180, initialLength: 8, initialLifespan: 9500 },
                { speed: 180, initialLength: 8, initialLifespan: 9000 },
                { speed: 180, initialLength: 8, initialLifespan: 8500 },
                { speed: 180, initialLength: 8, initialLifespan: 8000 },
                { speed: 180, initialLength: 8, initialLifespan: 7500 }
            ],
            // World 5 - Doble o nada
            Array(5).fill({ speed: 170, initialLength: 10, initialLifespan: 9500 }),
            // World 6 - Racha demoledora
            Array(5).fill({ speed: 160, initialLength: 12, initialLifespan: 9000 }),
            // World 7 - Bosque de los Engaños
            Array(5).fill({ speed: 150, initialLength: 14, initialLifespan: 8500 }),
            // World 8 - Jardín de los Peligros
            Array(5).fill({ speed: 140, initialLength: 16, initialLifespan: 8000 }),
            // World 9 - Lago del Reflejo
            Array(5).fill({ speed: 130, initialLength: 18, initialLifespan: 7500 }),
            // World 10 - Desafío Final
            [
                { speed: 125, initialLength: 20, initialLifespan: 7000 },
                { speed: 120, initialLength: 25, initialLifespan: 6500 },
                { speed: 115, initialLength: 30, initialLifespan: 6000 },
                { speed: 110, initialLength: 35, initialLifespan: 5500 },
                { speed: 105, initialLength: 40, initialLifespan: 5000 }
            ]
        ];
        let currentWorld = 1;
        let currentLevelInWorld = 1;
        let maxUnlockedWorld = 1;
        let levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
        let worldCurrentLevels = Array(TOTAL_WORLDS).fill(1);

        // --- Variables de visualización para UI ---
        let displayWorld = 1;
        let displayLevelInWorld = 1;
        let displayMazeLevel = 1;
        let displayTargetScore = TARGET_SCORES_LEVELS[0];


        // --- Configuración de Jugadores (Skins) ---
        const SKINS = {
            snake: {
                snakeHeadAsset: { 
                    upDown: classicSnakeHeadDownImg, 
                    left: classicSnakeHeadLeftImg   
                }, 
                foodAsset: classicFoodImg, 
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#90ff00',
                bodyStrokeColor: adjustColor('#90ff00', 0.30), 
            },
            rubiSnake: {
                snakeHeadAsset: { 
                    upDown: rubiSnakeHeadUpDownImg, 
                    left: rubiSnakeHeadLeftImg, 
                },
                foodAsset: rubiSnakeFoodImg,
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#E74C3C',
                bodyStrokeColor: adjustColor('#E74C3C', 0.30), 
            },
            aitorSnake: { 
                snakeHeadAsset: {
                    upDown: aitorSnakeHeadUpDownImg, 
                    left: aitorSnakeHeadLeftImg,
                },
                foodAsset: aitorSnakeFoodImg,
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#772CE8', 
                bodyStrokeColor: adjustColor('#772CE8', 0.30), 
            },
            noemiSnake: { 
                snakeHeadAsset: {
                    upDown: noemiSnakeHeadUpDownImg, 
                    left: noemiSnakeHeadLeftImg,
                },
                foodAsset: noemiSnakeFoodImg,
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#FFC0EB', 
                bodyStrokeColor: adjustColor('#FFC0EB', 0.30), 
            },
            maraSnake: {
                snakeHeadAsset: {
                    upDown: maraSnakeHeadUpDownImg,
                    left: maraSnakeHeadLeftImg,
                },
                foodAsset: maraSnakeFoodImg,
                snakeHeadScale: 2.0,
                foodScale: 1.5,
                bodyTintColor: '#FCE9BC',
                bodyStrokeColor: adjustColor('#FCE9BC', 0.30),
            },
            almuSnake: { 
                snakeHeadAsset: {
                    upDown: almuSnakeHeadUpDownImg,
                    left: almuSnakeHeadLeftImg,
                },
                foodAsset: almuSnakeFoodImg,
                snakeHeadScale: 2.0,
                foodScale: 1.5,
                bodyTintColor: '#C96B20',
                bodyStrokeColor: adjustColor('#C96B20', 0.30),
            },
            mimiSnake: { 
                snakeHeadAsset: {
                    upDown: mimiSnakeHeadUpDownImg,
                    left: mimiSnakeHeadLeftImg,
                },
                foodAsset: mimiSnakeFoodImg,
                snakeHeadScale: 2.0,
                foodScale: 1.5,
                bodyTintColor: '#FFFFFF',
                bodyStrokeColor: adjustColor('#FFFFFF', 0.30),
            }
        };
        let currentSkin = 'snake';
        let playerProfiles = {};
        let playerNames = ['Snake', 'GamiSnake'];
        let currentPlayerName = 'Snake';

        function createDefaultProfile(name = '') {
            return {
                name: name,
                skin: 'snake',
                food: 'apple',
                difficulty: 'principiante',
                audioGeneral: 'all',
                musicVolume: 75,
                sfxVolume: 75,
                gameMode: '',
                currentWorld: 1,
                currentLevelInWorld: 1,
                maxUnlockedWorld: 1,
                levelsProgress: Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false),
                worldCurrentLevels: Array(TOTAL_WORLDS).fill(1),
                currentMazeLevel: 1,
                mazeLevelStars: Array(MAZE_LEVEL_COUNT).fill(0),
                freeModeSettings: { ...FREE_MODE_DEFAULTS }
            };
        }

        function loadPlayerProfiles() {
            const stored = localStorage.getItem('snakePlayerProfiles');
            if (stored) {
                try {
                    playerProfiles = JSON.parse(stored) || {};
                } catch (e) {
                    console.error('Error parsing player profiles', e);
                    playerProfiles = {};
                }
            }
            if (Object.keys(playerProfiles).length === 0) {
                playerProfiles['Snake'] = createDefaultProfile('Snake');
                playerProfiles['GamiSnake'] = createDefaultProfile('GamiSnake');
            }
            Object.keys(playerProfiles).forEach(name => {
                const profile = playerProfiles[name];
                if (!profile.name) profile.name = name;
                if (!Array.isArray(profile.levelsProgress)) {
                    profile.levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
                }
                if (!Array.isArray(profile.worldCurrentLevels)) {
                    profile.worldCurrentLevels = Array(TOTAL_WORLDS).fill(1);
                }
                if (!Array.isArray(profile.mazeLevelStars)) {
                    profile.mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
                }
                if (!profile.freeModeSettings) {
                    profile.freeModeSettings = { ...FREE_MODE_DEFAULTS };
                }
            });
        }

        function savePlayerProfiles() {
            localStorage.setItem('snakePlayerProfiles', JSON.stringify(playerProfiles));
        }

        function applyProfile(profile) {
            if (!profile) return;
            difficultySelector.value = profile.difficulty || 'principiante';
            classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(difficultySelector.value);
            skinSelector.value = profile.skin || 'snake';
            currentSkin = skinSelector.value;
            applySkin(currentSkin);
            foodSelector.value = profile.food || 'apple';
            currentFood = foodSelector.value;
            applyFood(currentFood);
            audioToggleSelector.value = profile.audioGeneral || 'all';
            musicVolumeSlider.value = profile.musicVolume || 75;
            if (musicVolumeValue) musicVolumeValue.textContent = musicVolumeSlider.value;
            sfxVolumeSlider.value = profile.sfxVolume || 75;
            if (sfxVolumeValue) sfxVolumeValue.textContent = sfxVolumeSlider.value;
            currentWorld = profile.currentWorld || 1;
            currentLevelInWorld = profile.currentLevelInWorld || 1;
            maxUnlockedWorld = profile.maxUnlockedWorld || 1;
            levelsProgress = Array.isArray(profile.levelsProgress) ? profile.levelsProgress : Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
            worldCurrentLevels = Array.isArray(profile.worldCurrentLevels) ? profile.worldCurrentLevels : Array(TOTAL_WORLDS).fill(1);
            currentMazeLevel = profile.currentMazeLevel || 1;
            mazeLevelStars = Array.isArray(profile.mazeLevelStars) ? profile.mazeLevelStars : Array(MAZE_LEVEL_COUNT).fill(0);
            freeModeSettings = profile.freeModeSettings ? { ...FREE_MODE_DEFAULTS, ...profile.freeModeSettings } : { ...FREE_MODE_DEFAULTS };
            populateFreeSettingsInputs();
            updateFreeSettingsLockState();

            // Update display variables when applying profile so UI reflects new player state
            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            displayMazeLevel = currentMazeLevel;

            if (gameMode === 'levels') {
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else {
                    displayTargetScore = TARGET_SCORES_LEVELS[TARGET_SCORES_LEVELS.length - 1];
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            }
        }
        function getSelectedPlayerName() {
            return playerNameSelectors.length ? playerNameSelectors[0].value : '';
        }
        function updatePlayerNameSelectors(selectedName) {
            playerNames = Object.keys(playerProfiles);
            playerNameSelectors.forEach(sel => {
                sel.innerHTML = '';
                playerNames.forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    sel.appendChild(opt);
                });
                if (selectedName && playerNames.includes(selectedName)) sel.value = selectedName;
            });
        }
        // --- Fin Configuración de Jugadores ---

        // --- Configuración de Comestibles ---
        const FOODS = {
            apple: { asset: classicFoodImg, scale: 1.5 },
            cerveza: { asset: rubiSnakeFoodImg, scale: 1.5 },
            croqueta: { asset: aitorSnakeFoodImg, scale: 1.5 },
            aguacate: { asset: noemiSnakeFoodImg, scale: 1.5 },
            sushi: { asset: maraSnakeFoodImg, scale: 1.5 },
            lotus: { asset: almuSnakeFoodImg, scale: 1.5 },
            pan: { asset: mimiSnakeFoodImg, scale: 1.5 },
            oreo: { asset: oreoFoodImg, scale: 1.5 }
        };
        let currentFood = 'apple';
        // --- Fin Configuración de Comestibles ---


        // Estado del juego
        let snake = []; 
        let direction = "right"; 
        let nextDirection = "right"; // Buffer para la siguiente dirección (MANTENIDO DE LA VERSIÓN ANTERIOR)
        let score = 0;
        let totalCoins = 0;
        const MAX_LIVES = 5;
        const LIFE_RECHARGE_TIME = 5 * 60 * 1000; // 5 minutes in ms
        let playerLives = MAX_LIVES;
        let lifeRestoreQueue = [];
        let gameOver = false;
        let gameOverByTimeout = false;
        let gameOverByInactivity = false;
        let gameIntervalId;
        let gameTimeRemaining;
        let gameTimeElapsed;
        let gameTimerIntervalId;
        let lastMovementTime;
        let inactivityIntervalId;
        let gameMode = ''; // No mode selected initially
        let isNewHighScore = false; // Flag for new high score
        
        let currentFoodItem = {}; 
        const FOOD_SHAPE_FALLBACK = { 
            name: 'Comida', 
            color: '#FF7043', 
            borderColor: '#E64A19', 
        };

        let difficulty = 'principiante';
        let freeDifficulty = 'personalizado';
        let snakeSpeed = 150; 
        let foodTimeRemaining = 0; 
        let foodDisappearTimeoutId; 
        let foodVisualTimerIntervalId;
        let streakMultiplier = 1; 
        let lastWarningSoundSecond = -1; 

        // Game state variables for screen display
        let screenState = {
            showCoverForWorld: 0,
            showLevelCompleteCover: 0,
            showWorldCompleteCover: 0,
            showDefeatCoverForWorld: 0,
            showTimeoutCover: false,
            showFreeModeCover: false,
            showFreeModeEnd: false,
            showClassificationCover: false,
            showMazeCover: false,
            mazeResultType: '',
            gameActuallyStarted: false
        };
        let modeSelectIndex = 0;
        const MODE_SELECT_ORDER = ['intro', 'levels', 'maze', 'classification', 'freeMode'];
        let showModeSelect = false;
        let panelOpenedFromSplash = false;
        let introOptionAvailable = true; // controls visibility of the intro slide
        const MODE_TRANSITION_DURATION = 300; // ms
        let modeTransitionStart = null;
        let modeTransitionDir = 0;
        let modeTransitionFrom = 0;

        const CLASSIFICATION_DIFFICULTY_ORDER = ['principiante', 'explorador', 'veterano', 'legendario'];
        let classificationDifficultyIndex = 0;
        let classificationTransitionStart = null;
        let classificationTransitionDir = 0;
        let classificationTransitionFrom = 0;
        let worldTransitionStart = null;
        let worldTransitionDir = 0;
        let worldTransitionFrom = 1;
        let mazeTransitionStart = null;
        let mazeTransitionDir = 0;
        let mazeTransitionFrom = 1;


        const FREE_MODE_DEFAULTS = {
            speed: 140,
            initialLifespan: 7500,
            initialLength: 10,
            goldenFoodChance: 0.1,
            goldenFoodLifespan: 4000,
            lightningSpawnRange: [6000, 10000],
            lightningLifespan: 5000,
            redLightningChance: 0.25,
            streakReduction: 800,
            falseFoodSpawnRange: [6000, 10000],
            falseFoodLifespan: 5000,
            mirrorSpawnRange: [6000, 10000],
            mirrorLifespan: 5000,
            mirrorEffectDuration: 3000,
            obstacleCount: 5
        };
        let freeModeSettings = { ...FREE_MODE_DEFAULTS };


        const DIFFICULTY_SETTINGS = {
            principiante: {
                speed: 180,
                initialLifespan: 0,
                initialLength: 4,
                goldenFoodChance: 0,
                goldenFoodLifespan: 0,
                lightningSpawnRange: null,
                lightningLifespan: 0,
                redLightningChance: 0,
                streakReduction: 0,
                falseFoodSpawnRange: null,
                falseFoodLifespan: 0,
                mirrorSpawnRange: null,
                mirrorLifespan: 0,
                mirrorEffectDuration: 0,
                obstacleCount: 0
            },
            explorador:   {
                speed: 160,
                initialLifespan: 8000,
                initialLength: 6,
                goldenFoodChance: 0.15,
                goldenFoodLifespan: 3500,
                lightningSpawnRange: [6000, 10000],
                lightningLifespan: 5000,
                redLightningChance: 0.25,
                streakReduction: 800,
                falseFoodSpawnRange: null,
                falseFoodLifespan: 0,
                mirrorSpawnRange: null,
                mirrorLifespan: 0,
                mirrorEffectDuration: 0,
                obstacleCount: 0
            },
            veterano:     {
                speed: 140,
                initialLifespan: 7500,
                initialLength: 10,
                goldenFoodChance: 0.1,
                goldenFoodLifespan: 4000,
                lightningSpawnRange: [6000, 10000],
                lightningLifespan: 5000,
                redLightningChance: 0.25,
                streakReduction: 800,
                falseFoodSpawnRange: [6000, 10000],
                falseFoodLifespan: 5000,
                mirrorSpawnRange: [6000, 10000],
                mirrorLifespan: 5000,
                mirrorEffectDuration: 3000,
                obstacleCount: 5
            },
            legendario:   {
                speed: 120,
                initialLifespan: 7000,
                initialLength: 15,
                goldenFoodChance: 0.1,
                goldenFoodLifespan: 4000,
                lightningSpawnRange: [6000, 10000],
                lightningLifespan: 5000,
                redLightningChance: 0.25,
                streakReduction: 800,
                falseFoodSpawnRange: [5000, 7000],
                falseFoodLifespan: 6000,
                mirrorSpawnRange: [5000, 7000],
                mirrorLifespan: 6000,
                mirrorEffectDuration: 3000,
                obstacleCount: 10
            }
        };
        const CLASSIFICATION_RANKS = {
            principiante: 1,
            explorador: 2,
            veterano: 3,
            legendario: 4
        };
        const MIN_FOOD_LIFESPAN = 4000;
        const FOOD_WARNING_TIME = 3000; 
        const POINTS_PER_FOOD = 10;
        const POINTS_PER_COIN = 10;
        const WIN_SOUND_DURATION = 1300; // ms
        const GAME_OVER_SOUND_DURATION = 800; // ms
        const COIN_MESSAGE_DISPLAY_TIME = 1000; // ms
        const MAX_HIGH_SCORES = 10;
        const FREE_MODE_INACTIVITY_LIMIT = 30000; // ms without movement before game ends in free mode
        const FALSE_FOOD_LIFESPAN = 5000;
        const FALSE_FOOD_SPAWN_RANGES_WORLD4 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const FALSE_FOOD_SPAWN_RANGE_WORLD5 = [7000, 12000];
        const OBSTACLE_COUNTS_WORLD5 = [3, 5, 8, 11, 15];
        const OBSTACLE_COUNT_WORLD6 = 5;
        const GOLDEN_FOOD_CHANCE = 0.15;
        const GOLDEN_FOOD_LIFESPANS_WORLD5 = [4000, 3500, 3000, 2500, 2000];
        const GOLDEN_FOOD_LIFESPAN_CLASSIF_RANK1 = 4500;
        const FALSE_FOOD_SPAWN_RANGES_WORLD8 = [
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000]
        ];
        const OBSTACLE_COUNTS_WORLD8 = [5, 8, 11, 14, 17];
        const LIGHTNING_SPAWN_RANGES_WORLD6 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const LIGHTNING_SPAWN_RANGE_WORLD4 = [4000, 7000];
        const LIGHTNING_SPAWN_RANGE_WORLD7 = [7000, 12000];
        const LIGHTNING_SPAWN_RANGES_WORLD8 = [
            [7000, 9000],
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000]
        ];
        const MIRROR_SPAWN_RANGES_WORLD7 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const MIRROR_SPAWN_RANGES_WORLD8 = [
            [7000, 9000],
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000]
        ];
        const DEFAULT_MIRROR_EFFECT_DURATION = 3000;
        let MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
        const LIGHTNING_LIFESPAN = 5000;
        const SPEED_BOOST_DURATION = 3000;
        let obstacles = [];
        let snakeSpawnRow = 0;
        let falseFoodItems = [];
        let falseFoodSpawnTimeoutId;
        let lightningItems = [];
        let lightningSpawnTimeoutId;
        let mirrorItems = [];
        let mirrorSpawnTimeoutId;
        let controlsInverted = false;
        let mirrorEffect = { active: false, startTime: 0 };
        
        function updateMirrorEffect() {
            if (!mirrorEffect.active) return;
            let duration = MIRROR_EFFECT_DURATION;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? DIFFICULTY_SETTINGS[difficultySelector.value] : freeModeSettings;
                if (typeof cfg.mirrorEffectDuration === 'number') {
                    duration = cfg.mirrorEffectDuration;
                }
            }
            const elapsed = Date.now() - mirrorEffect.startTime;
            if (elapsed >= duration) {
                mirrorEffect.active = false;
                controlsInverted = false;
            }
        }
        let speedBoost = { active: false, color: '', change: 0, startTime: 0 };


        // Nuevas variables para el estado del audio
        let isMusicEnabled = true; 
        let areSfxEnabled = true; 
        let synthsInitialized = false; // Flag to track synth initialization
        let synthEat, synthEatNoise, synthBadEat, synthWarning, synthTimeout, synthGameOver, synthStartGame, synthWin, synthCoinNoise, synthCoinChime;
        let synthModeSwitch, synthModeSelect;
        let sfxGain;


        // --- Configuración para la animación de parpadeo del high score ---
        let blinkAnimation = {
            active: false,
            startTime: 0,
            rowIndex: -1,
            duration: 2000,
            interval: 250
        };

        // Animation data for streak multiplier display
        let streakAnimation = {
            active: false,
            value: '',
            color: '',
            startTime: 0
        };

        function startStreakAnimation(multiplier) {
            const text = `x${Number.isInteger(multiplier) ? multiplier : multiplier.toFixed(1)}`;
            let color = '#FF0000';
            if (multiplier > 2 && multiplier <= 3.5) {
                color = '#FFFF00';
            } else if (multiplier > 3.5 && multiplier <= 4.5) {
                color = '#00FF00';
            } else if (multiplier > 4.5) {
                color = '#EE82EE';
            }
            streakAnimation = { active: true, value: text, color, startTime: Date.now() };
        }

        function drawStreakAnimation(head) {
            if (!streakAnimation.active) return;
            const elapsed = Date.now() - streakAnimation.startTime;
            if (elapsed >= STREAK_ANIMATION_DURATION) {
                streakAnimation.active = false;
                return;
            }
            const alpha = 1 - (elapsed / STREAK_ANIMATION_DURATION);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = streakAnimation.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `${Math.floor(GRID_SIZE * 0.5)}px 'Press Start 2P'`;
            const x = head.x * GRID_SIZE + GRID_SIZE / 2;
            const y = head.y * GRID_SIZE - 6;
            ctx.fillText(streakAnimation.value, x, y);
            ctx.restore();
        }
        
        // --- Funciones de Carga y Aplicación de Jugadores ---
        function loadWorldImages() {
            Object.entries(worldImagesConfig).forEach(([id, cfg]) => {
                worldCoverImages[id].src = cfg.cover;
                worldCompleteImages[id].src = cfg.complete;
                levelCompleteImages[id].src = cfg.level;
                defeatImages[id].src = cfg.defeat;
            });

            freeModeCoverImg.src = 'https://i.imgur.com/6cMWnrC.png';
            freeModeEndImg.src = 'https://i.imgur.com/dWseJe2.png';
            freeModeInactivityImg.src = 'https://i.imgur.com/G4j8uBX.png';
            classificationModeCoverImg.src = 'https://i.imgur.com/t5n37Mw.png';
            classificationDifficultyImages.principiante.src = 'https://i.imgur.com/z4SlhGV.png';
            classificationDifficultyImages.explorador.src = 'https://i.imgur.com/QCxdQQh.png';
            classificationDifficultyImages.veterano.src = 'https://i.imgur.com/kEDCBEZ.png';
            classificationDifficultyImages.legendario.src = 'https://i.imgur.com/Mohv1u4.png';

            mazeModeCoverImg.src = 'https://i.imgur.com/WY3lrHv.png';
            mazeLevelCoverImg.src = 'https://i.imgur.com/8asDGaZ.png';
            mazeFailImg.src = 'https://i.imgur.com/3snKeSJ.png';
            mazePartialImg.src = 'https://i.imgur.com/04vASxK.png';
            mazePerfectImg.src = 'https://i.imgur.com/YKVlhix.png';
            mazeCompleteImg.src = 'https://i.imgur.com/0s9b6JB.png';
            mazeFinalImg.src = 'https://i.imgur.com/dga8Z3q.png';
            mazeAllStarsImg.src = 'https://i.imgur.com/grMD2kr.png';
            timeoutImg.src = 'https://i.imgur.com/uEjzFbY.png';
            starFullImg.src = 'https://i.imgur.com/mJU2iIm.png';
            starEmptyImg.src = 'https://i.imgur.com/M4FDVgp.png';


            const allWorldImages = [
                ...Object.values(worldCoverImages),
                ...Object.values(worldCompleteImages),
                ...Object.values(levelCompleteImages),
                ...Object.values(defeatImages),
                freeModeCoverImg, freeModeEndImg, freeModeInactivityImg, classificationModeCoverImg,
                ...Object.values(classificationDifficultyImages),
                mazeModeCoverImg, mazeLevelCoverImg,
                mazeFailImg, mazePartialImg, mazePerfectImg,
                mazeCompleteImg, mazeFinalImg, mazeAllStarsImg, timeoutImg,
                starFullImg, starEmptyImg
            ];

            allWorldImages.forEach(img => {
                img.onload = () => {
                    worldImagesLoaded++;
                    if (worldImagesLoaded === totalWorldImagesToLoad) {
                        console.log("Todas las imágenes de mundo, completado de mundo, completado de nivel, derrota, modo libre, modo clasificación y modo laberinto cargadas.");
                        if (ctx && (
                            (gameMode === 'levels' && (screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0) && !screenState.gameActuallyStarted) || 
                            screenState.showWorldCompleteCover > 0 ||
                            (gameMode === 'freeMode' && screenState.showFreeModeCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'classification' && screenState.showClassificationCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'maze' && screenState.showMazeCover && !screenState.gameActuallyStarted)
                            )) {
                           requestAnimationFrame(draw);
                        }
                    }
                };
                 img.onerror = () => {
                    console.error(`Error al cargar imagen: ${img.src}`);
                    worldImagesLoaded++; 
                     if (worldImagesLoaded === totalWorldImagesToLoad) {
                        console.log("Proceso de carga de imágenes de mundo/nivel/derrota/modo libre/modo clasificación/modo laberinto finalizado (con errores).");
                         if (ctx && (
                            (gameMode === 'levels' && (screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0) && !screenState.gameActuallyStarted) || 
                            screenState.showWorldCompleteCover > 0 ||
                            (gameMode === 'freeMode' && screenState.showFreeModeCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'classification' && screenState.showClassificationCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'maze' && screenState.showMazeCover && !screenState.gameActuallyStarted)
                            )) {
                            requestAnimationFrame(draw);
                        }
                    }
                };
            });
        }

        function loadModeSelectionImages() {
            modeSelectIntroImg.src = 'https://i.imgur.com/W34ctvU.png';
            modeSelectLevelsImg.src = 'https://i.imgur.com/1Dp5GTu.png';
            modeSelectFreeImg.src = 'https://i.imgur.com/6cMWnrC.png';
            modeSelectClassificationImg.src = 'https://i.imgur.com/t5n37Mw.png';
            modeSelectMazeImg.src = 'https://i.imgur.com/WY3lrHv.png';

            [modeSelectIntroImg, modeSelectLevelsImg, modeSelectFreeImg, modeSelectClassificationImg, modeSelectMazeImg].forEach(img => {
                img.onload = () => { if (showModeSelect && ctx) requestAnimationFrame(draw); };
                img.onerror = () => { console.error(`Error al cargar imagen: ${img.src}`); if (showModeSelect && ctx) requestAnimationFrame(draw); };
            });
        }

        function loadSkinImages() {
            classicSnakeHeadLeftImg.src = 'https://i.imgur.com/x3Wrabg.png';
            classicSnakeHeadDownImg.src = 'https://i.imgur.com/lapIn2F.png';
            classicFoodImg.src = 'https://i.imgur.com/Rrvl9Fj.png'; 
            snakeBodyTexture.src = 'https://i.imgur.com/qWefd22.png'; 

            rubiSnakeHeadUpDownImg.src = 'https://i.imgur.com/XQzDVMk.png';
            rubiSnakeHeadLeftImg.src = 'https://i.imgur.com/XQzDVMk.png'; 
            rubiSnakeFoodImg.src = 'https://i.imgur.com/wXIXaQZ.png';

            aitorSnakeHeadUpDownImg.src = 'https://i.imgur.com/WBS3C4N.png';
            aitorSnakeHeadLeftImg.src = 'https://i.imgur.com/IfYIEkv.png';
            aitorSnakeFoodImg.src = 'https://i.imgur.com/rUCsqoq.png'; 

            noemiSnakeHeadUpDownImg.src = 'https://i.imgur.com/h84RIhq.png';
            noemiSnakeHeadLeftImg.src = 'https://i.imgur.com/TU4CgRq.png';
            noemiSnakeFoodImg.src = 'https://i.imgur.com/2bGXbM1.png';
            
            maraSnakeHeadUpDownImg.src = 'https://i.imgur.com/YvQ2uni.png';
            maraSnakeHeadLeftImg.src = 'https://i.imgur.com/oiBGoud.png';
            maraSnakeFoodImg.src = 'https://i.imgur.com/krE9lwu.png';

            almuSnakeHeadUpDownImg.src = 'https://i.imgur.com/2HqLxxp.png';
            almuSnakeHeadLeftImg.src = 'https://i.imgur.com/27Q7QvA.png';
            almuSnakeFoodImg.src = 'https://i.imgur.com/Lcurg08.png';

            mimiSnakeHeadUpDownImg.src = 'https://i.imgur.com/2UnTxTM.png';
            mimiSnakeHeadLeftImg.src = 'https://i.imgur.com/GjJrvUA.png';
            mimiSnakeFoodImg.src = 'https://i.imgur.com/kgOjgCI.png';

            oreoFoodImg.src = 'https://i.imgur.com/Yv5ioX3.png';
            obstacleImg.src = 'https://i.imgur.com/wk1u29m.png';
            lightningYellowImg.src = 'https://i.imgur.com/AJL2p3j.png';
            lightningRedImg.src = 'https://i.imgur.com/4sNOTpi.png';
            
            const allImageObjects = [ 
                classicSnakeHeadLeftImg, classicSnakeHeadDownImg, classicFoodImg, snakeBodyTexture,
                rubiSnakeHeadUpDownImg, rubiSnakeHeadLeftImg, rubiSnakeFoodImg,
                aitorSnakeHeadUpDownImg, aitorSnakeHeadLeftImg, aitorSnakeFoodImg,
                noemiSnakeHeadUpDownImg, noemiSnakeHeadLeftImg, noemiSnakeFoodImg,
                maraSnakeHeadUpDownImg, maraSnakeHeadLeftImg, maraSnakeFoodImg,
                almuSnakeHeadUpDownImg, almuSnakeHeadLeftImg, almuSnakeFoodImg,
                mimiSnakeHeadUpDownImg, mimiSnakeHeadLeftImg, mimiSnakeFoodImg,
                oreoFoodImg, obstacleImg, lightningYellowImg, lightningRedImg
            ];

            allImageObjects.forEach(imgObj => {
                imgObj.onload = () => {
                    console.log(`Imagen ${imgObj.src.split('/').pop()} cargada.`);
                    if (ctx && (gameOver || !gameIntervalId || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                        requestAnimationFrame(draw);
                    }
                };
                imgObj.onerror = () => {
                    console.error(`Error al cargar la imagen: ${imgObj.src}`);
                    if (ctx && (gameOver || !gameIntervalId || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                        requestAnimationFrame(draw);
                    }
                };
            });
        }

        function applySkin(skinName) {
            currentSkin = skinName;
            console.log(`Jugador aplicado: ${currentSkin}`);

            if (gameOver) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151"; 
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            } else { 
                if (!gameIntervalId && ctx) { 
                    draw(); 
                }
            }
        }

        function applyFood(foodName) {
            currentFood = foodName;
            console.log(`Comestible aplicado: ${currentFood}`);
            if (gameOver) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            } else {
                if (!gameIntervalId && ctx) {
                    draw();
                }
            }
        }
        
        function resizeGameElements() {
            if (!gameContainer || !canvasEl ) { 
                console.error("Error: gameContainer or canvasEl no están definidos en resizeGameElements.");
                return;
            }
            const containerComputedStyle = getComputedStyle(gameContainer);
            const canvasComputedStyle = getComputedStyle(canvasEl);

           const containerPadding = 2 * parseFloat(containerComputedStyle.paddingLeft);
           let availableWidth = gameContainer.clientWidth - containerPadding;

           const canvasBorderWidth = 2 * parseFloat(canvasComputedStyle.borderLeftWidth);
           availableWidth -= canvasBorderWidth;

            const availableHeight =
                gameContainer.clientHeight -
                topInfoBar.offsetHeight -
                setupControls.offsetHeight;

            GRID_SIZE = Math.floor(
                Math.min(availableWidth, availableHeight) / TILE_COUNT
            );

            canvasEl.width = TILE_COUNT * GRID_SIZE;
            canvasEl.height = TILE_COUNT * GRID_SIZE;

            tileCountX = TILE_COUNT;
            tileCountY = TILE_COUNT;

            // If a panel is open, re-calculate its position after resize
            if (!settingsPanel.classList.contains("settings-panel-hidden")) {
                positionPanel(settingsPanel);
                applyScrollbarPadding(settingsPanelContent);
            }
            if (!infoPanel.classList.contains("info-panel-hidden")) {
                positionPanel(infoPanel);
                applyScrollbarPadding(infoPanelContent);
            }
            if (specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden")) {
                positionPanel(specificInfoPanel);
                applyScrollbarPadding(specificInfoContent);
            }
            if (freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden")) {
                positionPanel(freeSettingsPanel);
                applyScrollbarPadding(freeSettingsPanelContent);
            }
            if (resetConfirmPanel && !resetConfirmPanel.classList.contains("reset-panel-hidden")) {
                positionPanel(resetConfirmPanel);
                applyScrollbarPadding(resetConfirmPanelContent);
            }


            if (ctx && (gameIntervalId || gameOver || snake.length > 0 || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                draw();
            } else if (ctx) {
                ctx.fillStyle = "#374151";
                ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            }
        }

        function resetGameUIDisplays() {
            updateCoinDisplay();
            scoreValueDisplay.textContent = "0";
            if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
            } else if (gameMode === 'classification') {
                timeLengthValueEl.textContent = formatTime(0);
            } else { // freeMode
                timeLengthValueEl.textContent = initialSnakeLength;
            }
            updateTargetScoreDisplay();
        }

        function positionPanel(panelElement) {
            if (panelElement.classList.contains('centered-panel')) {
                panelElement.style.top = '50%';
                panelElement.style.bottom = 'auto';
                panelElement.style.height = 'auto';
                return;
            }
            let topReferenceElement = progressPanel;
            if (progressPanel.classList.contains('hidden') || !progressPanel.offsetParent) {
                if (!titlePanel.classList.contains('hidden') && titlePanel.offsetParent) {
                    topReferenceElement = titlePanel;
                } else {
                    topReferenceElement = topInfoBar;
                    if (topInfoBar.classList.contains('hidden') || !topInfoBar.offsetParent) {
                        topReferenceElement = gameContainer;
                    }
                }
            }
            
            const mobileControlsEl = document.getElementById('mobile-controls'); 

            if (!topReferenceElement || !mobileControlsEl || !panelElement || !gameContainer) { 
                console.error("positionPanel: Elemento(s) clave(s) para el posicionamiento no encontrado(s).");
                return;
            }

            const topRefRect = topReferenceElement.getBoundingClientRect();
            const mobileControlsRect = mobileControlsEl.getBoundingClientRect(); 
            const gameContainerRect = gameContainer.getBoundingClientRect();
            const panelVerticalMargin = 5; 

            let panelTopPosition = topRefRect.top - gameContainerRect.top;
            if (topReferenceElement === gameContainer) panelTopPosition = 0; 
            
            panelElement.style.top = panelTopPosition + 'px';
            
            let panelBottomLimit;
            if (mobileControlsEl.offsetParent === null) {
                panelBottomLimit = gameContainerRect.height - panelVerticalMargin;
            } else {
                panelBottomLimit = mobileControlsRect.top - gameContainerRect.top - panelVerticalMargin;
            }
            let availablePanelHeight = panelBottomLimit - panelTopPosition;

            panelElement.style.height = Math.max(100, availablePanelHeight) + 'px';
            panelElement.style.bottom = 'auto';
            const limitSource = mobileControlsEl.offsetParent === null ? 'Contenedor' : 'D-Pad';
            console.log(`Panel ${panelElement.id} posicionado. Top: ${panelElement.style.top}, Height: ${panelElement.style.height}, Referencia superior: ${topReferenceElement.id}, Límite inferior: ${limitSource}`);
        }

        function updateMainButtonStates() {
            const isSettingsVisible = !settingsPanel.classList.contains("settings-panel-hidden") && settingsPanel.classList.contains("panel-visible");
            const isInfoVisible = !infoPanel.classList.contains("info-panel-hidden") && infoPanel.classList.contains("panel-visible");
            const isFreeSettingsVisible = freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden") && freeSettingsPanel.classList.contains("panel-visible");
            const isAnyMainPanelEffectivelyOpen = isSettingsVisible || isInfoVisible || isFreeSettingsVisible;

            if (isAnyMainPanelEffectivelyOpen) {
                startButton.disabled = true;
                restartMazeButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;
                backButtonIcon.src = showModeSelect ? 'https://i.imgur.com/1WrBpTQ.png' : 'https://i.imgur.com/Wvl87cV.png';
                configButtonIcon.src = showModeSelect ? 'https://i.imgur.com/9HHOgFe.png' : ((gameMode === 'levels' || gameMode === 'maze') ? 'https://i.imgur.com/IW3a5DA.png' : 'https://i.imgur.com/jekDmyV.png');
                return;
            }

            if (gameIntervalId) {
                startButton.disabled = true;
                restartMazeButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;
                backButtonIcon.src = showModeSelect ? 'https://i.imgur.com/1WrBpTQ.png' : 'https://i.imgur.com/Wvl87cV.png';
                configButtonIcon.src = showModeSelect ? 'https://i.imgur.com/9HHOgFe.png' : ((gameMode === 'levels' || gameMode === 'maze') ? 'https://i.imgur.com/IW3a5DA.png' : 'https://i.imgur.com/jekDmyV.png');
            } else {
                const isWorldIntroCover = screenState.showCoverForWorld > 0 && !screenState.gameActuallyStarted;
                const isWorldCompleteScreen = screenState.showWorldCompleteCover > 0;
                const isLevelCompleteScreen = screenState.showLevelCompleteCover > 0 && !screenState.gameActuallyStarted;
                const isDefeatScreen = screenState.showDefeatCoverForWorld > 0 && !screenState.gameActuallyStarted;
                const isTimeoutScreen = screenState.showTimeoutCover && !screenState.gameActuallyStarted;
                const isFreeModeEndScreen = screenState.showFreeModeEnd && !screenState.gameActuallyStarted;
                const isFreeModeCoverActive = screenState.showFreeModeCover && !screenState.gameActuallyStarted;
                const isClassificationCoverActive = screenState.showClassificationCover && !screenState.gameActuallyStarted;
                const isMazeCoverActive = screenState.showMazeCover && !screenState.gameActuallyStarted;
                const isMazeResultScreen = screenState.mazeResultType && !screenState.gameActuallyStarted;
                const isModeSelectActive = showModeSelect;
                const isModeSelectIntro = isModeSelectActive && MODE_SELECT_ORDER[modeSelectIndex] === 'intro';
                const isSelectedWorldLocked = isWorldIntroCover && displayWorld > maxUnlockedWorld;
                const isSelectedMazeLocked = isMazeCoverActive && displayMazeLevel > currentMazeLevel;

                startButton.disabled = isModeSelectIntro || isSelectedWorldLocked || isSelectedMazeLocked;
                restartMazeButton.disabled = restartMazeButton.classList.contains('hidden');
                configButton.disabled = false;
                backButton.disabled = false;

                if (isModeSelectActive) {
                    backButtonIcon.src = 'https://i.imgur.com/1WrBpTQ.png';
                    configButtonIcon.src = 'https://i.imgur.com/9HHOgFe.png';
                } else {
                    backButtonIcon.src = 'https://i.imgur.com/Wvl87cV.png';
                    configButtonIcon.src = (gameMode === 'levels' || gameMode === 'maze') ? 'https://i.imgur.com/IW3a5DA.png' : 'https://i.imgur.com/jekDmyV.png';
                }

                if (isModeSelectActive) {
                    startButton.textContent = "Seleccionar";
                } else if (isLevelCompleteScreen) {
                    // Text is set by handleLevelsModeEnd
                } else if (isWorldCompleteScreen) {
                    // Text is set by handleLevelsModeEnd
                } else if (isDefeatScreen || isTimeoutScreen || isFreeModeEndScreen) {
                    startButton.textContent = "Reintentar";
                } else if (isMazeResultScreen) {
                    // Text already set by handleMazeModeEnd
                } else if (isWorldIntroCover || isFreeModeCoverActive || isClassificationCoverActive || isMazeCoverActive) {
                    startButton.textContent = "Empezar";
                } else if (gameOver && (gameMode === 'freeMode' || gameMode === 'classification')) {
                    startButton.textContent = "Empezar";
                } else if (gameOver && gameMode === 'levels') {
                    // finalizeGameOver (via handleLevelsModeEnd) sets the text
                    // If we are here after closing settings, it should be "Empezar"
                     if (!isWorldIntroCover && !isWorldCompleteScreen && !isLevelCompleteScreen && !isDefeatScreen) {
                        startButton.textContent = "Empezar";
                    }
                } else { 
                    startButton.textContent = "Empezar";
                }
                
                const isAnyCoverScreenActive = isWorldIntroCover || isWorldCompleteScreen || isLevelCompleteScreen || isDefeatScreen || isTimeoutScreen || isFreeModeEndScreen || isFreeModeCoverActive || isClassificationCoverActive || isMazeCoverActive || isMazeResultScreen || isModeSelectActive;
                if (!isAnyCoverScreenActive && !gameOver) {
                     if (isMusicEnabled && generalBackgroundMusic && generalBackgroundMusic.paused) {
                        if (inGameBackgroundMusic && !inGameBackgroundMusic.paused) inGameBackgroundMusic.pause();
                        generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (updateMainButtonStates):", e));
                    }
                }
            }
        }

        function applyScrollbarPadding(el) {
            if (!el) return;
            const needsPadding = el.scrollHeight > el.clientHeight + 1;
            if (needsPadding) el.classList.add('scroll-padding');
            else el.classList.remove('scroll-padding');
        }

        function matchPanelSizeWithElement(sourceElement, targetPanel) {
            if (!sourceElement || !targetPanel) return;
            const srcRect = sourceElement.getBoundingClientRect();
            targetPanel.style.top = srcRect.top + 'px';
            targetPanel.style.height = srcRect.height + 'px';
        }

        // --- Panel Management Refactor ---
        function togglePanel(panelElement, contentContainer, show) {
            if (!panelElement) {
                console.error("togglePanel: panelElement no encontrado.");
                return;
            }
            const panelId = panelElement.id;
            let hiddenClassName;
            const visibleClassName = "panel-visible";

            if (panelId === "settings-panel") hiddenClassName = "settings-panel-hidden";
            else if (panelId === "info-panel") hiddenClassName = "info-panel-hidden";
            else if (panelId === "specific-info-panel") hiddenClassName = "specific-info-panel-hidden";
            else if (panelId === "free-settings-panel") hiddenClassName = "free-settings-panel-hidden";
            else if (panelId === "reset-confirmation-panel") hiddenClassName = "reset-panel-hidden";
            else {
                console.error("togglePanel: Clase oculta no definida para el panel:", panelId);
                return;
            }

            if (show) {
                if (panelElement === settingsPanel && !infoPanel.classList.contains("info-panel-hidden")) {
                    togglePanel(infoPanel, infoPanelContent, false);
                }
                if (panelElement === settingsPanel && freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden")) {
                    togglePanel(freeSettingsPanel, freeSettingsPanelContent, false);
                }
                if (panelElement === infoPanel && !settingsPanel.classList.contains("settings-panel-hidden")) {
                    togglePanel(settingsPanel, settingsPanelContent, false);
                }
                if (panelElement === freeSettingsPanel && !settingsPanel.classList.contains("settings-panel-hidden")) {
                    togglePanel(settingsPanel, settingsPanelContent, false);
                }
                if (panelElement !== specificInfoPanel && specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden")) {
                    togglePanel(specificInfoPanel, specificInfoContent, false);
                }

                panelElement.classList.remove(hiddenClassName);
                positionPanel(panelElement);
                
                requestAnimationFrame(() => {
                    panelElement.classList.add(visibleClassName);
                    const targetScrollElement = contentContainer || panelElement;
                    if (targetScrollElement) {
                        targetScrollElement.scrollTop = 0;
                        applyScrollbarPadding(targetScrollElement);
                    }
                });
                
                startButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;

                if (panelElement === settingsPanel && !gameIntervalId) {
                    skinSelector.disabled = false;
                    foodSelector.disabled = false;
                    skinControlGroup.classList.add("interactive-mode");
                    foodControlGroup.classList.add("interactive-mode");
                    if (gameMode === 'levels') worldsSelector.disabled = false; else difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                    if (typeof Tone !== 'undefined') {
                        if (panelOpenedFromSplash) {
                            audioControlGroup.classList.remove('hidden');
                            musicVolumeControlGroup.classList.remove('hidden');
                            sfxVolumeControlGroup.classList.remove('hidden');
                            audioToggleSelector.disabled = false;
                            audioControlGroup.classList.add("interactive-mode");
                            musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                            sfxVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'music_only');
                            if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                            else musicVolumeControlGroup.classList.remove("interactive-mode");
                            if (!sfxVolumeSlider.disabled) sfxVolumeControlGroup.classList.add("interactive-mode");
                            else sfxVolumeControlGroup.classList.remove("interactive-mode");
                        } else {
                            audioToggleSelector.disabled = true;
                            musicVolumeSlider.disabled = true;
                            sfxVolumeSlider.disabled = true;
                            audioControlGroup.classList.add('hidden');
                            musicVolumeControlGroup.classList.add('hidden');
                            sfxVolumeControlGroup.classList.add('hidden');
                            audioControlGroup.classList.remove("interactive-mode");
                            musicVolumeControlGroup.classList.remove("interactive-mode");
                            sfxVolumeControlGroup.classList.remove("interactive-mode");
                        }
                    }
                    settingsPanel.querySelectorAll('.setting-info-button').forEach(btn => btn.disabled = false);
                }
            } else { // Hiding a panel
                panelElement.classList.remove(visibleClassName); 
                setTimeout(() => {
                    panelElement.classList.add(hiddenClassName); 
                    panelElement.style.top = '';
                    panelElement.style.bottom = '';
                    panelElement.style.height = '';
                    // Caller of togglePanel(..., false) is now responsible for updateMainButtonStates
                }, 300); 
            }
        }


        function openSettingsPanel() {
            settingsPanel.classList.add('centered-panel');
            togglePanel(settingsPanel, settingsPanelContent, true);
            updateSfxVolume();
            // Show or hide certain settings when accessed from the splash screen
            if (!gameMode) difficultyControlGroup.classList.add('hidden');
            else difficultyControlGroup.classList.remove('hidden');
            skinControlGroup.classList.remove('hidden');
            foodControlGroup.classList.remove('hidden');
            if (playerNameControlGroup) playerNameControlGroup.classList.remove('hidden');
            if (panelOpenedFromSplash) {
                playerSelectControlGroup.classList.remove('hidden');
                addPlayerControlGroup.classList.remove('hidden');
                difficultyControlGroup.classList.add('hidden');
                skinControlGroup.classList.add('hidden');
                foodControlGroup.classList.add('hidden');
                if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
                resetDataButton.classList.remove('hidden');
                resetDataButton.classList.add('interactive-mode');
            } else {
                playerSelectControlGroup.classList.add('hidden');
                addPlayerControlGroup.classList.add('hidden');
                resetDataButton.classList.add('hidden');
                resetDataButton.classList.remove('interactive-mode');
            }

            if (gameMode === 'classification' && !panelOpenedFromSplash) {
                if (classificationRankingGroup) {
                    classificationRankingGroup.classList.remove('hidden');
                    populateClassificationRanking();
                }
                skinControlGroup.classList.add('hidden');
                foodControlGroup.classList.add('hidden');
                audioControlGroup.classList.add('hidden');
                musicVolumeControlGroup.classList.add('hidden');
                sfxVolumeControlGroup.classList.add('hidden');
            } else if (classificationRankingGroup) {
                classificationRankingGroup.classList.add('hidden');
            }
            if (gameOver && !gameIntervalId) { // Game is over and not running
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
                
                score = 0; // Reset internal score
                streakMultiplier = 1; // Reset internal streak
                
                if (gameMode === 'levels' || gameMode === 'maze') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    screenState.showFreeModeEnd = false;
                    screenState.showClassificationCover = false;
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    screenState.gameActuallyStarted = false;
                    snake = []; // Vaciar la serpiente para que updateTimeLengthDisplay use initialSnakeLength
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = [];
                }
                resetGameUIDisplays(); // Update UI for score, streak, AND length (if free mode and snake is empty)
                updateGameModeUI(); // This will refresh panel values and target scores
                requestAnimationFrame(draw); // Redraw canvas to show cover
            } else {
                updateGameModeUI(); // Ensure panel reflects current mode when opening during gameplay
            }
        }

        function closeSettingsPanel() {
            const wasSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden");
            
            togglePanel(settingsPanel, settingsPanelContent, false); // Hides panel

            if (wasSpecificInfoOpen) {
                togglePanel(specificInfoPanel, specificInfoContent, false); // Hides specific info
            }

            if (gameOver && !gameIntervalId) { // If game was over and not running
                if (gameMode === 'levels') {

                    screenState.showCoverForWorld = currentWorld; // Show current world cover
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    
                    // Score and streak should have been reset when settings panel was opened if game was over
                    updateScoreDisplay(); // Ensure score 0 is displayed
                    updateTargetScoreDisplay(); // Ensure correct target is displayed
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true; // Ensure cover is shown when returning from settings
                    screenState.showFreeModeEnd = false;
                    screenState.gameActuallyStarted = false;
                    // Score, streak and snake length (via snake=[]) reset when settings opened
                    updateScoreDisplay();
                    updateTimeLengthDisplay(); // Ensure length is updated based on empty snake array
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true; // Ensure cover is shown when returning from settings
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                }
                updateGameModeUI(); 
                requestAnimationFrame(draw); 
            }
            
            setTimeout(() => { // Ensure buttons are updated after panel animation
                updateMainButtonStates();
            }, 0);
            settingsPanel.classList.remove('centered-panel');

            if (panelOpenedFromSplash && splashScreen && !splashScreen.classList.contains('hidden')) {
                if (gameContainer) gameContainer.classList.add('hidden');
                panelOpenedFromSplash = false;
            }
        }

       function openFreeSettingsPanel() {
           freeSettingsPanel.classList.add('centered-panel');
           togglePanel(freeSettingsPanel, freeSettingsPanelContent, true);
           if (freeDifficultySelector) {
               freeDifficultySelector.value = freeDifficulty;
           }
           populateFreeSettingsInputs();
            displayHighScoreInPanel();
            updateFreeSettingsLockState();
       }

        function closeFreeSettingsPanel() {
            togglePanel(freeSettingsPanel, freeSettingsPanelContent, false);
            setTimeout(updateMainButtonStates, 0);
            freeSettingsPanel.classList.remove('centered-panel');
        }

        function populateFreeSettingsInputs() {
            const speedFactor = freeModeSettings.speed / FREE_MODE_DEFAULTS.speed;
            freeSpeedInput.value = Math.round(((2 - speedFactor) / 1.5) * 100);
            if (freeSpeedValue) freeSpeedValue.textContent = freeSpeedInput.value;

            freeLifespanToggle.checked = freeModeSettings.initialLifespan > 0;
            freeLifespanInput.value = freeModeSettings.initialLifespan > 0 ? freeModeSettings.initialLifespan / 1000 : 4;
            if (freeLifespanValue) freeLifespanValue.textContent = freeLifespanInput.value;
            freeLifespanInput.disabled = !freeLifespanToggle.checked;

            freeLengthInput.value = freeModeSettings.initialLength;
            if (freeLengthValue) freeLengthValue.textContent = freeLengthInput.value;

            freeGoldenToggle.checked = freeModeSettings.goldenFoodChance > 0;
            freeGoldenChanceInput.value = freeModeSettings.goldenFoodChance > 0 ? freeModeSettings.goldenFoodChance * 100 : 10;
            if (freeGoldenChanceValue) freeGoldenChanceValue.textContent = freeGoldenChanceInput.value;
            freeGoldenLifespanInput.value = freeModeSettings.goldenFoodLifespan / 1000;
            if (freeGoldenLifespanValue) freeGoldenLifespanValue.textContent = freeGoldenLifespanInput.value;
            freeGoldenChanceInput.disabled = freeGoldenLifespanInput.disabled = !freeGoldenToggle.checked;

            freeLightningToggle.checked = !!freeModeSettings.lightningSpawnRange;
            if (freeModeSettings.lightningSpawnRange) {
                freeLightningRange.value = freeModeSettings.lightningSpawnRange[0] / 1000;
            } else {
                freeLightningRange.value = 0;
            }
            if (freeLightningRangeDisplay) {
                freeLightningRangeDisplay.textContent = `${freeLightningRange.value} - ${parseFloat(freeLightningRange.value) + 4}`;
            }
            freeLightningRange.disabled = !freeLightningToggle.checked;
            freeLightningLifespan.value = freeModeSettings.lightningLifespan / 1000;
            if (freeLightningLifespanValue) freeLightningLifespanValue.textContent = freeLightningLifespan.value;
            freeLightningLifespan.disabled = !freeLightningToggle.checked;
            freeRedChance.value = freeModeSettings.redLightningChance * 100;
            if (freeRedChanceValue) freeRedChanceValue.textContent = freeRedChance.value;
            freeRedChance.disabled = !freeLightningToggle.checked;

            freeStreakToggle.checked = freeModeSettings.streakReduction > 0;

            freeFalseToggle.checked = !!freeModeSettings.falseFoodSpawnRange;
            if (freeModeSettings.falseFoodSpawnRange) {
                freeFalseRange.value = freeModeSettings.falseFoodSpawnRange[0] / 1000;
            } else {
                freeFalseRange.value = 0;
            }
            if (freeFalseRangeDisplay) {
                freeFalseRangeDisplay.textContent = `${freeFalseRange.value} - ${parseFloat(freeFalseRange.value) + 4}`;
            }
            freeFalseRange.disabled = !freeFalseToggle.checked;
            freeFalseLifespan.value = freeModeSettings.falseFoodLifespan / 1000;
            if (freeFalseLifespanValue) freeFalseLifespanValue.textContent = freeFalseLifespan.value;
            freeFalseLifespan.disabled = !freeFalseToggle.checked;

            freeMirrorToggle.checked = !!freeModeSettings.mirrorSpawnRange;
            if (freeModeSettings.mirrorSpawnRange) {
                freeMirrorRange.value = freeModeSettings.mirrorSpawnRange[0] / 1000;
            } else {
                freeMirrorRange.value = 0;
            }
            if (freeMirrorRangeDisplay) {
                freeMirrorRangeDisplay.textContent = `${freeMirrorRange.value} - ${parseFloat(freeMirrorRange.value) + 4}`;
            }
            freeMirrorRange.disabled = !freeMirrorToggle.checked;
            freeMirrorLifespan.value = freeModeSettings.mirrorLifespan / 1000;
            if (freeMirrorLifespanValue) freeMirrorLifespanValue.textContent = freeMirrorLifespan.value;
            freeMirrorEffect.value = freeModeSettings.mirrorEffectDuration / 1000;
            if (freeMirrorEffectValue) freeMirrorEffectValue.textContent = freeMirrorEffect.value;
            freeMirrorLifespan.disabled = freeMirrorEffect.disabled = !freeMirrorToggle.checked;

            freeObstacleCount.value = freeModeSettings.obstacleCount;
            if (freeObstacleCountValue) freeObstacleCountValue.textContent = freeObstacleCount.value;
            if (freeObstacleGroup) {
                freeObstacleGroup.classList.toggle('dimmed', freeModeSettings.obstacleCount === 0);
            }

            [
                freeLifespanToggle,
                freeGoldenToggle,
                freeLightningToggle,
                freeStreakToggle,
                freeFalseToggle,
                freeMirrorToggle
            ].forEach(t => t && t.dispatchEvent(new Event('change')));
        }

        function applyFreeSettings() {
            freeModeSettings = {
                speed: (2 - (parseFloat(freeSpeedInput.value) / 100) * 1.5) * FREE_MODE_DEFAULTS.speed,
                initialLifespan: freeLifespanToggle.checked ? parseFloat(freeLifespanInput.value) * 1000 : 0,
                initialLength: parseInt(freeLengthInput.value, 10),
                goldenFoodChance: freeGoldenToggle.checked ? parseFloat(freeGoldenChanceInput.value) / 100 : 0,
                goldenFoodLifespan: parseFloat(freeGoldenLifespanInput.value) * 1000,
                lightningSpawnRange: freeLightningToggle.checked ? [parseFloat(freeLightningRange.value) * 1000, (parseFloat(freeLightningRange.value) + 4) * 1000] : null,
                lightningLifespan: parseFloat(freeLightningLifespan.value) * 1000,
                redLightningChance: parseFloat(freeRedChance.value) / 100,
                streakReduction: freeStreakToggle.checked ? FREE_MODE_DEFAULTS.streakReduction : 0,
                falseFoodSpawnRange: freeFalseToggle.checked ? [parseFloat(freeFalseRange.value) * 1000, (parseFloat(freeFalseRange.value) + 4) * 1000] : null,
                falseFoodLifespan: parseFloat(freeFalseLifespan.value) * 1000,
                mirrorSpawnRange: freeMirrorToggle.checked ? [parseFloat(freeMirrorRange.value) * 1000, (parseFloat(freeMirrorRange.value) + 4) * 1000] : null,
                mirrorLifespan: parseFloat(freeMirrorLifespan.value) * 1000,
                mirrorEffectDuration: parseFloat(freeMirrorEffect.value) * 1000,
                obstacleCount: parseInt(freeObstacleCount.value, 10)
            };
            if (playerProfiles[currentPlayerName]) {
                playerProfiles[currentPlayerName].freeModeSettings = freeModeSettings;
                saveGameSettings();
            }
            closeFreeSettingsPanel();
        }

        function openInfoPanel() {
            infoPanel.classList.add('centered-panel');
            togglePanel(infoPanel, infoPanelContent, true);
            if (panelOpenedFromSplash) {
                const splashContent = document.getElementById('splash-content');
                requestAnimationFrame(() => {
                    matchPanelSizeWithElement(splashContent, infoPanel);
                    infoPanel.classList.remove('centered-panel');
                });
            }
            if (gameOver && !gameIntervalId) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
                score = 0;
                streakMultiplier = 1;

                if (gameMode === 'levels' || gameMode === 'maze') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showFreeModeEnd = false;
                screenState.showClassificationCover = false;
            } else if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = true;
                screenState.showFreeModeEnd = false;
                screenState.gameActuallyStarted = false;
                snake = []; // Vaciar la serpiente
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = [];
                }
                resetGameUIDisplays(); // Llamar aquí para que la UI se actualice con los valores reseteados
                updateGameModeUI();
                requestAnimationFrame(draw);
            }
        }

        function closeInfoPanel() {
            togglePanel(infoPanel, infoPanelContent, false);
             if (gameOver && !gameIntervalId) { // If game was over and not running
                if (gameMode === "levels") {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showFreeModeEnd = false;
                    screenState.showClassificationCover = false;
                    updateScoreDisplay();
                    updateTargetScoreDisplay();
                } else if (gameMode === "freeMode") {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                } else if (gameMode === "classification") {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                }
                updateGameModeUI();
                requestAnimationFrame(draw);
            }
            setTimeout(() => {
                updateMainButtonStates();
            }, 0);
            infoPanel.classList.remove('centered-panel');

            if (panelOpenedFromSplash && splashScreen && !splashScreen.classList.contains('hidden')) {
                if (gameContainer) gameContainer.classList.add('hidden');
                panelOpenedFromSplash = false;
            }
        }
        
        configButton.addEventListener('click', () => {
            if (areSfxEnabled) playSound('modeSwitch');
            if (gameMode === 'freeMode') openFreeSettingsPanel();
            else openSettingsPanel();
        });
        if (applyFreeSettingsBottomButton) applyFreeSettingsBottomButton.addEventListener('click', applyFreeSettings);
        if (freeDifficultySelector) freeDifficultySelector.addEventListener('change', () => {
            freeDifficulty = freeDifficultySelector.value;
            if (freeDifficulty === 'personalizado') {
                if (playerProfiles[currentPlayerName] && playerProfiles[currentPlayerName].freeModeSettings) {
                    freeModeSettings = { ...FREE_MODE_DEFAULTS, ...playerProfiles[currentPlayerName].freeModeSettings };
                } else {
                    freeModeSettings = { ...FREE_MODE_DEFAULTS };
                }
            } else {
                freeModeSettings = { ...FREE_MODE_DEFAULTS, ...DIFFICULTY_SETTINGS[freeDifficulty] };
            }
            difficulty = freeDifficulty;
            if (!gameIntervalId) {
                snakeSpeed = freeModeSettings.speed;
                initialSnakeLength = freeModeSettings.initialLength;
            }
            populateFreeSettingsInputs();
            displayHighScoreInPanel();
            updateFreeSettingsLockState();
        });
        closeFreeSettingsButton.addEventListener('click', closeFreeSettingsPanel);
        closeSettingsButton.addEventListener('click', closeSettingsPanel);
        backButton.addEventListener('click', () => {
            if (areSfxEnabled) playSound('modeSwitch');
            handleBackButtonClick();
        });
        closeInfoButton.addEventListener('click', closeInfoPanel);

        function openResetConfirmPanel() {
            if (!panelOpenedFromSplash) return;
            resetConfirmPanel.classList.add('centered-panel');
            togglePanel(settingsPanel, settingsPanelContent, false);
            togglePanel(resetConfirmPanel, resetConfirmPanelContent, true);
        }

        function closeResetConfirmPanel() {
            togglePanel(resetConfirmPanel, resetConfirmPanelContent, false);
            resetConfirmPanel.classList.remove('centered-panel');
        }

        if (resetDataButton) {
            resetDataButton.addEventListener('click', openResetConfirmPanel);
        }
        if (confirmResetNoButton) {
            confirmResetNoButton.addEventListener('click', () => {
                closeResetConfirmPanel();
                togglePanel(settingsPanel, settingsPanelContent, true);
            });
        }
        if (confirmResetYesButton) {
            confirmResetYesButton.addEventListener('click', () => {
                localStorage.clear();
                window.location.reload();
            });
        }

        // --- Specific Info Panel Logic ---
        const specificHelpTexts = {
            difficulty: {
                title: "Modo Clasificación",
                image: "https://i.imgur.com/19iGpfZ.png",
                text_classification: "<p>¡Demuestra de lo que eres capaz y compite por lo más alto!</p> <p><strong>Selecciona la dificultad</strong> que prefieras y trata de superar tus propios récords.</p><p>También puedes <strong>compartir el juego</strong> con amigos y familia. Solo asegúrate de que seleccionan su perfil antes de empezar, ¡y que intenten superarte si pueden!</p> <p>¿Estás listo para luchar por la <strong>primera posición</strong> del ranking?</p>"
            },
            freeDifficulty: {
                title: "Modo Libre",
                image: "https://i.imgur.com/qvL4cd8.png",
                text: "<p>Disfruta de una experiencia <strong>totalmente personalizada</strong>.</p> <p>Elige el nivel de dificultad que prefieras para <strong>ajustar automáticamente</strong> la configuración de la partida.</p> <p>También puedes seleccionar la opción <strong>Personalizado</strong> para ajustar tu propia configuración de partida.</p><p>Cada jugador puede tener su configuración individual: Elige las opciones que prefieras, pulsa el botón <strong>Guardar</strong>, y podrás reutilizarla en futuras partidas.</p><p>¡Juega a tu ritmo y desafíate como quieras!</p>"
            },
            world: {
                title: "Modo Aventura",
                image: "https://i.imgur.com/tLBeddL.png",
                text: "<p>¡Supera todos los Mundos y completa la aventura!</p> <p>Explora <strong>10 escenarios únicos</strong>, cada uno con nuevos elementos de juego y <strong>5 niveles</strong> de dificultad progresiva que pondrán a prueba tus habilidades.</p> <p>Avanza superando desafíos y <strong>desbloquea nuevos mundos</strong> en tu recorrido.</p> <p><strong>Continúa</strong> donde lo dejaste o <strong>regresa</strong> a niveles ya completados para volver a disfrutar de la experiencia.</p> <p>¡Y esto es solo el comienzo! Muy pronto llegarán actualizaciones con <strong>nuevas aventuras</strong>.</p>"
            },
            mazeLevel: {
                title: "Modo Laberinto",
                image: "https://i.imgur.com/XLdIK3D.png",
                text: "<p>¡Pon a prueba tu ingenio y reflejos en <strong>10 laberintos únicos</strong>!</p> <p>La distribución de bloques en cada nivel cambia la forma de jugar, conviertiendo cada partida en una experiencia diferente.</p> <p>Acumula puntos para conseguir al menos <strong>3 estrellas</strong> y desbloquear nuevos laberintos, o trata de lograr las <strong>5 estrellas</strong> en todos para desbloquear increíbles sorpresas.</p> <p>¿Tendrás lo que hace falta para <strong>completar todos los niveles</strong> y alcanzar la <strong>puntuación perfecta</strong> en cada uno?</p>"
            },
            skin: {
                title: "Disfraz",
                text: "<p>Desbloquea disfraces con estética temática u original, juega con el look que más te guste y convierte tu experiencia en algo único y divertido</p><p>La elección del disfraz es <strong>puramente estética</strong>.<p>¡Así que <strong>siéntete libre de experimentar</strong> sin preocuparte por ventajas o desventajas en el juego!</p>"
            },
            food: {
                title: "Comestible",
                text: "<p>Selecciona el alimento que quieres que aparezca en el escenario entre todos los que hayas desbloqueado. Esta elección <strong>solo afecta al aspecto visual</strong> y no modifica la jugabilidad.</p>"
            },
            playerName: {
                title: "Jugador",
                text: "<p>En el <strong>Modo Libre</strong>, se utiliza para guardar los ajustes personalizados de la partida, en el <strong>Modo Clasificación</strong>, tu nombre se mostrará en el ranking para que puedas comparar tu puntuación con otros jugadores y, en el <strong>Modo Aventura</strong> y el <strong>Modo Laberinto</strong>, te permite guardar tus progresos y continuar donde la habías dejado.</p><p>Si deseas <strong>registrar a un nuevo jugador</strong>, puedes hacerlo desde el menú de configuración de la pantalla de inicio.</p>"
            },
            audioGeneral: {
                title: "Audio General",
                text: "<p>Controla los elementos sonoros del juego para crear la atmósfera perfecta para ti.</p><p>Selecciona <strong>Activado</strong> para disfrutar de música y efectos, <strong>Sólo Música</strong> para escuchar únicamente la banda sonora, <strong>Sólo Efectos</strong> para oír exclusivamente las acciones clave y <strong>Desactivado</strong> para silenciar completamente el juego." 
            },
            musicVolume: {
                title: "Volumen Música",
                text: "<p>Ajusta con precisión qué tan fuerte o suave quieres que suene la música de fondo del juego, siempre que la tengas activada.</p><p>Mueve el deslizador hacia la derecha para aumentar el volumen, y hacia la izquierda para disminuirlo.</p>"
            },
            sfxVolume: {
                title: "Volumen Efectos",
                text: "<p>Controla la intensidad de los efectos de sonido del juego. Desliza hacia la derecha para escucharlos con más fuerza o hacia la izquierda para suavizarlos.</p>"
            }
        };

        function openSpecificInfoPanel(settingKey) {
            if (!specificInfoPanel || !specificInfoTitle || !specificInfoContent) return;

            if (settingKey === 'difficulty' && gameMode !== 'classification') {
                settingKey = 'freeDifficulty';
            }

            let helpData = specificHelpTexts[settingKey];
            if (!helpData) {
                console.error(`No help text found for setting: ${settingKey}`);
                return;
            }

            const imgTag = helpData.image ?
                `<img src="${helpData.image}" alt="${helpData.title}" onerror="this.src='https://placehold.co/300x80/02030D/FFFFFF?text=Title+Error'; console.error('Error loading specific-info-title image');">` :
                helpData.title;

            if (settingKey === 'difficulty') {
                // In classification mode show the dedicated title
                specificInfoTitle.innerHTML = imgTag;
                specificInfoContent.innerHTML = helpData.text_classification;
            } else {
                specificInfoTitle.innerHTML = imgTag;
                specificInfoContent.innerHTML = helpData.text;
            }
            
            // Determine which configuration panel is open and disable its controls
            let sourcePanel = null;
            if (!settingsPanel.classList.contains('settings-panel-hidden')) {
                sourcePanel = settingsPanel;
            } else if (freeSettingsPanel && !freeSettingsPanel.classList.contains('free-settings-panel-hidden')) {
                sourcePanel = freeSettingsPanel;
            }
            if (sourcePanel) {
                Array.from(sourcePanel.querySelectorAll('select, input[type="range"], .setting-info-button')).forEach(el => el.disabled = true);
                Array.from(sourcePanel.querySelectorAll('.control-group.interactive-mode')).forEach(el => el.classList.remove("interactive-mode")); // Visually indicate disabled state
            }

            specificInfoPanel.classList.add('centered-panel');
            togglePanel(specificInfoPanel, specificInfoContent, true);
            if (sourcePanel) {
                requestAnimationFrame(() => {
                    matchPanelSizeWithElement(sourcePanel, specificInfoPanel);
                    specificInfoPanel.classList.remove('centered-panel');
                    applyScrollbarPadding(specificInfoContent);
                });
            }
        }

        function closeSpecificInfoPanel() {
            togglePanel(specificInfoPanel, specificInfoContent, false); // Hide specific info panel
            specificInfoPanel.classList.remove('centered-panel');

            // Re-enable controls depending on which configuration panel is visible
            let targetPanel = null;
            if (!settingsPanel.classList.contains("settings-panel-hidden") && !gameIntervalId) {
                targetPanel = settingsPanel;
            } else if (freeSettingsPanel && !freeSettingsPanel.classList.contains("free-settings-panel-hidden") && !gameIntervalId) {
                targetPanel = freeSettingsPanel;
            }

            if (targetPanel) {
                targetPanel.querySelectorAll('select, input[type="range"], .setting-info-button').forEach(el => el.disabled = false);

                if (targetPanel === settingsPanel) {
                    skinControlGroup.classList.add("interactive-mode");
                    foodControlGroup.classList.add("interactive-mode");

                    if (gameMode === 'levels') {
                        worldsSelector.disabled = false;
                    } else if (gameMode === 'maze') {
                        mazeLevelButtonsContainer.classList.remove('disabled');
                    } else {
                        difficultySelector.disabled = false;
                    }
                    difficultyControlGroup.classList.add("interactive-mode");

                    if (typeof Tone !== 'undefined') {
                        if (panelOpenedFromSplash) {
                            audioControlGroup.classList.remove('hidden');
                            musicVolumeControlGroup.classList.remove('hidden');
                            sfxVolumeControlGroup.classList.remove('hidden');
                            audioToggleSelector.disabled = false;
                            audioControlGroup.classList.add("interactive-mode");
                            musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                            sfxVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'music_only');
                            if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                            else musicVolumeControlGroup.classList.remove("interactive-mode");
                            if (!sfxVolumeSlider.disabled) sfxVolumeControlGroup.classList.add("interactive-mode");
                            else sfxVolumeControlGroup.classList.remove("interactive-mode");
                        } else {
                            audioToggleSelector.disabled = true;
                            musicVolumeSlider.disabled = true;
                            sfxVolumeSlider.disabled = true;
                            audioControlGroup.classList.add('hidden');
                            musicVolumeControlGroup.classList.add('hidden');
                            sfxVolumeControlGroup.classList.add('hidden');
                            audioControlGroup.classList.remove("interactive-mode");
                            musicVolumeControlGroup.classList.remove("interactive-mode");
                            sfxVolumeControlGroup.classList.remove("interactive-mode");
                        }
                    }
                    playerNameSelectors.forEach(sel => sel.disabled = false);
                    if (panelOpenedFromSplash) {
                        if (playerSelectControlGroup) playerSelectControlGroup.classList.add("interactive-mode");
                        if (addPlayerControlGroup) addPlayerControlGroup.classList.add("interactive-mode");
                    }
                    settingsPanel.querySelectorAll('.setting-info-button').forEach(btn => btn.disabled = false);
                } else {
                    // Free settings panel - restore inputs based on difficulty selection
                    updateFreeSettingsLockState();
                }

                // Ensure main action buttons reflect that a configuration panel is still the context
                startButton.disabled = true;
                configButton.disabled = true;
                backButton.disabled = true;
            } else {
                // If no configuration panel was open, update main buttons normally
                updateMainButtonStates();
            }
        }


        if (closeSpecificInfoButton) {
            closeSpecificInfoButton.addEventListener('click', closeSpecificInfoPanel);
        }

        function maybeShowInitialHelpForMode(mode) {
            const storageKey = `snakeHelpShown_${mode}`;
            if (!localStorage.getItem(storageKey)) {
                let settingKey = null;
                if (mode == 'levels') settingKey = 'world';
                else if (mode == 'freeMode') settingKey = 'freeDifficulty';
                else if (mode == 'classification') settingKey = 'difficulty';
                else if (mode == 'maze') settingKey = 'mazeLevel';
                if (settingKey) {
                    openSpecificInfoPanel(settingKey);
                    localStorage.setItem(storageKey, 'true');
                }
            }
        }
        document.querySelectorAll('.setting-info-button').forEach(button => {
            const icon = button.querySelector('.setting-info-icon');
            const settingKey = button.dataset.setting;
            if (settingKey) {
                button.addEventListener('click', () => {
                    if (areSfxEnabled) playSound('modeSwitch');
                    openSpecificInfoPanel(settingKey);
                });
            } else {
                button.addEventListener('click', () => {
                    if (areSfxEnabled) playSound('modeSwitch');
                });
            }
            if (icon) {
                button.addEventListener('mousedown', () => icon.classList.add('icon-button-pressed'));
                button.addEventListener('mouseup', () => icon.classList.remove('icon-button-pressed'));
                button.addEventListener('mouseleave', () => icon.classList.remove('icon-button-pressed'));
                button.addEventListener('touchstart', () => icon.classList.add('icon-button-pressed'));
                button.addEventListener('touchend', () => icon.classList.remove('icon-button-pressed'));
                button.addEventListener('touchcancel', () => icon.classList.remove('icon-button-pressed'));
            }
        });

        if (worldInfoButton) {
            worldInfoButton.addEventListener('click', () => {
                if (areSfxEnabled) playSound('modeSwitch');
                openSpecificInfoPanel('world');
            });
        }

        if (currentWorldInfoGroup) {
            currentWorldInfoGroup.addEventListener('click', () => {
                const isSettingsOpen = !settingsPanel.classList.contains('settings-panel-hidden');
                const isInfoOpen = !infoPanel.classList.contains('info-panel-hidden');
                const isSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains('specific-info-panel-hidden');
                if (isSettingsOpen || isInfoOpen || isSpecificInfoOpen || gameIntervalId || showModeSelect) return;

                // Reset any result screens that may be showing
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;

                if (gameMode === 'levels') {
                    displayWorld = currentWorld;
                    displayLevelInWorld = currentLevelInWorld;
                    const absoluteIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteIndex] || 0;
                    screenState.showCoverForWorld = currentWorld;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                    screenState.showMazeCover = false;
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    screenState.showCoverForWorld = 0;
                    screenState.showClassificationCover = false;
                    screenState.showMazeCover = false;
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.showCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showMazeCover = false;
                } else if (gameMode === 'maze') {
                    displayMazeLevel = currentMazeLevel;
                    mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                    mazeStarsEarned = mazePreviousStars;
                    if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                        displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                    } else {
                        displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                    }
                    screenState.showMazeCover = true;
                    screenState.showCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                    screenState.mazeResultType = '';
                } else {
                    return;
                }

                screenState.gameActuallyStarted = false;
                updateGameModeUI();
                updateMainButtonStates();
                requestAnimationFrame(draw);
            });
        }


        function drawFoodItem(x, y) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS['apple'];
            const foodImg = foodData.asset;
            
            let foodVisualTopY;
            let foodVisualHeight;

            if (foodImg && foodImg.complete && foodImg.naturalHeight !== 0) {
                const drawSize = GRID_SIZE * foodData.scale;
                const offset = (drawSize - GRID_SIZE) / 2;
                foodVisualTopY = y * GRID_SIZE - offset;
                foodVisualHeight = drawSize;
            } else {
                foodVisualTopY = y * GRID_SIZE + 2; 
                foodVisualHeight = GRID_SIZE - 4; 
            }
            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            let foodIsVisible = true;
            if (!gameOver && foodTimeRemaining <= FOOD_WARNING_TIME && foodTimeRemaining > 0) {
                const blinkInterval = 500; 
                foodIsVisible = (Math.floor(foodTimeRemaining / blinkInterval) % 2 !== 0);
            }

            if (foodIsVisible && (foodTimeRemaining > 0 || currentFoodItem.initialLifespanForThisFood === 0)) {
                if (foodImg && foodImg.complete && foodImg.naturalHeight !== 0) {
                    const drawSize = GRID_SIZE * foodData.scale;
                    const offset = (drawSize - GRID_SIZE) / 2;
                    if (currentFoodItem.isGolden) {
                        ctx.filter = 'hue-rotate(-50deg) brightness(1.4)';
                    }
                    ctx.drawImage(foodImg, x * GRID_SIZE - offset, y * GRID_SIZE - offset, drawSize, drawSize);
                    ctx.filter = 'none';
                } else {
                    ctx.fillStyle = currentFoodItem.isGolden ? 'gold' : FOOD_SHAPE_FALLBACK.color;
                    ctx.fillRect(x * GRID_SIZE + 2, y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                    ctx.strokeStyle = FOOD_SHAPE_FALLBACK.borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x * GRID_SIZE + 2, y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                }
            }

            if (!gameOver && foodTimeRemaining > 0 && currentFoodItem.initialLifespanForThisFood > 0) {
                const barProgress = foodTimeRemaining / currentFoodItem.initialLifespanForThisFood;
                const barWidth = (GRID_SIZE - 4) * barProgress; 
                const barHeight = 3;
                const barGap = 2; 

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                   timeBarYPosition = canvasEl.height - barHeight -1; 
                }
                 if (timeBarYPosition < 0){ 
                       timeBarYPosition = 1; 
                }
                
                let barColor = 'rgba(76, 175, 80, 0.85)'; 
                const percentageRemaining = (foodTimeRemaining / currentFoodItem.initialLifespanForThisFood) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)'; 
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)'; 
                }
                
                ctx.fillStyle = barColor;
                ctx.fillRect(
                    x * GRID_SIZE + 2, 
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }
        
        function calculateNextFoodLifespan() {
            let baseLifespan;
            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                baseLifespan = levelCfg.initialLifespan || 0;
            } else if (gameMode === 'classification') {
                baseLifespan = DIFFICULTY_SETTINGS[difficulty].initialLifespan;
            } else {
                baseLifespan = freeModeSettings.initialLifespan;
            }
            if (baseLifespan <= 0) return 0;
            let streakReduction = 0;
            const effectiveStreak = Math.min(streakMultiplier, MAX_STREAK);
            if (effectiveStreak > 1) {
                // Reduce food lifespan by 0.5 s per 0.5 streak increase
                const reductionPerStep = (gameMode === 'classification' ? DIFFICULTY_SETTINGS[difficulty].streakReduction : freeModeSettings.streakReduction) || 1000;
                streakReduction = (effectiveStreak - 1) * reductionPerStep;
            }
            const calculatedLifespan = baseLifespan - streakReduction;
            return Math.max(MIN_FOOD_LIFESPAN, calculatedLifespan);
        }

        function generateFood() {
            clearTimeout(foodDisappearTimeoutId);
            clearInterval(foodVisualTimerIntervalId);
            lastWarningSoundSecond = -1; 
            let newFoodPosition;
            do {
                newFoodPosition = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                };
            } while ((isFoodOnSnake(newFoodPosition) || obstacles.some(ob => ob.x === newFoodPosition.x && ob.y === newFoodPosition.y)) && tileCountX > 0 && tileCountY > 0);
            
            if (tileCountX <=0 || tileCountY <=0) { 
                console.warn("Canvas too small to generate food.");
                currentFoodItem = {}; 
                return;
            }

            const classificationRank = CLASSIFICATION_RANKS[difficulty] || 0;
            const diffCfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficulty] || {}) : freeModeSettings;
            const goldenChance = diffCfg.goldenFoodChance !== undefined ? diffCfg.goldenFoodChance : GOLDEN_FOOD_CHANCE;
            const isGolden = ((gameMode === 'levels' && currentWorld === 5) || (gameMode === 'classification' && classificationRank >= 1) || gameMode === 'freeMode') && Math.random() < goldenChance;
            let lifespan = calculateNextFoodLifespan();
            if (isGolden) {
                if (gameMode === 'classification' && classificationRank === 1 && diffCfg.goldenFoodLifespan === undefined) {
                    lifespan = GOLDEN_FOOD_LIFESPAN_CLASSIF_RANK1;
                } else if (gameMode === 'levels') {
                    lifespan = GOLDEN_FOOD_LIFESPANS_WORLD5[currentLevelInWorld - 1] || lifespan;
                } else if (gameMode === 'freeMode' && diffCfg.goldenFoodLifespan !== undefined) {
                    lifespan = diffCfg.goldenFoodLifespan;
                } else if (diffCfg.goldenFoodLifespan !== undefined) {
                    lifespan = diffCfg.goldenFoodLifespan;
                }
            }
            currentFoodItem = {
                x: newFoodPosition.x,
                y: newFoodPosition.y,
                isGolden,
                initialLifespanForThisFood: lifespan
            };
            foodTimeRemaining = currentFoodItem.initialLifespanForThisFood;
            if (foodTimeRemaining > 0) {
                foodDisappearTimeoutId = setTimeout(handleFoodTimeout, foodTimeRemaining);
                foodVisualTimerIntervalId = setInterval(() => {
                if (gameOver) {
                    clearInterval(foodVisualTimerIntervalId);
                    return;
                }
                foodTimeRemaining -= 100;
                if (foodTimeRemaining < 0) foodTimeRemaining = 0;
                if (foodTimeRemaining <= FOOD_WARNING_TIME && foodTimeRemaining > 0) {
                    const currentSecondInWarning = Math.ceil(foodTimeRemaining / 1000);
                    if (currentSecondInWarning !== lastWarningSoundSecond) { 
                        if (areSfxEnabled) playSound('warning');
                        lastWarningSoundSecond = currentSecondInWarning;
                    }
                } else {
                    lastWarningSoundSecond = -1; 
                }
            }, 100);
            } else {
                foodDisappearTimeoutId = null;
                foodVisualTimerIntervalId = null;
            }
        }
        
        function handleFoodTimeout() {
            if (gameOver) return;
            console.log("¡Comida no recogida! Racha perdida."); 
            if (areSfxEnabled) playSound('timeout');
            streakMultiplier = 1;
            const classRank = CLASSIFICATION_RANKS[difficulty] || 0;
            if ((gameMode === 'levels' && currentWorld >= 6) || (gameMode === 'classification' && classRank >= 2)) {
                startStreakAnimation(streakMultiplier);
            }
            foodTimeRemaining = 0;
            generateFood(); 
            updateScoreDisplay();
            draw(); 
        }

        function isFoodOnSnake(foodPosition) {
            for (let segment of snake) {
                if (segment.x === foodPosition.x && segment.y === foodPosition.y) {
                    return true;
                }
            }
            return false;
        }

        function isAdjacentToAnyFood(pos) {
            if (currentFoodItem.x !== undefined) {
                if (Math.abs(currentFoodItem.x - pos.x) <= 1 && Math.abs(currentFoodItem.y - pos.y) <= 1) {
                    return true;
                }
            }
            for (let ff of falseFoodItems) {
                if (Math.abs(ff.x - pos.x) <= 1 && Math.abs(ff.y - pos.y) <= 1) {
                    return true;
                }
            }
            return false;
        }

        function isAdjacentToAnyObstacle(pos) {
            for (let ob of obstacles) {
                if (Math.abs(ob.x - pos.x) <= 1 && Math.abs(ob.y - pos.y) <= 1) {
                    return true;
                }
            }
            return false;
        }

        function drawFalseFoodItem(item) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS["apple"];
            const img = foodData.asset;
            let foodVisualTopY;
            let foodVisualHeight;
            if (img && img.complete && img.naturalHeight !== 0) {
                const size = GRID_SIZE * foodData.scale;
                const off = (size - GRID_SIZE) / 2;
                foodVisualTopY = item.y * GRID_SIZE - off;
                foodVisualHeight = size;
                drawImageWithTint(ctx, img, item.x * GRID_SIZE - off, item.y * GRID_SIZE - off, size, size, 'rgba(255,0,0,0.2)');
            } else {
                foodVisualTopY = item.y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(item.x * GRID_SIZE + 2, item.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            }

            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            if (!gameOver && item.remaining > 0) {
                const totalLifespan = item.lifespan || FALSE_FOOD_LIFESPAN;
                const barProgress = item.remaining / totalLifespan;
                const barWidth = (GRID_SIZE - 4) * barProgress;
                const barHeight = 3;
                const barGap = 2;

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                    timeBarYPosition = canvasEl.height - barHeight - 1;
                }
                if (timeBarYPosition < 0) {
                    timeBarYPosition = 1;
                }

                let barColor = 'rgba(76, 175, 80, 0.85)';
                const percentageRemaining = (item.remaining / totalLifespan) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)';
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)';
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(
                    item.x * GRID_SIZE + 2,
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }

        function drawObstacle(ob) {
            if (!ctx) return;
            const drawSize = GRID_SIZE;
            const img = ob.img || obstacleImg;
            const offset = 0;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, ob.x * GRID_SIZE - offset, ob.y * GRID_SIZE - offset, drawSize, drawSize);
            } else {
                ctx.fillStyle = "#555";
                ctx.fillRect(ob.x * GRID_SIZE - offset, ob.y * GRID_SIZE - offset, drawSize, drawSize);
            }
        }

        function drawLightningItem(item) {
            if (!ctx) return;
            const img = item.color === 'yellow' ? lightningYellowImg : lightningRedImg;
            const drawSize = GRID_SIZE * 1.5;
            const offset = (drawSize - GRID_SIZE) / 2;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, item.x * GRID_SIZE - offset, item.y * GRID_SIZE - offset, drawSize, drawSize);
            } else {
                const color = item.color === 'yellow' ? 'yellow' : 'red';
                ctx.fillStyle = color;
                ctx.fillRect(item.x * GRID_SIZE + 2 - offset, item.y * GRID_SIZE + 2 - offset, GRID_SIZE - 4 + (drawSize - GRID_SIZE), GRID_SIZE - 4 + (drawSize - GRID_SIZE));
            }
        }

        function removeFalseFoodItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = falseFoodItems.indexOf(item);
            if (idx !== -1) falseFoodItems.splice(idx, 1);
        }

        function generateFalseFood() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos;
            let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isFoodOnSnake(pos) ||
                    (currentFoodItem.x === pos.x && currentFoodItem.y === pos.y) ||
                    falseFoodItems.some(f => f.x === pos.x && f.y === pos.y) ||
                    isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let lifespan = FALSE_FOOD_LIFESPAN;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (typeof cfg.falseFoodLifespan === 'number') {
                    lifespan = cfg.falseFoodLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeFalseFoodItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeFalseFoodItem(item); }, 100);
            falseFoodItems.push(item);
        }

        function scheduleNextFalseFoodSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (!cfg.falseFoodSpawnRange) return;
                range = cfg.falseFoodSpawnRange;
            } else if (gameMode === "levels" && (currentWorld === 7 || currentWorld === 8 || currentWorld === 10)) {
                if (currentWorld === 7) {
                    range = FALSE_FOOD_SPAWN_RANGES_WORLD4[currentLevelInWorld - 1] || [5000,8000];
                } else if (currentWorld === 10) {
                    range = FALSE_FOOD_SPAWN_RANGES_WORLD8[currentLevelInWorld - 1] || [5000,7000];
                } else {
                    range = FALSE_FOOD_SPAWN_RANGE_WORLD5;
                }
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            falseFoodSpawnTimeoutId = setTimeout(() => {
                generateFalseFood();
                scheduleNextFalseFoodSpawn();
            }, delay);
        }

        function startWorld4FalseFoodMechanics() {
            stopWorld4FalseFoodMechanics();
            scheduleNextFalseFoodSpawn();
        }

        function stopWorld4FalseFoodMechanics() {
            if (falseFoodSpawnTimeoutId) {
                clearTimeout(falseFoodSpawnTimeoutId);
                falseFoodSpawnTimeoutId = null;
            }
            falseFoodItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            falseFoodItems = [];
        }

        function generateWorld5Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : (OBSTACLE_COUNTS_WORLD5[currentLevelInWorld - 1] || 0);
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isFoodOnSnake(pos) ||
                          obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld5Obstacles(customCount) {
            generateWorld5Obstacles(customCount);
        }

        function stopWorld5Obstacles() {
            obstacles = [];
        }

        function generateWorld6Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : OBSTACLE_COUNT_WORLD6;
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isFoodOnSnake(pos) ||
                          obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld6Obstacles(customCount) {
            generateWorld6Obstacles(customCount);
        }

        function stopWorld6Obstacles() {
            obstacles = [];
        }

        function generateWorld8Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : (OBSTACLE_COUNTS_WORLD8[currentLevelInWorld - 1] || 0);
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isFoodOnSnake(pos) ||
                          obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld8Obstacles(customCount) {
            generateWorld8Obstacles(customCount);
        }

        function stopWorld8Obstacles() {
            obstacles = [];
        }

        function removeLightningItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = lightningItems.indexOf(item);
            if (idx !== -1) lightningItems.splice(idx, 1);
        }

        function generateLightning() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos; let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isFoodOnSnake(pos) ||
                    obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                    lightningItems.some(l => l.x === pos.x && l.y === pos.y) ||
                    isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let redChance = 0.25;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (typeof cfg.redLightningChance === 'number') {
                    redChance = cfg.redLightningChance;
                }
            }
            const color = Math.random() < redChance ? 'red' : 'yellow';
            let lifespan = LIGHTNING_LIFESPAN;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (typeof cfg.lightningLifespan === 'number') {
                    lifespan = cfg.lightningLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, color, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeLightningItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeLightningItem(item); }, 100);
            lightningItems.push(item);
        }

        function scheduleNextLightningSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === "classification" || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (!cfg.lightningSpawnRange) return;
                range = cfg.lightningSpawnRange;
            } else if (gameMode === "levels" && (currentWorld === 3 || currentWorld === 4 || currentWorld === 9 || currentWorld === 10)) {
                if (currentWorld === 3) {
                    range = LIGHTNING_SPAWN_RANGES_WORLD6[currentLevelInWorld - 1] || [5000, 7000];
                } else if (currentWorld === 4) {
                    range = LIGHTNING_SPAWN_RANGE_WORLD4;
                } else if (currentWorld === 10) {
                    range = LIGHTNING_SPAWN_RANGES_WORLD8[currentLevelInWorld - 1] || [5000, 7000];
                } else {
                    range = LIGHTNING_SPAWN_RANGE_WORLD7;
                }
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            lightningSpawnTimeoutId = setTimeout(() => {
                generateLightning();
                scheduleNextLightningSpawn();
            }, delay);
        }

        function startWorld6LightningMechanics() {
            stopWorld6LightningMechanics();
            scheduleNextLightningSpawn();
        }

        function stopWorld6LightningMechanics() {
            if (lightningSpawnTimeoutId) {
                clearTimeout(lightningSpawnTimeoutId);
                lightningSpawnTimeoutId = null;
            }
            lightningItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            lightningItems = [];
        }

        function drawMirrorItem(item) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS["apple"];
            const img = foodData.asset;
            let foodVisualTopY;
            let foodVisualHeight;
            if (img && img.complete && img.naturalHeight !== 0) {
                const size = GRID_SIZE * foodData.scale;
                const off = (size - GRID_SIZE) / 2;
                foodVisualTopY = item.y * GRID_SIZE - off;
                foodVisualHeight = size;
                drawImageWithTint(ctx, img, item.x * GRID_SIZE - off, item.y * GRID_SIZE - off, size, size, 'rgba(0,0,255,0.2)');
            } else {
                foodVisualTopY = item.y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(item.x * GRID_SIZE + 2, item.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            }

            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            if (!gameOver && item.remaining > 0) {
                const totalLifespan = item.lifespan || FALSE_FOOD_LIFESPAN;
                const barProgress = item.remaining / totalLifespan;
                const barWidth = (GRID_SIZE - 4) * barProgress;
                const barHeight = 3;
                const barGap = 2;

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                    timeBarYPosition = canvasEl.height - barHeight - 1;
                }
                if (timeBarYPosition < 0) {
                    timeBarYPosition = 1;
                }

                let barColor = 'rgba(76, 175, 80, 0.85)';
                const percentageRemaining = (item.remaining / totalLifespan) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)';
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)';
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(
                    item.x * GRID_SIZE + 2,
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }

        function removeMirrorItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = mirrorItems.indexOf(item);
            if (idx !== -1) mirrorItems.splice(idx, 1);
        }

        function generateMirror() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos; let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isFoodOnSnake(pos) ||
                    obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                    mirrorItems.some(m => m.x === pos.x && m.y === pos.y) ||
                    isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let lifespan = FALSE_FOOD_LIFESPAN;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (typeof cfg.mirrorLifespan === 'number') {
                    lifespan = cfg.mirrorLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeMirrorItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeMirrorItem(item); }, 100);
            mirrorItems.push(item);
        }

        function scheduleNextMirrorSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === 'classification' || gameMode === 'freeMode') {
                const cfg = (gameMode === 'classification') ? (DIFFICULTY_SETTINGS[difficultySelector.value] || {}) : freeModeSettings;
                if (!cfg.mirrorSpawnRange) return;
                range = cfg.mirrorSpawnRange;
            } else if (gameMode === "levels" && (currentWorld === 9 || currentWorld === 10)) {
                range = currentWorld === 9 ?
                    (MIRROR_SPAWN_RANGES_WORLD7[currentLevelInWorld - 1] || [5000, 7000]) :
                    (MIRROR_SPAWN_RANGES_WORLD8[currentLevelInWorld - 1] || [5000, 7000]);
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            mirrorSpawnTimeoutId = setTimeout(() => {
                generateMirror();
                scheduleNextMirrorSpawn();
            }, delay);
        }

        function startWorld7MirrorMechanics() {
            stopWorld7MirrorMechanics();
            scheduleNextMirrorSpawn();
        }

        function stopWorld7MirrorMechanics() {
            if (mirrorSpawnTimeoutId) {
                clearTimeout(mirrorSpawnTimeoutId);
                mirrorSpawnTimeoutId = null;
            }
            mirrorItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            mirrorItems = [];
            controlsInverted = false;
            mirrorEffect = { active: false, startTime: 0 };
        }

        function generateMazeLevel(levelIndex) {
            obstacles = [];
            const layout = MAZE_LAYOUTS[levelIndex];
            if (layout) {
                obstacles = layout.map(pos => ({ x: pos.x, y: pos.y, img: obstacleImg }));
            }
        }

        function startMazeLevel() {
            generateMazeLevel(displayMazeLevel);
        }

        function stopMazeLevel() {
            obstacles = [];
        }

        function applySpeedChange(change) {
            clearInterval(gameIntervalId);
            snakeSpeed = Math.max(50, snakeSpeed + change);
            gameIntervalId = setInterval(update, snakeSpeed);
        }

        function activateSpeedBoost(color) {
            const change = color === 'yellow' ? -25 : -50;
            if (speedBoost.active) {
                applySpeedChange(-speedBoost.change);
            }
            applySpeedChange(change);
            speedBoost = { active: true, color, change, startTime: Date.now() };
        }

        function updateSpeedBoost() {
            if (!speedBoost.active) return;
            const elapsed = Date.now() - speedBoost.startTime;
            if (elapsed >= SPEED_BOOST_DURATION) {
                applySpeedChange(-speedBoost.change);
                speedBoost.active = false;
            }
        }
        function splitTextIntoLines(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            if (words.length === 0) return lines;
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + " " + word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth < maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // --- High Score Functions ---
        function getHighScoreKey(difficultyLevel) {
            return `snakeHighScores_${difficultyLevel}`;
        }

        function loadHighScores(difficultyLevel) {
            const key = getHighScoreKey(difficultyLevel);
            const scoresJSON = localStorage.getItem(key);
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function getClassificationHighScoreKey(difficultyLevel) {
            return `snakeClassificationHighScores_${difficultyLevel}`;
        }

        function loadClassificationHighScores(difficultyLevel) {
            const key = getClassificationHighScoreKey(difficultyLevel);
            const scoresJSON = localStorage.getItem(key);
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function saveClassificationHighScore(currentScore, timeValue, difficultyLevel) {
            const key = getClassificationHighScoreKey(difficultyLevel);
            let highScores = loadClassificationHighScores(difficultyLevel);
            const newEntry = {
                score: currentScore,
                time: timeValue,
                difficulty: DIFFICULTY_DISPLAY_NAMES[difficultyLevel],
                skin: currentSkin,
                playerName: currentPlayerName,
            };

            let insertIndex = highScores.findIndex(entry => {
                if (currentScore > entry.score) return true;
                if (currentScore === entry.score) {
                    if (timeValue < entry.time) return true;
                    if (timeValue === entry.time) return true;
                }
                return false;
            });

            if (insertIndex === -1) {
                highScores.push(newEntry);
                insertIndex = highScores.length - 1;
            } else {
                highScores.splice(insertIndex, 0, newEntry);
            }

            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            localStorage.setItem(key, JSON.stringify(highScores));
            console.log(`Puntuaciones Modo Clasificación guardadas para ${difficultyLevel}:`, highScores);

            const isActuallyNewHighScoreThisGame = insertIndex < MAX_HIGH_SCORES;
            const newRecordIndex = isActuallyNewHighScoreThisGame ? insertIndex : -1;
            return { isNewRecord: isActuallyNewHighScoreThisGame, rowIndex: newRecordIndex };
        }

        function saveHighScore(currentScore, timeValue, difficultyLevel) {
            const key = getHighScoreKey(difficultyLevel);
            let highScores = loadHighScores(difficultyLevel);
            const newEntry = {
                score: currentScore,
                time: timeValue,
                difficulty: DIFFICULTY_DISPLAY_NAMES[difficultyLevel],
                skin: currentSkin, // Guardamos el 'value' del skin actual
            };

            let insertIndex = highScores.findIndex(entry => {
                if (currentScore > entry.score) return true;
                if (currentScore === entry.score) {
                    if (timeValue < entry.time) return true;
                    if (timeValue === entry.time) return true; // Nuevo registro se coloca antes de los empates
                }
                return false;
            });

            if (insertIndex === -1) {
                highScores.push(newEntry);
                insertIndex = highScores.length - 1;
            } else {
                highScores.splice(insertIndex, 0, newEntry);
            }

            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            localStorage.setItem(key, JSON.stringify(highScores));
            console.log(`Puntuaciones guardadas para ${difficultyLevel}:`, highScores);

            const isActuallyNewHighScoreThisGame = insertIndex < MAX_HIGH_SCORES;
            const newRecordIndex = isActuallyNewHighScoreThisGame ? insertIndex : -1;
            return { isNewRecord: isActuallyNewHighScoreThisGame, rowIndex: newRecordIndex };
        }

        // --- Funciones de Refactorización de finalizeGameOver ---
        function clearGameTimersAndMusic() {
            clearInterval(gameIntervalId);
            gameIntervalId = null;
            clearTimeout(foodDisappearTimeoutId);
            clearInterval(foodVisualTimerIntervalId);
            clearInterval(gameTimerIntervalId);
            clearInterval(inactivityIntervalId);
            inactivityIntervalId = null;
            stopWorld4FalseFoodMechanics();
            stopWorld5Obstacles();
            stopWorld6Obstacles();
            stopWorld8Obstacles();
            stopWorld6LightningMechanics();
            stopWorld7MirrorMechanics();

            if (inGameBackgroundMusic) {
                inGameBackgroundMusic.pause();
                console.log("Música de partida pausada (clearGameTimersAndMusic).");
            }
        }

        function handleFreeModeEnd(currentScore, timeElapsedValue, difficultyValue) {
            const highScoreData = saveHighScore(currentScore, timeElapsedValue, difficultyValue);

            console.log("FinalizeGameOver - Modo Libre - isNewRecord:", highScoreData.isNewRecord, "Score:", currentScore, "Time:", timeElapsedValue, "Difficulty:", difficultyValue, "Blink Row Index:", highScoreData.rowIndex);
            
            if (highScoreData.isNewRecord) {
                blinkAnimation.startTime = Date.now();
                blinkAnimation.active = true; 
                console.log("Blink animation activated for new high score.");
            }
            return { isNewRecord: highScoreData.isNewRecord, isEffectivelyWon: highScoreData.isNewRecord, rowIndex: highScoreData.rowIndex };
        }

        function handleClassificationModeEnd(currentScore, timeElapsedValue, difficultyValue) {
            const highScoreData = saveClassificationHighScore(currentScore, timeElapsedValue, difficultyValue);

            console.log("FinalizeGameOver - Modo Clasificación - isNewRecord:", highScoreData.isNewRecord, "Score:", currentScore, "Time:", timeElapsedValue, "Difficulty:", difficultyValue, "Blink Row Index:", highScoreData.rowIndex);

            if (highScoreData.isNewRecord) {
                blinkAnimation.startTime = Date.now();
                blinkAnimation.active = true;
                console.log("Blink animation activated for new classification high score.");
            }
            return { isNewRecord: highScoreData.isNewRecord, isEffectivelyWon: highScoreData.isNewRecord, rowIndex: highScoreData.rowIndex };
        }

        function handleLevelsModeEnd(currentScore, timeRemaining) {
            const absoluteLevelIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
            const currentTarget = TARGET_SCORES_LEVELS[absoluteLevelIndex];
            const levelWon = (currentScore >= currentTarget && timeRemaining > 0);

            if (levelWon) {
                levelsProgress[absoluteLevelIndex] = true; // Se marca la estrella
                worldCurrentLevels[currentWorld - 1] = currentLevelInWorld;

                if (currentLevelInWorld === LEVELS_PER_WORLD) { // Mundo completado
                    screenState.showWorldCompleteCover = currentWorld;

                    if (currentWorld === TOTAL_WORLDS) { // Juego completado
                        startButton.textContent = "Ajustes";
                        // No hay más niveles a los que avanzar. currentWorld y currentLevelInWorld permanecen en el máximo.
                    } else { // Avanzar al siguiente mundo
                        startButton.textContent = "Nuevo Mundo";
                        worldCurrentLevels[currentWorld - 1] = LEVELS_PER_WORLD;
                        currentWorld++;
                        currentLevelInWorld = worldCurrentLevels[currentWorld - 1] || 1;
                        if (currentWorld > maxUnlockedWorld) {
                            maxUnlockedWorld = currentWorld;
                        }
                    }
                } else { // Nivel completado (no es el último del mundo)
                    currentLevelInWorld++; // Avanzamos el nivel inmediatamente
                    screenState.showLevelCompleteCover = currentWorld;
                    startButton.textContent = `Nivel ${currentWorld}.${currentLevelInWorld}`; // Botón para el *nuevo* nivel actual
                }
                // Limpiamos otros estados de pantalla
                screenState.showCoverForWorld = 0;
                screenState.showDefeatCoverForWorld = 0;

            } else { // Nivel perdido
                startButton.textContent = "Reintentar";
                screenState.showDefeatCoverForWorld = currentWorld;
                // Limpiamos otros estados de pantalla por si acaso
                screenState.showCoverForWorld = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
            }
            worldCurrentLevels[currentWorld - 1] = currentLevelInWorld;
            drawStarProgress(); // Dibuja las estrellas con la nueva completada
            return levelWon;
        }

        function handleMazeModeEnd(currentScore, timeRemaining) {
            const isLastLevel = displayMazeLevel === MAZE_LEVEL_COUNT;
            let levelWon = false;
            let resultType = 'fail';

            const levelIndex = displayMazeLevel - 1;
            const previousStars = mazePreviousStars;
            const improved = mazeStarsEarned > previousStars;

            if (isLastLevel && improved && mazeStarsEarned >= 3) {
                levelWon = true;
                resultType = 'final';
                startButton.textContent = 'Ajustes';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            } else if (improved && mazeStarsEarned >= MAZE_STAR_TARGETS.length) {
                levelWon = true;
                if (isLastLevel) {
                    resultType = 'final';
                    startButton.textContent = 'Ajustes';
                } else {
                    resultType = 'perfect';
                    startButton.textContent = 'Continuar';
                }
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            } else if (improved && mazeStarsEarned >= 3) {
                if (!isLastLevel) {
                    levelWon = true;
                    resultType = 'partial';
                    startButton.textContent = 'Continuar';
                    restartMazeButton.classList.remove('hidden');
                    startButtonWrapperEl.classList.add('split');
                } else {
                    startButton.textContent = 'Reintentar';
                    resultType = 'fail';
                    restartMazeButton.classList.add('hidden');
                    startButtonWrapperEl.classList.remove('split');
                }
            } else {
                startButton.textContent = 'Reintentar';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            }

            if (levelWon && !isLastLevel && displayMazeLevel === currentMazeLevel) {
                currentMazeLevel++;
            }

            if (levelIndex >= 0 && levelIndex < MAZE_LEVEL_COUNT && mazeStarsEarned > mazePreviousStars) {
                mazeLevelStars[levelIndex] = mazeStarsEarned;
            }

            saveGameSettings();

            const allStarsAchieved = mazeLevelStars.every(s => s >= MAZE_STAR_TARGETS.length);
            if (levelWon && allStarsAchieved) {
                resultType = 'allstars';
            }

        screenState.mazeResultType = resultType;
        return levelWon;
        }

        function getNextIncompleteMazeLevel(currentLevel) {
            let next = currentLevel + 1;
            while (next <= currentMazeLevel && mazeLevelStars[next - 1] >= MAZE_STAR_TARGETS.length) {
                next++;
            }
            if (next <= currentMazeLevel) {
                return next;
            }
            return currentMazeLevel;
        }


        function playSoundForGameOver(levelWon) {
            if (!areSfxEnabled) return;

            if (gameMode === 'freeMode') {
                if (gameOverByInactivity) {
                    playSound('gameOver');
                } else {
                    playSound('win');
                }
                return;
            }

            if (levelWon) {
                playSound('win');
            } else {
                playSound('gameOver');
            }
        }
        
        function managePostGameOverMusicAndAnimation() {
            if (blinkAnimation.active && gameOver) { 
                requestAnimationFrame(gameEndAnimationLoop);
            } else {
                const isSettingsCurrentlyOpen = settingsPanel && !settingsPanel.classList.contains("settings-panel-hidden");
                const isInfoCurrentlyOpen = infoPanel && !infoPanel.classList.contains("info-panel-hidden");
                if (isMusicEnabled && generalBackgroundMusic && !isSettingsCurrentlyOpen && !isInfoCurrentlyOpen) {
                    if (generalBackgroundMusic.paused) {
                        generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (managePostGameOverMusic):", e));
                        console.log("Música general iniciada (managePostGameOverMusic - no blink).");
                    }
                }
            }
        }
        
        function gameEndAnimationLoop() { // This is the loop for the blinking animation
            if (gameOver && blinkAnimation.active) { 
                draw(); 
                const elapsedTime = Date.now() - blinkAnimation.startTime;
                if (elapsedTime >= blinkAnimation.duration) {
                    blinkAnimation.active = false; 
                    draw(); 
                    managePostGameOverMusicAndAnimation(); // Check for music again once blink is done
                } else {
                    requestAnimationFrame(gameEndAnimationLoop); 
                }
            }
        }

        function updateUIOnGameOver() {
            updateMainButtonStates();

            skinSelector.disabled = false;
            foodSelector.disabled = false;
            skinControlGroup.classList.add("interactive-mode");
            foodControlGroup.classList.add("interactive-mode");

            if (gameMode === 'levels') {
                worldsSelector.disabled = false; 
            } else { 
                difficultySelector.disabled = false;
            }
            difficultyControlGroup.classList.add("interactive-mode");

            if (typeof Tone !== 'undefined') {
                 if (panelOpenedFromSplash) {
                     audioControlGroup.classList.remove('hidden');
                     musicVolumeControlGroup.classList.remove('hidden');
                     sfxVolumeControlGroup.classList.remove('hidden');
                     audioToggleSelector.disabled = false;
                     audioControlGroup.classList.add("interactive-mode");
                     musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                     sfxVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'music_only');
                     if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                     else musicVolumeControlGroup.classList.remove("interactive-mode");
                     if (!sfxVolumeSlider.disabled) sfxVolumeControlGroup.classList.add("interactive-mode");
                     else sfxVolumeControlGroup.classList.remove("interactive-mode");
                 } else {
                     audioToggleSelector.disabled = true;
                     musicVolumeSlider.disabled = true;
                     sfxVolumeSlider.disabled = true;
                     audioControlGroup.classList.add('hidden');
                     musicVolumeControlGroup.classList.add('hidden');
                     sfxVolumeControlGroup.classList.add('hidden');
                     audioControlGroup.classList.remove("interactive-mode");
                     musicVolumeControlGroup.classList.remove("interactive-mode");
                     sfxVolumeControlGroup.classList.remove("interactive-mode");
                 }
            } else {
                 audioToggleSelector.disabled = true;
                 musicVolumeSlider.disabled = true;
                 sfxVolumeSlider.disabled = true;
                 audioControlGroup.classList.add('hidden');
                 musicVolumeControlGroup.classList.add('hidden');
                 sfxVolumeControlGroup.classList.add('hidden');
                 audioControlGroup.classList.remove("interactive-mode");
                 musicVolumeControlGroup.classList.remove("interactive-mode");
                 sfxVolumeControlGroup.classList.remove("interactive-mode");
            }

            resetDataButton.classList.add('hidden');
            resetDataButton.classList.remove('interactive-mode');

            updateScoreDisplay();
            updateTimeLengthDisplay();
            updateGameModeUI();
        }
        // --- Fin de Funciones de Refactorización ---

        function finalizeGameOver() {
            if (gameOver && startButton.disabled === false && configButton.disabled === false && backButton.disabled === false && gameIntervalId === null) return;

            gameOver = true;
            screenState.gameActuallyStarted = false; // Game is no longer "actually started"

            // Crucial for Free Mode: Ensure cover is not shown when game ends, so classification appears
            if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = false; // Ensure no cover is shown
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeEnd = false;
            } else if (gameMode === 'classification') {
                screenState.showClassificationCover = false;
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
            }


            clearGameTimersAndMusic();

            // Ensure any active speed boost or mirror effect ends when the game does
            if (speedBoost.active) {
                speedBoost = { active: false, color: '', change: 0, startTime: 0 };
            }
            controlsInverted = false;
            mirrorEffect = { active: false, startTime: 0 };

            let levelEffectivelyWon = false; 
            isNewHighScore = false; 

            if (gameMode === 'freeMode') {
                if (gameOverByInactivity) {
                    screenState.showTimeoutCover = true;
                } else {
                    screenState.showFreeModeEnd = true;
                }
                isNewHighScore = false;
                levelEffectivelyWon = false;
            } else if (gameMode === 'classification') {
                const classificationResult = handleClassificationModeEnd(score, Math.floor(gameTimeElapsed / 1000), difficulty);
                isNewHighScore = classificationResult.isNewRecord;
                levelEffectivelyWon = classificationResult.isEffectivelyWon;
                if (isNewHighScore) {
                    blinkAnimation.rowIndex = classificationResult.rowIndex;
                }
            } else if (gameMode === 'levels') {
                levelEffectivelyWon = handleLevelsModeEnd(score, gameTimeRemaining);
            } else if (gameMode === 'maze') {
                levelEffectivelyWon = handleMazeModeEnd(score, gameTimeRemaining);
            }

            if (!levelEffectivelyWon && gameOverByTimeout && (gameMode === 'levels' || gameMode === 'maze')) {
                screenState.showTimeoutCover = true;
                screenState.showDefeatCoverForWorld = 0;
                if (gameMode === 'maze') {
                    screenState.mazeResultType = '';
                }
            }
            gameOverByTimeout = false;
            gameOverByInactivity = false;

            playSoundForGameOver(levelEffectivelyWon);
            draw();
            managePostGameOverMusicAndAnimation();

            if (!levelEffectivelyWon) {
                loseLife();
            }

            let earnedCoins;
            if (gameMode === 'freeMode') {
                // In free mode coins are earned based on time played
                earnedCoins = Math.floor(gameTimeElapsed / 1000);
            } else {
                earnedCoins = Math.floor(score / POINTS_PER_COIN);
            }
            const previousCoins = totalCoins;

            const soundDelay = levelEffectivelyWon ? WIN_SOUND_DURATION : GAME_OVER_SOUND_DURATION;
            setTimeout(() => {
                showEarnedCoinsMessage(earnedCoins);
                setTimeout(() => {
                    totalCoins += earnedCoins;
                    animateCoinGain(previousCoins, totalCoins);
                    localStorage.setItem('snakeGameCoins', totalCoins.toString());
                    updateUIOnGameOver();
                    if (gameMode === 'levels' || gameMode === 'maze') {
                        saveGameSettings();
                    }
                }, COIN_MESSAGE_DISPLAY_TIME);
            }, soundDelay);
        }
        
        function drawSingleWorldCover(worldNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = worldCoverImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                if (worldNumber > maxUnlockedWorld) {
                    ctx.filter = 'grayscale(100%)';
                }
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
                ctx.filter = 'none';
            } else {
                ctx.fillStyle = "#24f2ed";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Mundo ${worldNumber}`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }
        
        function drawWorldCompleteScreen(worldNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = worldCompleteImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                 ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                // Fallback text if image fails to load
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 10)}px 'Press Start 2P'`;
                if (worldNumber === TOTAL_WORLDS) {
                    ctx.fillText("¡JUEGO COMPLETADO!", canvasEl.width / 2, canvasEl.height / 2);
                } else {
                    ctx.fillText(`¡MUNDO ${worldNumber} SUPERADO!`, canvasEl.width / 2, canvasEl.height / 2);
                }
                 if (!img.complete) {
                    console.warn(`Imagen de mundo completado para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de mundo completado para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawLevelCompleteImage(worldNumber) { 
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = levelCompleteImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`¡Nivel Superado!`, canvasEl.width / 2, canvasEl.height / 2 - 20);
                ctx.font = `${Math.floor(canvasEl.width / 25)}px 'Press Start 2P'`;
                ctx.fillText(`(Mundo ${worldNumber})`, canvasEl.width / 2, canvasEl.height / 2 + 20);

                if (!img.complete) {
                    console.warn(`Imagen de nivel completado para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de nivel completado para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawDefeatScreen(worldNumber) { // New function for defeat screen
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = defeatImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`¡Has Perdido!`, canvasEl.width / 2, canvasEl.height / 2 - 20);
                ctx.font = `${Math.floor(canvasEl.width / 25)}px 'Press Start 2P'`;
                ctx.fillText(`(Mundo ${worldNumber})`, canvasEl.width / 2, canvasEl.height / 2 + 20);

                if (!img.complete) {
                    console.warn(`Imagen de derrota para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de derrota para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawTimeoutScreen() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = (gameMode === 'freeMode') ? freeModeInactivityImg : timeoutImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText('¡Tiempo agotado!', canvasEl.width / 2, canvasEl.height / 2);
            }
        }
        function drawFreeModeCover() { // New function for free mode cover
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = freeModeCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Modo Libre`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de Modo Libre aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de Modo Libre parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawFreeModeEndScreen() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = freeModeEndImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText('Fin de partida', canvasEl.width / 2, canvasEl.height / 2);
            }
        }

        function drawClassificationCover() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const now = performance.now();
            let progress = 1;
            if (classificationTransitionStart !== null) {
                progress = Math.min((now - classificationTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromImg = classificationDifficultyImages[CLASSIFICATION_DIFFICULTY_ORDER[classificationTransitionStart !== null ? classificationTransitionFrom : classificationDifficultyIndex]];
            const toImg = classificationDifficultyImages[CLASSIFICATION_DIFFICULTY_ORDER[classificationDifficultyIndex]];

            if (classificationTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = classificationTransitionDir;
                if (fromImg && fromImg.complete && fromImg.naturalHeight !== 0) {
                    ctx.drawImage(fromImg, -dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, canvasEl.width * dir - dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                requestAnimationFrame(draw);
            } else {
                classificationTransitionStart = null;
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, 0, 0, canvasEl.width, canvasEl.height);
                } else {
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                    ctx.fillText(DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || 'Clasificación', canvasEl.width / 2, canvasEl.height / 2);
                    if (!toImg.complete) {
                        console.warn(`Imagen de portada de dificultad aún no cargada.`);
                    } else if (toImg.naturalHeight === 0) {
                        console.warn(`Imagen de portada de dificultad parece estar corrupta o no es una imagen válida.`);
                    }
                }
            }
        }

        function drawSingleMazeLevelCover(levelNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = mazeLevelCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                if (levelNumber > currentMazeLevel) {
                    ctx.filter = 'grayscale(100%)';
                }
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
                ctx.filter = 'none';
            } else {
                ctx.fillStyle = "#24f2ed";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Nivel ${levelNumber}`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de nivel aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de nivel parece estar corrupta o no es válida.`);
                }
            }

            const textColor = levelNumber > currentMazeLevel ? '#6B7280' : '#24f2ed';
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.font = `${Math.floor(canvasEl.width / 14)}px 'Press Start 2P'`;

            const totalStars = MAZE_STAR_TARGETS.length;
            const starSize = Math.floor(canvasEl.width / (totalStars * 2 + 1));
            const marginBottom = canvasEl.height * 0.05;
            const textY = canvasEl.height - starSize - marginBottom - canvasEl.height * 0.03;
            ctx.fillText(`Nivel ${levelNumber}`, canvasEl.width / 2, textY);

            const starsEarned = mazeLevelStars[levelNumber - 1] || 0;
            const gap = starSize * 0.5;
            const rowWidth = totalStars * starSize + (totalStars - 1) * gap;
            const startX = (canvasEl.width - rowWidth) / 2 + starSize / 2;
            const starY = canvasEl.height - starSize / 2 - marginBottom;
            for (let i = 0; i < totalStars; i++) {
                const filled = levelNumber <= currentMazeLevel && i < starsEarned;
                drawStarShape(startX + i * (starSize + gap), starY, starSize, filled);
            }
        }

        function drawStarShape(cx, cy, size, filled) {
            if (starFullImg.complete && starEmptyImg.complete && starFullImg.naturalHeight !== 0 && starEmptyImg.naturalHeight !== 0) {
                const img = filled ? starFullImg : starEmptyImg;
                ctx.drawImage(img, cx - size / 2, cy - size / 2, size, size);
            } else {
                const path = new Path2D('M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z');
                const scale = size / 24;
                const color = filled ? '#FACC15' : '#6B7280';
                ctx.save();
                ctx.translate(cx - size / 2, cy - size / 2);
                ctx.scale(scale, scale);
                ctx.fillStyle = color;
                ctx.fill(path);
                ctx.restore();
            }
        }

        function drawWorldCover() {
            if (!ctx || !canvasEl) return;
            const now = performance.now();
            let progress = 1;
            if (worldTransitionStart !== null) {
                progress = Math.min((now - worldTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromWorld = worldTransitionStart !== null ? worldTransitionFrom : displayWorld;
            const toWorld = displayWorld;

            if (worldTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = worldTransitionDir;
                ctx.save();
                ctx.translate(-dir * offset, 0);
                drawSingleWorldCover(fromWorld);
                ctx.restore();
                ctx.save();
                ctx.translate(canvasEl.width * dir - dir * offset, 0);
                drawSingleWorldCover(toWorld);
                ctx.restore();
                requestAnimationFrame(draw);
            } else {
                worldTransitionStart = null;
                drawSingleWorldCover(toWorld);
            }
        }

       function drawMazeCover() {
            if (!ctx || !canvasEl) return;
            const now = performance.now();
            let progress = 1;
            if (mazeTransitionStart !== null) {
                progress = Math.min((now - mazeTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromLevel = mazeTransitionStart !== null ? mazeTransitionFrom : displayMazeLevel;
            const toLevel = displayMazeLevel;

            if (mazeTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = mazeTransitionDir;
                ctx.save();
                ctx.translate(-dir * offset, 0);
                drawSingleMazeLevelCover(fromLevel);
                ctx.restore();
                ctx.save();
                ctx.translate(canvasEl.width * dir - dir * offset, 0);
                drawSingleMazeLevelCover(toLevel);
                ctx.restore();
                requestAnimationFrame(draw);
            } else {
                mazeTransitionStart = null;
                drawSingleMazeLevelCover(toLevel);
            }
        }

        function drawMazeResultScreen(resultType) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            let img;
            if (resultType === 'fail') img = mazeFailImg;
            else if (resultType === 'partial') img = mazePartialImg;
            else if (resultType === 'perfect') img = mazePerfectImg;
            else if (resultType === 'complete') img = mazeCompleteImg;
            else if (resultType === 'final') img = mazeFinalImg;
            else if (resultType === 'allstars') img = mazeAllStarsImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                const textMap = {
                    fail: 'Reintentar',
                    partial: 'Continuar',
                    perfect: 'Perfecto',
                    complete: '¡Completado!',
                    final: '¡Completado!',
                    allstars: '¡Completado!'
                };
                ctx.fillText(textMap[resultType] || '', canvasEl.width / 2, canvasEl.height / 2);
            }
        }

        function getModeImage(mode) {
            if (mode === 'intro') return modeSelectIntroImg;
            if (mode === 'levels') return modeSelectLevelsImg;
            if (mode === 'freeMode') return modeSelectFreeImg;
            if (mode === 'classification') return modeSelectClassificationImg;
            return modeSelectMazeImg;
        }

        function drawModeSelection() {
            modeLeftButton.classList.remove('hidden');
            modeRightButton.classList.remove('hidden');

            const now = performance.now();
            let progress = 1;
            if (modeTransitionStart !== null) {
                progress = Math.min((now - modeTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromImg = getModeImage(MODE_SELECT_ORDER[modeTransitionStart !== null ? modeTransitionFrom : modeSelectIndex]);
            const toImg = getModeImage(MODE_SELECT_ORDER[modeSelectIndex]);

            if (modeTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = modeTransitionDir;
                if (fromImg && fromImg.complete && fromImg.naturalHeight !== 0) {
                    ctx.drawImage(fromImg, -dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, canvasEl.width * dir - dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                requestAnimationFrame(draw);
            } else {
                modeTransitionStart = null;
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, 0, 0, canvasEl.width, canvasEl.height);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                    ctx.fillText('Selecciona modo', canvasEl.width / 2, canvasEl.height / 2);
                }
            }
        }


        function draw() {
             if (!ctx) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            if (showModeSelect) {
                drawModeSelection();
                updateMainButtonStates();
                return;
            } else {
                if ((screenState.showClassificationCover ||
                     (screenState.showCoverForWorld > 0 && gameMode === 'levels') ||
                     (screenState.showMazeCover && gameMode === 'maze')) &&
                    !screenState.gameActuallyStarted) {
                    modeLeftButton.classList.remove('hidden');
                    modeRightButton.classList.remove('hidden');
                } else {
                    modeLeftButton.classList.add('hidden');
                    modeRightButton.classList.add('hidden');
                }
            }

            let speedBoostVisible = false;
            let speedBoostOverlayColor = '';
            if (speedBoost.active) {
                const remaining = SPEED_BOOST_DURATION - (Date.now() - speedBoost.startTime);
                if (remaining > 0) {
                    speedBoostOverlayColor = speedBoost.color === 'yellow' ? 'rgba(255,255,0,0.3)' : 'rgba(255,0,0,0.3)';
                    speedBoostVisible = remaining > 1000 || Math.floor(remaining / 100) % 2 === 0;
                }
            }
            let mirrorVisible = false;
            let mirrorOverlayColor = 'rgba(0,0,255,0.3)';
            if (mirrorEffect.active) {
                let effectDuration = MIRROR_EFFECT_DURATION;
                if (gameMode === 'classification') {
                    const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                    if (typeof cfg.mirrorEffectDuration === 'number') {
                        effectDuration = cfg.mirrorEffectDuration;
                    }
                }
                const remaining = effectDuration - (Date.now() - mirrorEffect.startTime);
                if (remaining > 0) {
                    mirrorVisible = remaining > 1000 || Math.floor(remaining / 100) % 2 === 0;
                } else {
                    mirrorEffect.active = false;
                }
            }

            if (screenState.showFreeModeCover && !screenState.gameActuallyStarted) {
                drawFreeModeCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                drawClassificationCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.showMazeCover && !screenState.gameActuallyStarted) {
                modeLeftButton.classList.remove('hidden');
                modeRightButton.classList.remove('hidden');
                drawMazeCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.mazeResultType && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                drawMazeResultScreen(screenState.mazeResultType);
                updateMainButtonStates();
                return;
            }
            if (screenState.showTimeoutCover && !screenState.gameActuallyStarted) {
                drawTimeoutScreen();
                updateMainButtonStates();
                return;
            }
            if (screenState.showFreeModeEnd && !screenState.gameActuallyStarted) {
                drawFreeModeEndScreen();
                updateMainButtonStates();
                return;
            }
            if (screenState.showDefeatCoverForWorld > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                drawDefeatScreen(screenState.showDefeatCoverForWorld);
                updateMainButtonStates();
                return;
            }
            if (screenState.showWorldCompleteCover > 0 && gameMode === 'levels') { 
                drawWorldCompleteScreen(screenState.showWorldCompleteCover);
                updateMainButtonStates(); 
                return;
            }
            if (screenState.showLevelCompleteCover > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) { 
                drawLevelCompleteImage(screenState.showLevelCompleteCover); 
                updateMainButtonStates(); 
                return;
            }
            if (screenState.showCoverForWorld > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                modeLeftButton.classList.remove('hidden');
                modeRightButton.classList.remove('hidden');
                drawWorldCover();
                updateMainButtonStates();
                return;
            }


            if (tileCountX <= 0 || tileCountY <= 0) return; 

            const currentSkinData = SKINS[currentSkin]; 

            if (!gameOver) {
                if (obstacles.length > 0) {
                    obstacles.forEach(ob => drawObstacle(ob));
                }
                // Draw snake body
                for (let i = 1; i < snake.length; i++) {
                    const segmentX = snake[i].x * GRID_SIZE;
                    const segmentY = snake[i].y * GRID_SIZE;
                    const skinData = SKINS[currentSkin]; 

                    if (snakeBodyTexture && snakeBodyTexture.complete && snakeBodyTexture.naturalHeight !== 0) {
                        ctx.drawImage(snakeBodyTexture, segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                        if (skinData.bodyTintColor) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = skinData.bodyTintColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (speedBoostVisible) {
                            drawImageWithTint(ctx, snakeBodyTexture, segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1, speedBoostOverlayColor);
                        }
                        if (mirrorVisible) {
                            drawImageWithTint(ctx, snakeBodyTexture, segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1, mirrorOverlayColor);
                        }
                    } else {
                        ctx.fillStyle = skinData.bodyTintColor || '#A8F031';
                        ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                        if (speedBoostVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = speedBoostOverlayColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (mirrorVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = mirrorOverlayColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                    if (skinData.bodyStrokeColor) {
                        ctx.strokeStyle = skinData.bodyStrokeColor;
                        ctx.lineWidth = 1; 
                        ctx.strokeRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                    }
                }

                // Draw food
                if (currentFoodItem.x !== undefined) {
                    drawFoodItem(currentFoodItem.x, currentFoodItem.y);
                }
                if (falseFoodItems.length > 0) {
                    falseFoodItems.forEach(item => drawFalseFoodItem(item));
                }
                if (lightningItems.length > 0) {
                    lightningItems.forEach(item => drawLightningItem(item));
                }
                if (mirrorItems.length > 0) {
                    mirrorItems.forEach(item => drawMirrorItem(item));
                }

                // Draw snake head
                if (snake.length > 0) {
                    const head = snake[0];
                    if (currentSkinData && currentSkinData.snakeHeadAsset) {
                        let imgToDraw;
                        let baseImageForUp = currentSkinData.snakeHeadAsset.upDown;
                        let baseImageForDown = currentSkinData.snakeHeadAsset.upDown;
                        let baseImageForLeft = currentSkinData.snakeHeadAsset.left;
                        let baseImageForRight = currentSkinData.snakeHeadAsset.left; 
                        let flipHorizontal = false;
                        let flipVertical = false;

                        if (direction === 'up') { imgToDraw = baseImageForUp; flipVertical = true; }
                        else if (direction === 'down') { imgToDraw = baseImageForDown; }
                        else if (direction === 'left') { imgToDraw = baseImageForLeft; }
                        else if (direction === 'right') { imgToDraw = baseImageForRight; flipHorizontal = true; }

                        if (imgToDraw && imgToDraw.complete && imgToDraw.naturalHeight !== 0) {
                            const drawSize = GRID_SIZE * currentSkinData.snakeHeadScale;
                            const offset = (drawSize - GRID_SIZE) / 2;
                            const drawX = head.x * GRID_SIZE - offset;
                            const drawY = head.y * GRID_SIZE - offset;
                            ctx.save();
                            ctx.translate(drawX + drawSize / 2, drawY + drawSize / 2);
                            let scaleX = 1; let scaleY = 1;
                            if (flipHorizontal) scaleX = -1; if (flipVertical) scaleY = -1;
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                            if (speedBoostVisible) {
                                drawImageWithTint(ctx, imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize, speedBoostOverlayColor);
                            }
                            if (mirrorVisible) {
                                drawImageWithTint(ctx, imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize, mirrorOverlayColor);
                            }
                            ctx.restore();
                        } else {
                            ctx.fillStyle = "#a7f3d0";
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                            if (speedBoostVisible) {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = speedBoostOverlayColor;
                                ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                                ctx.globalCompositeOperation = 'source-over';
                            }
                            if (mirrorVisible) {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = mirrorOverlayColor;
                                ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                                ctx.globalCompositeOperation = 'source-over';
                            }
                        }
                    } else {
                        ctx.fillStyle = "#a7f3d0";
                        ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                        ctx.strokeStyle = "#065f46";
                        ctx.strokeRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                        if (speedBoostVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = speedBoostOverlayColor;
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (mirrorVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = mirrorOverlayColor;
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                    drawStreakAnimation(head);
                }
            } else { // Game Over Screen (but not world/level complete or defeat screen)
                if (!screenState.showWorldCompleteCover && !screenState.showLevelCompleteCover && !screenState.showDefeatCoverForWorld && !screenState.showFreeModeCover) { 
                    ctx.fillStyle = "rgba(0, 0, 0, 0.65)"; 
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                    
                    const baseFontSize = Math.min(16, Math.floor(canvasEl.width / 20)); 
                    const highScoreTitleFontSize = Math.max(9, baseFontSize * 0.9);
                    const highScoreEntryFontSize = Math.max(7, baseFontSize * 0.7);
                    const tableHeaderFontSize = Math.max(7, baseFontSize * 0.7);
                    
                    let endMessageFontSize = baseFontSize;
                    let mainTitle = "";
                    let subTitle = "";
                    let titleColor = "rgba(220, 38, 38, 1)"; 

                    if (gameMode === 'levels') {
                        mainTitle = `Nivel ${displayWorld}.${displayLevelInWorld} Fallido`; // Use display variables
                        subTitle = "Inténtalo de nuevo";
                    } else if (gameMode === 'freeMode' || gameMode === 'classification') {
                        mainTitle = isNewHighScore ? "¡Nuevo Récord!" : "Game Over";
                         if (isNewHighScore) titleColor = "rgba(76, 175, 80, 1)";
                    }


                    const targetWidthForEndMessage = canvasEl.width * 0.9;
                    let optimalSizeForEndMessage = Math.floor(canvasEl.height / 5); 
                    if (optimalSizeForEndMessage < 15) optimalSizeForEndMessage = 15;
                    ctx.font = `${optimalSizeForEndMessage}px 'Press Start 2P'`;
                    while(ctx.measureText(mainTitle).width > targetWidthForEndMessage && optimalSizeForEndMessage > 10) {
                        optimalSizeForEndMessage--;
                        ctx.font = `${optimalSizeForEndMessage}px 'Press Start 2P'`;
                    }
                    endMessageFontSize = optimalSizeForEndMessage;

                    let currentY = canvasEl.height * 0.08;

                    ctx.fillStyle = titleColor;
                    ctx.font = `${endMessageFontSize}px 'Press Start 2P'`;
                    ctx.textAlign = "center";
                    ctx.shadowColor = "rgba(0,0,0,0.8)";
                    ctx.shadowBlur = 10;

                    const mainTitleMetrics = ctx.measureText(mainTitle);
                    const mainTitleHeight = mainTitleMetrics.actualBoundingBoxAscent + mainTitleMetrics.actualBoundingBoxDescent;
                    const mainTitleBaseline = currentY + mainTitleMetrics.actualBoundingBoxAscent - mainTitleHeight / 2;

                    ctx.textBaseline = "alphabetic";
                    ctx.fillText(mainTitle, canvasEl.width / 2, mainTitleBaseline);

                    ctx.shadowBlur = 0;
                    currentY = mainTitleBaseline + mainTitleMetrics.actualBoundingBoxDescent + endMessageFontSize * 0.7;

                    if (subTitle) {
                        const subTitleFontSize = Math.max(10, Math.floor(endMessageFontSize * 0.7));
                        ctx.font = `${subTitleFontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = titleColor;

                        const subTitleMetrics = ctx.measureText(subTitle);
                        const subTitleHeight = subTitleMetrics.actualBoundingBoxAscent + subTitleMetrics.actualBoundingBoxDescent;
                        const subTitleBaseline = currentY + subTitleMetrics.actualBoundingBoxAscent - subTitleHeight / 2;

                        ctx.textBaseline = "alphabetic";
                        ctx.fillText(subTitle, canvasEl.width / 2, subTitleBaseline);

                        currentY = subTitleBaseline + subTitleMetrics.actualBoundingBoxDescent + subTitleFontSize * 0.7;
                    }

                    currentY += 10;

                    if (gameMode === 'freeMode' || gameMode === 'classification') {
                        const tableOuterTopPadding = 30; 
                        const tableBottomPadding = 10; 
                        const tableSidePadding = canvasEl.width * 0.05;
                        const tableRectX = tableSidePadding;
                        const tableRectWidth = canvasEl.width - (2 * tableSidePadding);
                        const tableCornerRadius = 10; 
                        const tableBorderWidth = 2;
                        const tableBorderColor = "#4B5563";
                        const internalLineWidth = tableBorderWidth; 

                        const classificationTitleText = `Clasificación`;
                        let classificationTitleY = currentY; 
                        
                        const titleRowBgColor = "#1F2937"; 
                        const headerRowBgColor = "#1F2937"; 
                        const titleRowPaddingY = 5;

                        const titleRowHeight = highScoreTitleFontSize + 2 * titleRowPaddingY;
                        const headerRowHeight = tableHeaderFontSize + 10; 
                        
                        const tableContentStartY = classificationTitleY - highScoreTitleFontSize * 0.5 - titleRowPaddingY; 
                        const tableBgEndY = canvasEl.height - tableBottomPadding;
                        const tableBgHeight = tableBgEndY - tableContentStartY;

                        const availableHeightForScores = tableBgHeight - titleRowHeight - headerRowHeight - (tableBorderWidth * 2);
                        let dynamicScoreRowHeight = highScoreEntryFontSize + 10; 
                        if (MAX_HIGH_SCORES > 0 && availableHeightForScores > 0) {
                            dynamicScoreRowHeight = Math.max(highScoreEntryFontSize + 4, availableHeightForScores / MAX_HIGH_SCORES);
                        }

                        if (tableBgHeight > 0) {
                            ctx.fillStyle = "#374151"; 
                            ctx.strokeStyle = tableBorderColor;
                            ctx.lineWidth = tableBorderWidth;
                            ctx.beginPath();
                            ctx.roundRect(tableRectX, tableContentStartY, tableRectWidth, tableBgHeight, tableCornerRadius);
                            ctx.fill();
                            ctx.stroke();
                        }
                        
                        const titleRowActualY = tableContentStartY;
                        ctx.fillStyle = titleRowBgColor;
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(tableRectX + tableBorderWidth / 2, titleRowActualY + tableBorderWidth / 2, tableRectWidth - tableBorderWidth, titleRowHeight);
                        ctx.clip(); 
                        ctx.beginPath();
                        ctx.roundRect(tableRectX, titleRowActualY, tableRectWidth, titleRowHeight + tableCornerRadius, [tableCornerRadius, tableCornerRadius, 0, 0]); 
                        ctx.fill();
                        ctx.restore();
                        
                        ctx.font = `${highScoreTitleFontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = "#8f66af";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(classificationTitleText, canvasEl.width / 2, titleRowActualY + titleRowHeight / 2);

                        let currentDrawingYForTable = titleRowActualY + titleRowHeight;
                        
                        const headerRowActualY = currentDrawingYForTable;
                        ctx.fillStyle = headerRowBgColor;
                        ctx.fillRect(tableRectX + tableBorderWidth/2, headerRowActualY, tableRectWidth - tableBorderWidth, headerRowHeight);

                        const headerTextY = headerRowActualY + headerRowHeight / 2;
                        // AJUSTE DE POSICIONES X PARA LA TABLA DE PUNTUACIONES
                        const rankX = tableRectX + tableRectWidth * 0.08;    // Para "Nº"
                        const scoreX = tableRectX + tableRectWidth * 0.27;   // Para "PUNTOS"
                        const lengthX = tableRectX + tableRectWidth * 0.50;  // Para valor secundario
                        const skinX = tableRectX + tableRectWidth * 0.79;   // Para "JUGADOR" (más espacio)

                        const headerFont = `${tableHeaderFontSize}px 'Press Start 2P'`;
                        const headerColor = "#F5F5F5";
                        ctx.font = headerFont;
                        ctx.fillStyle = headerColor;
                        ctx.textAlign = "center"; // Asegurar alineación central
                        ctx.textBaseline = "middle"; // Asegurar alineación vertical

                        ctx.fillText("Nº", rankX, headerTextY);
                        ctx.fillText("PUNTOS", scoreX, headerTextY);
                        const secondaryHeader = (gameMode === 'classification' || gameMode === 'freeMode') ? 'TIEMPO' : 'LONG.';
                        ctx.fillText(secondaryHeader, lengthX, headerTextY);
                        ctx.fillText("JUGADOR", skinX, headerTextY); // Usar el texto "JUGADOR"
                        currentDrawingYForTable = headerRowActualY + headerRowHeight;

                        const highScores = gameMode === 'freeMode' ? loadHighScores(difficulty) : loadClassificationHighScores(difficulty);
                        const entryFont = `${highScoreEntryFontSize}px 'Press Start 2P'`;
                        const defaultEntryColor = "#F5F5F5";
                        const highlightEntryColor = "#8f66af"; 
                        const blinkOffColor = "#5A6578"; 
                        
                        let newHighScoreEntryProcessedForVisuals = false; 

                        for (let i = 0; i < MAX_HIGH_SCORES; i++) { 
                            const scoreRowActualY = currentDrawingYForTable;
                            if (scoreRowActualY + dynamicScoreRowHeight > tableBgEndY - tableBorderWidth/2) break; 

                            const rowTextY = scoreRowActualY + dynamicScoreRowHeight / 2; 
                            
                            if (i > 0 || headerRowActualY + headerRowHeight < scoreRowActualY) {
                                ctx.strokeStyle = tableBorderColor; 
                                ctx.lineWidth = internalLineWidth; 
                                ctx.beginPath();
                                ctx.moveTo(tableRectX + tableBorderWidth / 2, scoreRowActualY); 
                                ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, scoreRowActualY);
                                ctx.stroke();
                            }
                            
                            if (highScores[i]) {
                                const entry = highScores[i];
                                let currentEntryColor = defaultEntryColor;
                                
                                let isThisTheNewRecordFromThisGame = isNewHighScore &&
                                                                entry.score === score &&
                                                                ((gameMode === 'classification' || gameMode === 'freeMode')
                                                                     ? entry.time === Math.floor(gameTimeElapsed / 1000)
                                                                     : entry.length === snake.length) &&
                                                                i === blinkAnimation.rowIndex &&
                                                                !newHighScoreEntryProcessedForVisuals;


                                if (blinkAnimation.active && isThisTheNewRecordFromThisGame) {
                                    const visible = Math.floor((Date.now() - blinkAnimation.startTime) / blinkAnimation.interval) % 2 === 0;
                                    currentEntryColor = visible ? highlightEntryColor : blinkOffColor;
                                } else if (isThisTheNewRecordFromThisGame && !blinkAnimation.active) { 
                                    currentEntryColor = highlightEntryColor;
                                } else if (isNewHighScore && i === blinkAnimation.rowIndex && !blinkAnimation.active) { 
                                    currentEntryColor = highlightEntryColor;
                                }
                                
                                ctx.fillStyle = currentEntryColor;
                                ctx.font = entryFont;
                                // textAlign y textBaseline ya están en "center" y "middle"
                                ctx.fillText(`${i + 1}.`, rankX, rowTextY);
                                ctx.fillText(`${entry.score}`, scoreX, rowTextY);
                                const secondaryValue = (gameMode === 'classification' || gameMode === 'freeMode') ? formatTime(entry.time) : entry.length;
                                ctx.fillText(`${secondaryValue}`, lengthX, rowTextY);
                                // Mostrar el nombre del jugador si está disponible, si no el nombre del skin
                                const playerDisplay = entry.playerName || SKIN_DISPLAY_NAMES[entry.skin] || entry.skin || '-';
                                ctx.fillText(playerDisplay, skinX, rowTextY);
                            } else {
                                ctx.fillStyle = defaultEntryColor;
                                ctx.font = entryFont;
                                ctx.fillText(`${i + 1}.`, rankX, rowTextY);
                                ctx.fillText("---", scoreX, rowTextY);
                                ctx.fillText("---", lengthX, rowTextY);
                                ctx.fillText("---", skinX, rowTextY); // Placeholder para skin
                            }
                            currentDrawingYForTable += dynamicScoreRowHeight; 
                        }
                        ctx.strokeStyle = tableBorderColor;
                        ctx.lineWidth = internalLineWidth; 
                        ctx.beginPath();
                        ctx.moveTo(tableRectX + tableBorderWidth / 2, titleRowActualY + titleRowHeight);
                        ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, titleRowActualY + titleRowHeight);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(tableRectX + tableBorderWidth / 2, headerRowActualY + headerRowHeight);
                        ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, headerRowActualY + headerRowHeight);
                        ctx.stroke();
                    }
                    ctx.textBaseline = "alphabetic"; 
                }
            }
        }
        
       function update() {
            if (gameOver || tileCountX <= 0 || tileCountY <= 0) return;
            updateSpeedBoost();
            updateMirrorEffect();

            direction = nextDirection; // Actualizar la dirección actual con la siguiente dirección almacenada

            let nextHeadX = snake[0].x;
            let nextHeadY = snake[0].y;
            switch (direction) {
                case "up":    nextHeadY--; break;
                case "down":  nextHeadY++; break;
                case "left":  nextHeadX--; break;
                case "right": nextHeadX++; break;
            }

            if (nextHeadX < 0) nextHeadX = tileCountX - 1;
            else if (nextHeadX >= tileCountX) nextHeadX = 0;
            if (nextHeadY < 0) nextHeadY = tileCountY - 1;
            else if (nextHeadY >= tileCountY) nextHeadY = 0;

            if (!gameOver) {
                for (let i = 1; i < snake.length; i++) {
                    if (nextHeadX === snake[i].x && nextHeadY === snake[i].y) {
                        gameOver = true;
                        break;
                    }
                }
            }
            
            const nextHead = { x: nextHeadX, y: nextHeadY };
            let growth = 0; 
            if (currentFoodItem.x !== undefined && nextHead.x === currentFoodItem.x && nextHead.y === currentFoodItem.y) {
                let gained = POINTS_PER_FOOD;
                const rank = CLASSIFICATION_RANKS[difficulty] || 0;
                if ((gameMode === 'levels' && currentWorld >= 6) || (gameMode === 'classification' && rank >= 2)) {
                    gained *= streakMultiplier;
                    if (streakMultiplier < MAX_STREAK) { streakMultiplier += 0.5; }
                    if (streakMultiplier > MAX_STREAK) { streakMultiplier = MAX_STREAK; }
                    startStreakAnimation(streakMultiplier);
                }
                if (currentFoodItem.isGolden) gained *= 2;
                score += gained;
                if(areSfxEnabled) playSound('eat');

                growth = 1;
                clearTimeout(foodDisappearTimeoutId);
                clearInterval(foodVisualTimerIntervalId);
                foodTimeRemaining = 0;
                generateFood();

                if (gameMode === 'levels') {
                    const absoluteLevelIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
                    if (score >= TARGET_SCORES_LEVELS[absoluteLevelIndex]) {
                        gameOver = true; // Level won by score
                    }
                } else if (gameMode === 'maze') {
                    while (mazeStarsEarned < MAZE_STAR_TARGETS.length && score >= MAZE_STAR_TARGETS[mazeStarsEarned]) {
                        mazeStarsEarned++;
                        if (mazeStarsEarned === MAZE_STAR_TARGETS.length) {
                            gameOver = true;
                            break;
                        } else {
                            displayTargetScore = MAZE_STAR_TARGETS[mazeStarsEarned];
                        }
                    }
                    drawStarProgress();
                    updateTargetScoreDisplay();
                }
            }

            if (gameOver) {
                finalizeGameOver();
                return;
            }
            for (let i = falseFoodItems.length - 1; i >= 0; i--) {
                const ff = falseFoodItems[i];
                if (nextHead.x === ff.x && nextHead.y === ff.y) {
                    score = Math.max(0, score - 30);
                    streakMultiplier = 1;
                    const rank = CLASSIFICATION_RANKS[difficulty] || 0;
                    if ((gameMode === 'levels' && currentWorld >= 6) || (gameMode === 'classification' && rank >= 2)) startStreakAnimation(streakMultiplier);
                    removeFalseFoodItem(ff);
                    if (areSfxEnabled) playSound('badEat');
                }
            }
            for (let i = lightningItems.length - 1; i >= 0; i--) {
                const lt = lightningItems[i];
                if (nextHead.x === lt.x && nextHead.y === lt.y) {
                    activateSpeedBoost(lt.color);
                    removeLightningItem(lt);
                    if (areSfxEnabled) playSound('eat');
                }
            }
            for (let i = mirrorItems.length - 1; i >= 0; i--) {
                const mi = mirrorItems[i];
                if (nextHead.x === mi.x && nextHead.y === mi.y) {
                    controlsInverted = true;
                    mirrorEffect = { active: true, startTime: Date.now() };
                    removeMirrorItem(mi);
                    if (areSfxEnabled) playSound('eat');
                }
            }
            for (const ob of obstacles) {
                if (nextHead.x === ob.x && nextHead.y === ob.y) {
                    gameOver = true;
                    break;
                }
            }
            if (gameOver) {
                finalizeGameOver();
                return;
            }

            snake.unshift(nextHead);
            if (growth === 0) { snake.pop(); }

            updateScoreDisplay(); 
            if (gameMode === 'freeMode' || gameMode === 'levels') { 
                updateTimeLengthDisplay(); 
            }
            draw();
        }
        
        function updateScoreDisplay() {
            scoreValueDisplay.textContent = score;
        }

        function updateCoinDisplay() {
            coinValueDisplay.textContent = totalCoins;
        }

        function animateCoinGain(oldTotal, newTotal) {
            const diff = newTotal - oldTotal;
            if (diff <= 0) {
                coinValueDisplay.textContent = newTotal;
                return;
            }
            const duration = Math.min(2000, diff * 60);
            const start = performance.now();
            if (areSfxEnabled) playSound('coinAdd', duration / 1000);
            function step(now) {
                const progress = Math.min(1, (now - start) / duration);
                const value = Math.floor(oldTotal + diff * progress);
                coinValueDisplay.textContent = value;
                if (progress < 1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function showEarnedCoinsMessage(amount) {
            if (!earnedCoinsMessage) return;
            earnedCoinsMessage.textContent = `+${amount}`;
            earnedCoinsMessage.classList.remove('hidden', 'hide');
            void earnedCoinsMessage.offsetWidth;
            earnedCoinsMessage.classList.add('show');
            setTimeout(() => {
                earnedCoinsMessage.classList.remove('show');
                earnedCoinsMessage.classList.add('hide');
                setTimeout(() => {
                    earnedCoinsMessage.classList.add('hidden');
                    earnedCoinsMessage.classList.remove('hide');
                }, 300);
            }, COIN_MESSAGE_DISPLAY_TIME);
        }

        function saveLives() {
            localStorage.setItem('snakeGameLives', playerLives.toString());
            localStorage.setItem('snakeGameLifeQueue', JSON.stringify(lifeRestoreQueue));
        }

        function loadLives() {
            const storedLives = parseInt(localStorage.getItem('snakeGameLives'), 10);
            playerLives = Number.isFinite(storedLives) ? Math.min(MAX_LIVES, storedLives) : MAX_LIVES;
            try {
                const queue = JSON.parse(localStorage.getItem('snakeGameLifeQueue') || '[]');
                if (Array.isArray(queue)) lifeRestoreQueue = queue.map(n => parseInt(n, 10)).filter(n => Number.isFinite(n));
            } catch (e) {
                lifeRestoreQueue = [];
            }
            checkLifeRecovery(true);
        }

        function updateLivesDisplay() {
            if (livesValueDisplay) livesValueDisplay.textContent = playerLives;
        }

        function updateLifeTimerDisplay() {
            if (!lifeTimerValueDisplay) return;
            if (playerLives >= MAX_LIVES || lifeRestoreQueue.length === 0) {
                lifeTimerValueDisplay.textContent = 'Lleno';
            } else {
                const remaining = Math.max(0, Math.ceil((lifeRestoreQueue[0] - Date.now()) / 1000));
                lifeTimerValueDisplay.textContent = formatTime(remaining);
            }
        }

        function checkLifeRecovery(initial = false) {
            const now = Date.now();
            while (lifeRestoreQueue.length > 0 && lifeRestoreQueue[0] <= now && playerLives < MAX_LIVES) {
                lifeRestoreQueue.shift();
                playerLives++;
            }
            if (playerLives > MAX_LIVES) playerLives = MAX_LIVES;
            if (initial) saveLives();
            updateLivesDisplay();
            updateLifeTimerDisplay();
        }

        function loseLife() {
            if (playerLives <= 0) return;
            playerLives--;
            const lastTime = lifeRestoreQueue.length > 0 ? lifeRestoreQueue[lifeRestoreQueue.length - 1] : Date.now();
            lifeRestoreQueue.push(lastTime + LIFE_RECHARGE_TIME);
            saveLives();
            updateLivesDisplay();
        }

        function updateTargetScoreDisplay() {
            if (targetScoreValueDisplay && targetScoreDivider) {
                 if (gameMode === 'levels' || gameMode === 'maze') { 
                    // Use displayTargetScore which is updated at the start of a game or when settings change
                    targetScoreValueDisplay.textContent = displayTargetScore;
                    targetScoreValueDisplay.classList.remove('hidden');
                    targetScoreDivider.classList.remove('hidden');
                } else { 
                    targetScoreValueDisplay.classList.add('hidden');
                    targetScoreDivider.classList.add('hidden');
                }
            }
        }
        
        function updateTimeLengthDisplay() {
            if (!gameMode) {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            } else if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = Math.max(0, Math.ceil(gameTimeRemaining / 1000));
            } else if (gameMode === 'classification' || gameMode === 'freeMode') {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
            } else { // other modes (currently none)
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            }
        }

        function displayHighScoreInPanel() {
            const selectedDifficulty = (gameMode === 'freeMode') ? freeDifficulty : difficultySelector.value;
            const highScores = loadHighScores(selectedDifficulty);
            const hsSkinValueDisplay = document.getElementById("hs-skin-value");

            if (highScores.length > 0) {
                hsScoreValue.textContent = highScores[0].score;
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = SKIN_DISPLAY_NAMES[highScores[0].skin] || highScores[0].skin || '-';
                }
            } else {
                hsScoreValue.textContent = "-";
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = "-";
                }
            }
        }
        
        function updateGameModeUI() {

            topInfoBar.classList.toggle('selector-mode', showModeSelect);

            if (showModeSelect) {
                if (livesValueDisplay) livesValueDisplay.classList.remove("hidden");
                if (lifeTimerValueDisplay) lifeTimerValueDisplay.classList.remove('hidden');
                if (scoreValueDisplay) scoreValueDisplay.classList.add('hidden');
                if (targetScoreDivider) targetScoreDivider.classList.add('hidden');
                if (targetScoreValueDisplay) targetScoreValueDisplay.classList.add('hidden');
            } else {
                if (livesValueDisplay) livesValueDisplay.classList.add("hidden");
                if (lifeTimerValueDisplay) lifeTimerValueDisplay.classList.add('hidden');
                if (scoreValueDisplay) scoreValueDisplay.classList.remove('hidden');
                if (targetScoreDivider && targetScoreValueDisplay) updateTargetScoreDisplay();
            }

            const isGameCurrentlyRunning = !!gameIntervalId;
            const isSettingsPanelCurrentlyOpen = !settingsPanel.classList.contains("settings-panel-hidden");
            progressPanel.classList.remove('classification-mode');
            if (classificationRankingGroup) classificationRankingGroup.classList.add('hidden');

            // Set default settings header appearance
            if (settingsTitleImg) {
                settingsTitleImg.src = 'https://i.imgur.com/IAfhEaH.png';
                settingsTitleImg.alt = 'Configuración';
            }
            if (mazeInfoButton) mazeInfoButton.classList.add('hidden');
            if (classificationInfoButton) classificationInfoButton.classList.add('hidden');

            if (!gameMode) {
                titlePanel.classList.remove('hidden');
                progressPanel.classList.add('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = "No disponible";

                difficultyLabel.textContent = "Nivel:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                difficultyInfoButton.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                mazeInfoButton.classList.add('hidden');

                if (isSettingsPanelCurrentlyOpen) {
                    difficultySelector.disabled = true;
                    worldsSelector.disabled = true;
                    mazeLevelButtonsContainer.classList.add('disabled');
                    difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'levels') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Mundo:";
                progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                
                difficultyLabel.textContent = "Mundo Actual:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.remove('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                difficultyControlGroup.classList.add('hidden');
                if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
                skinControlGroup.classList.add('hidden');
                foodControlGroup.classList.add('hidden');
                difficultyInfoButton.classList.add('hidden');
                worldInfoButton.classList.remove('hidden');
                mazeInfoButton.classList.add('hidden');
                populateWorldButtons();
                drawStarProgress();

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    worldButtonsContainer.classList.remove('disabled');
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    worldButtonsContainer.classList.add('disabled');
                     if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                     else difficultyControlGroup.classList.remove("interactive-mode");
                }
                if (settingsTitleImg) {
                    settingsTitleImg.src = 'https://i.imgur.com/tLBeddL.png';
                    settingsTitleImg.alt = 'Modo Aventura';
                }
            } else if (gameMode === 'freeMode') {
                // En el modo libre mantendremos visible el título del juego y ocultaremos
                // el panel de progreso con la dificultad y la máxima puntuación.
                titlePanel.classList.remove('hidden');
                progressPanel.classList.add('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.add('hidden');

                // Actualizamos la dificultad aunque no se muestre actualmente
                progressPanelLeftLabel.textContent = "Dificultad:";
                progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[freeDifficulty] || freeDifficulty;

                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.remove('hidden');
                mazeInfoButton.classList.add('hidden');

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'classification') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.remove('hidden');
                progressPanel.classList.add('classification-mode');

                progressPanelLeftLabel.textContent = "Dificultad:";
                progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;

                displayClassificationHighScoreInPanel();
                if (classificationRankingGroup) {
                    classificationRankingGroup.classList.remove('hidden');
                    populateClassificationRanking();
                }

                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.remove('hidden');
                mazeInfoButton.classList.add('hidden');
                if (classificationInfoButton) classificationInfoButton.classList.remove('hidden');
                if (settingsTitleImg) {
                    settingsTitleImg.src = specificHelpTexts.difficulty.image;
                    settingsTitleImg.alt = specificHelpTexts.difficulty.title;
                }

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
                skinControlGroup.classList.add('hidden');
                foodControlGroup.classList.add('hidden');
                audioControlGroup.classList.add('hidden');
                musicVolumeControlGroup.classList.add('hidden');
                sfxVolumeControlGroup.classList.add('hidden');
                resetDataButton.classList.add('hidden');
            } else if (gameMode === 'maze') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = displayMazeLevel;
                drawStarProgress();

                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                difficultyControlGroup.classList.add('hidden');
                if (playerNameControlGroup) playerNameControlGroup.classList.add('hidden');
                skinControlGroup.classList.add('hidden');
                foodControlGroup.classList.add('hidden');
                mazeLevelButtonsContainer.classList.remove('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.add('hidden');
                mazeInfoButton.classList.remove('hidden');
                populateMazeLevelButtons();

                if (settingsTitleImg) {
                    settingsTitleImg.src = 'https://i.imgur.com/XLdIK3D.png';
                    settingsTitleImg.alt = 'Modo Laberinto';
                }

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    mazeLevelButtonsContainer.classList.remove('disabled');
                } else {
                    mazeLevelButtonsContainer.classList.add('disabled');
                }
            } else {
                titlePanel.classList.add('hidden');
                progressPanel.classList.add('hidden');
                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                worldButtonsContainer.classList.add('hidden');
                mazeLevelButtonsContainer.classList.add('hidden');
                worldInfoButton.classList.add('hidden');
                difficultyInfoButton.classList.remove('hidden');
                mazeInfoButton.classList.add('hidden');
                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            }

            updateTargetScoreDisplay();

            if (!gameMode) {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            } else if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                     timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
                } else if (!gameOver) {
                     timeLengthValueEl.textContent = Math.max(0, Math.ceil(gameTimeRemaining / 1000));
                } else {
                     timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
                }
            } else if (gameMode === 'classification') {
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                    timeLengthValueEl.textContent = formatTime(0);
                } else {
                    timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
                }
            } else { // freeMode
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                    timeLengthValueEl.textContent = formatTime(0);
                } else {
                    timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
                }
            }
        }

function populateWorldsSelector() {
            worldsSelector.innerHTML = '';
            for (let i = 1; i <= TOTAL_WORLDS; i++) {
                const option = document.createElement('option');
                option.value = i;
                const name = WORLD_DISPLAY_NAMES[i - 1] || '';
                option.textContent = name ? `${i}.${name}` : `${i}`;
                option.disabled = i > maxUnlockedWorld;
                if (i === currentWorld) {
                    option.selected = true;
                }
                worldsSelector.appendChild(option);
            }
        }

function populateWorldButtons() {
            worldButtonsContainer.innerHTML = '';
            for (let i = 1; i <= TOTAL_WORLDS; i++) {
                const button = document.createElement('div');
                button.className = 'world-button';
                const worldImg = worldImagesConfig[i]?.cover || '';
                button.style.backgroundImage = `url('https://i.imgur.com/8Gp9hfW.png'), url('${worldImg}')`;
                button.style.backgroundSize = 'contain, 67%';
                button.style.backgroundRepeat = 'no-repeat';
                button.style.backgroundPosition = 'center, center 45%';

                const starsContainer = document.createElement('div');
                starsContainer.className = 'maze-stars';

                const completedLevels = levelsProgress.slice((i - 1) * LEVELS_PER_WORLD, i * LEVELS_PER_WORLD).filter(Boolean).length;
                for (let j = 0; j < LEVELS_PER_WORLD; j++) {
                    const star = document.createElement('div');
                    star.className = 'star ' + (j < completedLevels ? 'full' : 'empty');
                    starsContainer.appendChild(star);
                }

                button.appendChild(starsContainer);

                if (i > maxUnlockedWorld) {
                    button.classList.add('disabled');
                }

                button.addEventListener('click', () => {
                    if (i > maxUnlockedWorld) return;

                    currentWorld = i;
                    currentLevelInWorld = worldCurrentLevels[i - 1] || 1;
                    displayWorld = currentWorld;
                    displayLevelInWorld = currentLevelInWorld;
                    const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex] || 0;
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                    }
                    drawStarProgress();

                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;

                    saveGameSettings();

                    closeSettingsPanel();

                    requestAnimationFrame(draw);
                });

                addIconPressEvents(button, button);

                worldButtonsContainer.appendChild(button);
            }
        }

function populateMazeLevelButtons() {
            mazeLevelButtonsContainer.innerHTML = '';
            for (let i = 1; i <= MAZE_LEVEL_COUNT; i++) {
                const button = document.createElement('div');
                button.className = 'maze-level-button';

                const num = document.createElement('div');
                num.className = 'maze-level-number';
                num.textContent = i;

                const starsContainer = document.createElement('div');
                starsContainer.className = 'maze-stars';

                const starsEarned = mazeLevelStars[i - 1] || 0;
                for (let j = 0; j < MAZE_STAR_TARGETS.length; j++) {
                    const star = document.createElement('div');
                    star.className = 'star ' + (j < starsEarned ? 'full' : 'empty');
                    starsContainer.appendChild(star);
                }

                button.appendChild(num);
                button.appendChild(starsContainer);

                if (i > currentMazeLevel) {
                    button.classList.add('disabled');
                }

                button.addEventListener('click', () => {
                    if (i > currentMazeLevel) return;

                    displayMazeLevel = i;
                    mazePreviousStars = mazeLevelStars[i - 1] || 0;
                    mazeStarsEarned = mazePreviousStars;
                    if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                        displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                    } else {
                        displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                    }
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = displayMazeLevel;
                    }
                    drawStarProgress();

                    screenState.showMazeCover = true;
                    screenState.gameActuallyStarted = false;
                    screenState.mazeResultType = '';
                    restartMazeButton.classList.add('hidden');
                    startButtonWrapperEl.classList.remove('split');

                    saveGameSettings();

                    closeSettingsPanel();

                    requestAnimationFrame(draw);
                });

                // Press feedback similar to start button
                addIconPressEvents(button, button);

                mazeLevelButtonsContainer.appendChild(button);
            }
        }

        function drawStarProgress() {
            starProgressContainer.innerHTML = '';
            if (gameMode === 'levels') {
                const worldToDisplayStarsFor = (screenState.showCoverForWorld > 0 && !screenState.gameActuallyStarted)
                    ? displayWorld
                    : (gameOver ? displayWorld : currentWorld);
                const worldLevelStartIndex = (worldToDisplayStarsFor - 1) * LEVELS_PER_WORLD;
                for (let i = 0; i < LEVELS_PER_WORLD; i++) {
                    const levelIndexInTotal = worldLevelStartIndex + i;
                    const isCompleted = levelsProgress[levelIndexInTotal];
                    const star = document.createElement('div');
                    star.className = 'progress-star ' + (isCompleted ? 'full' : 'empty');
                    starProgressContainer.appendChild(star);
                }
            } else if (gameMode === 'maze') {
                for (let i = 0; i < MAZE_STAR_TARGETS.length; i++) {
                    const isEarned = i < mazeStarsEarned;
                    const star = document.createElement('div');
                    star.className = 'progress-star ' + (isEarned ? 'full' : 'empty');
                    starProgressContainer.appendChild(star);
                }
            }
        }
        
        async function ensureAudioContextRunning() {
            if (typeof Tone === 'undefined') return false;
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start(); 
                    console.log("Tone.js context (re)started/resumed by ensureAudioContextRunning.");
                    if (Tone.context.state === 'running' && !synthsInitialized) { 
                        initializeToneSynths();
                    }
                    return Tone.context.state === 'running';
                } catch (e) {
                    console.error("Error trying to start/resume Tone.js context in ensureAudioContextRunning:", e);
                    return false;
                }
            } else if (!synthsInitialized) { 
                 initializeToneSynths();
            }
            return true; 
        }
        
        function initializeToneSynths() {
            if (typeof Tone === 'undefined' || Tone.context.state !== 'running') {
                console.warn("Tone.js context not running. Synth initialization deferred or skipped.");
                synthsInitialized = false; 
                return;
            }
            if (synthsInitialized) return; 

            console.log("Initializing Tone.js Synths...");
            sfxGain = new Tone.Gain(1).toDestination();
            synthEat = new Tone.MonoSynth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.04, sustain: 0.01, release: 0.08 }, filterEnvelope: { attack: 0.002, decay: 0.01, sustain: 0, release: 0.02, baseFrequency: 1500, octaves: 1.5, exponent: 2 } }).connect(sfxGain);
            synthEat.volume.value = 0;
            synthEatNoise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 } }).connect(sfxGain);
            synthEatNoise.volume.value = -10;
            synthBadEat = new Tone.MonoSynth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.15 }, filterEnvelope: { attack: 0.002, decay: 0.02, sustain: 0, release: 0.05, baseFrequency: 500, octaves: 1.2, exponent: 2 } }).connect(sfxGain);
            synthBadEat.volume.value = 0;
            synthWarning = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).connect(sfxGain);
            synthWarning.volume.value = 0;
            synthTimeout = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).connect(sfxGain);
            synthTimeout.volume.value = 0;
            synthGameOver = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.3 } }).connect(sfxGain);
            synthGameOver.volume.value = 0;
            synthStartGame = new Tone.Synth({ oscillator: {type: 'triangle'}, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 } }).connect(sfxGain);
            synthStartGame.volume.value = 0;
            synthWin = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 } }).connect(sfxGain);
            synthWin.volume.value = -4; // lower victory sound volume
            synthCoinNoise = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 } }).connect(sfxGain);
            synthCoinNoise.volume.value = -8;
            synthCoinChime = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).connect(sfxGain);
            synthCoinChime.volume.value = -2;
            synthModeSwitch = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 } }).connect(sfxGain);
            synthModeSwitch.volume.value = -2;
            synthModeSelect = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.05 } }).connect(sfxGain);
            synthModeSelect.volume.value = -2;
            // synthSplashStart is initialized in window.onload
            if (synthSplashStart) {
                try {
                    synthSplashStart.disconnect();
                    synthSplashStart.connect(sfxGain);
                } catch (e) {
                    console.warn('Could not route splash start sound through sfxGain:', e);
                }
            }

            updateSfxVolume();

            synthsInitialized = true;
            console.log("Tone.js Synths initialized.");
        }


async function startGame(isRestart = false) {
    isNewHighScore = false;
    blinkAnimation.active = false;
    blinkAnimation.rowIndex = -1;
    streakAnimation.active = false;
    gameOverByTimeout = false;
    gameOverByInactivity = false;

    // Reset any lingering speed boost or mirror effect from a previous game
    speedBoost = { active: false, color: '', change: 0, startTime: 0 };
    controlsInverted = false;

    mirrorEffect = { active: false, startTime: 0 };

    if (gameMode === 'maze') {
        if (isRestart && (screenState.mazeResultType === 'partial' || screenState.mazeResultType === 'perfect')) {
            displayMazeLevel = Math.max(1, currentMazeLevel - 1);
        } else if (screenState.mazeResultType === 'partial' || screenState.mazeResultType === 'perfect') {
            if (displayMazeLevel < currentMazeLevel) {
                displayMazeLevel = getNextIncompleteMazeLevel(displayMazeLevel);
            } else {
                displayMazeLevel = currentMazeLevel;
            }
        }
    }
            
            const wasOnWorldCompleteCoverForNewWorld = screenState.showWorldCompleteCover > 0 && startButton.textContent === "Nuevo Mundo";
        
            // Reset all visual state flags that are managed before game loop starts
            screenState.showCoverForWorld = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showWorldCompleteCover = 0;
            screenState.showFreeModeCover = false;
            screenState.showFreeModeEnd = false;
            screenState.showMazeCover = false;
            screenState.mazeResultType = '';
            restartMazeButton.classList.add('hidden');
            startButtonWrapperEl.classList.remove('split');
        
            if (startButton.textContent === "Ajustes") {
                openSettingsPanel();
                screenState.gameActuallyStarted = false; 
            } else {
                closeSettingsPanel(); 
                closeInfoPanel(); 
        
                if (gameMode === 'levels' && wasOnWorldCompleteCoverForNewWorld) {
                    // currentWorld and currentLevelInWorld are already set for the new world
                    screenState.showCoverForWorld = currentWorld; 
                    screenState.gameActuallyStarted = false; 

                    // Update display variables for the new world's cover screen
                    displayWorld = currentWorld;
                    displayLevelInWorld = currentLevelInWorld;
                    const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                    if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                        displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                    } else {
                        displayTargetScore = 0; // Should not happen if TOTAL_WORLDS is correct
                    }
                    score = 0; // Reset score when transitioning to new world cover
                    streakMultiplier = 1; // Reset streak
                    updateScoreDisplay(); // Update UI to show 0 score & x1 streak

                    // Update UI elements that depend on display variables
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                    }
                    drawStarProgress(); // Update stars for the new world being displayed

                } else {
                    screenState.gameActuallyStarted = true;
                }
            }
            
            if (!screenState.gameActuallyStarted) { 
                draw(); 
                updateMainButtonStates(); 
                return;
            }
            
            // If we reach here, screenState.gameActuallyStarted is true.
            // Update display variables to the actual level being started
            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);

            if (gameMode === 'levels') {
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else { // Should only happen if all levels/worlds are completed
                    displayTargetScore = TARGET_SCORES_LEVELS[TARGET_SCORES_LEVELS.length -1];
                    console.warn("Attempting to start a level beyond defined targets. Using last target score.");
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            } else { // freeMode
                displayTargetScore = 0; // No target score in free mode
            }

            updateTargetScoreDisplay(); // Update UI with the target of the level to be played
            if (progressPanelLeftValue && gameMode === 'levels') { // Update progress panel UI
                progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
            } else if (progressPanelLeftValue && gameMode === 'maze') {
                progressPanelLeftValue.textContent = displayMazeLevel;
            } else if (progressPanelLeftValue && (gameMode === 'freeMode' || gameMode === 'classification')) {
                // El panel de #high-score-display ahora se encarga de su propio label.
                // progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;
            }
            drawStarProgress(); // Update stars for the current world being played


            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            if (audioContextStarted && areSfxEnabled) {
                 playSound('startGame');
            }

            let desiredMusic = inGameBackgroundMusicURL;
            if (gameMode === 'levels') {
                desiredMusic = WORLD_MUSIC_URLS[currentWorld] || inGameBackgroundMusicURL;
            } else if (gameMode === 'maze') {
                desiredMusic = MODE_MUSIC_URLS.maze;
            } else if (gameMode === 'freeMode') {
                desiredMusic = MODE_MUSIC_URLS.freeMode;
            } else if (gameMode === 'classification') {
                desiredMusic = MODE_MUSIC_URLS.classification;
            }
            let sourceChanged = false;
            if (inGameBackgroundMusic && inGameBackgroundMusic.src !== desiredMusic) {
                inGameBackgroundMusic.src = desiredMusic;
                sourceChanged = true;
            }

            if (generalBackgroundMusic) {
                generalBackgroundMusic.pause();
                console.log("Música general pausada (startGame).");
            }
            if (isMusicEnabled && inGameBackgroundMusic) {
                if (sourceChanged) {
                    inGameBackgroundMusic.currentTime = 0;
                }
                inGameBackgroundMusic.play().catch(e => console.error("Error al reproducir música de partida (startGame):", e));
                console.log("Música de partida iniciada (startGame).");
            } else if (inGameBackgroundMusic) {
                inGameBackgroundMusic.pause();
            }


            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                snakeSpeed = levelCfg.speed;
                initialSnakeLength = levelCfg.initialLength;
                MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
            } else if (gameMode === 'freeMode') {
                const cfg = freeModeSettings;
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = cfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            } else if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = cfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            } else { // maze
                snakeSpeed = DIFFICULTY_SETTINGS.principiante.speed;
                initialSnakeLength = DIFFICULTY_SETTINGS.principiante.initialLength;
                MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
            }

            applySkin(skinSelector.value); 
            
            resizeGameElements(); 
            if (tileCountX <= 0 || tileCountY <= 0) { 
                console.error("Pantalla demasiado pequeña para jugar.");
                updateMainButtonStates();
                return;
            }

            snake = [];
            let startX = Math.floor(tileCountX / 2);
            let startY = Math.floor(tileCountY / 2);
            if (gameMode === 'maze' && displayMazeLevel === 3) {
                startX = 1;
                startY = 1;
            }
            snakeSpawnRow = startY;
            for (let i = 0; i < initialSnakeLength; i++) {
                if (startX - i >= 0) { snake.push({ x: startX - i, y: startY }); }
                else { snake.push({ x: 0, y: startY }); }
            }
             if (snake.length === 0 && initialSnakeLength > 0) {
                console.error("Error al iniciar la serpiente. Pantalla muy pequeña.");
                updateMainButtonStates();
                return;
            }

            score = 0;
            streakMultiplier = 1; 
            gameOver = false; 
            direction = "right"; 
            nextDirection = "right"; // Asegurar que nextDirection también se reinicia
            
            if (gameMode === 'levels' || gameMode === 'maze') {
                gameTimeRemaining = LEVEL_TIME_LIMIT;
                // Target score already updated via displayTargetScore
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = setInterval(() => {
                    if (gameOver) { clearInterval(gameTimerIntervalId); return; }
                    gameTimeRemaining -= 1000;
                    updateTimeLengthDisplay();
                    if (gameTimeRemaining <= 0) {
                        if (!gameOver) {
                            gameOver = true;
                            gameOverByTimeout = true;
                            finalizeGameOver();
                        }
                        clearInterval(gameTimerIntervalId);
                    }
                }, 1000);
            } else if (gameMode === 'classification' || gameMode === 'freeMode') {
                gameTimeElapsed = 0;
                if (gameMode === 'freeMode') {
                    gameTimeRemaining = Infinity;
                }
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = setInterval(() => {
                    if (gameOver) { clearInterval(gameTimerIntervalId); return; }
                    gameTimeElapsed += 1000;
                    updateTimeLengthDisplay();
                }, 1000);
            } else {
                gameTimeElapsed = 0;
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
            }
            if (gameMode === "levels" && (currentWorld === 7 || currentWorld === 8 || currentWorld === 10)) {
                startWorld4FalseFoodMechanics();
            } else {
                stopWorld4FalseFoodMechanics();
            }
            if (gameMode === "levels" && currentWorld === 8) {
                startWorld5Obstacles();
            } else if (gameMode === "levels" && currentWorld === 3) {
                stopWorld6Obstacles();
                startWorld6LightningMechanics();
            } else if (gameMode === "levels" && currentWorld === 4) {
                stopWorld6Obstacles();
                startWorld6LightningMechanics();
            } else if (gameMode === "levels" && currentWorld === 9) {
                startWorld6Obstacles();
                startWorld6LightningMechanics();
                startWorld7MirrorMechanics();
            } else if (gameMode === "levels" && currentWorld === 10) {
                startWorld8Obstacles();
                startWorld6LightningMechanics();
                startWorld7MirrorMechanics();
            } else if (gameMode === 'classification') {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                stopWorld4FalseFoodMechanics();
                const rank = CLASSIFICATION_RANKS[difficultySelector.value] || 0;
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (rank >= 2) startWorld6LightningMechanics();
                if (rank >= 3) {
                    startWorld4FalseFoodMechanics();
                    const count = cfg.obstacleCount;
                    if (rank >= 4) {
                        startWorld8Obstacles(count);
                    } else {
                        startWorld6Obstacles(count);
                    }
                    startWorld7MirrorMechanics();
                }
            } else if (gameMode === 'maze') {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                startMazeLevel();
            } else {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                stopWorld4FalseFoodMechanics();
                if (freeModeSettings.obstacleCount > 0) startWorld6Obstacles(freeModeSettings.obstacleCount);
                if (freeModeSettings.lightningSpawnRange) startWorld6LightningMechanics();
                if (freeModeSettings.falseFoodSpawnRange) startWorld4FalseFoodMechanics();
                if (freeModeSettings.mirrorSpawnRange) startWorld7MirrorMechanics();
            }
            
            generateFood(); 
            updateScoreDisplay();
            clearInterval(gameIntervalId); 
            gameIntervalId = setInterval(update, snakeSpeed); 

            updateMainButtonStates(); 
            
            difficultySelector.disabled = true;
            worldsSelector.disabled = true;
            audioToggleSelector.disabled = true;
            skinSelector.disabled = true;
            foodSelector.disabled = true;
            musicVolumeSlider.disabled = true;
            sfxVolumeSlider.disabled = true;
            difficultyControlGroup.classList.remove("interactive-mode");
            audioControlGroup.classList.remove("interactive-mode");
            skinControlGroup.classList.remove("interactive-mode");
            foodControlGroup.classList.remove("interactive-mode");
            musicVolumeControlGroup.classList.remove("interactive-mode");
            sfxVolumeControlGroup.classList.remove("interactive-mode");
            if (gameMode === 'freeMode') {
                lastMovementTime = Date.now();
                clearInterval(inactivityIntervalId);
                inactivityIntervalId = setInterval(() => {
                    if (gameMode === 'freeMode' && gameIntervalId && !gameOver && Date.now() - lastMovementTime >= FREE_MODE_INACTIVITY_LIMIT) {
                        gameOverByInactivity = true;
                        finalizeGameOver();
                    }
                }, 1000);
            }
            draw();
        }

        function changeDirection(newDirectionCmd) { // Renamed parameter for clarity
            if (gameOver) return;
            if (gameMode === 'freeMode') {
                lastMovementTime = Date.now();
            }
            // Invert controls if mirror effect active
            if (controlsInverted) {
                switch (newDirectionCmd) {
                    case "up": newDirectionCmd = "down"; break;
                    case "down": newDirectionCmd = "up"; break;
                    case "left": newDirectionCmd = "right"; break;
                    case "right": newDirectionCmd = "left"; break;
                }
            }
            // Solo actualizar nextDirection, no direction directamente
            switch (newDirectionCmd) {
                case "up":    if (direction !== "down")  nextDirection = "up"; break;
                case "down":  if (direction !== "up")    nextDirection = "down"; break;
                case "left":  if (direction !== "right") nextDirection = "left"; break;
                case "right": if (direction !== "left")  nextDirection = "right"; break;
            }
        }

        async function playSound(type, param = null) {
            if (!areSfxEnabled) return; 
            
            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            if (!audioContextStarted) {
                console.warn(`Audio context not running, cannot play sound: ${type}`);
                return;
            }
            // initializeToneSynths() is called by ensureAudioContextRunning if needed

            if (!synthsInitialized) { // Check again if initialization failed even after ensureAudioContextRunning
                 console.warn(`Synths not initialized, cannot play sound: ${type}`);
                return;
            }

            const now = Tone.now();
            try {
                if (type === 'eat') {
                    if (synthEat) { const baseNote = "D5"; const targetNote = "A4"; const duration = 0.07; synthEat.triggerAttack(baseNote, now); synthEat.frequency.linearRampToValueAtTime(targetNote, now + duration * 0.7); synthEat.triggerRelease(now + duration); }
                    if (synthEatNoise) { synthEatNoise.triggerAttackRelease("64n", now + 0.005); }
                } else if (type === 'badEat' && synthBadEat) {
                    const duration = 0.1;
                    synthBadEat.triggerAttack("G4", now);
                    synthBadEat.frequency.linearRampToValueAtTime("C4", now + duration * 0.7);
                    synthBadEat.triggerRelease(now + duration);
                    if (synthEatNoise) { synthEatNoise.triggerAttackRelease("64n", now + 0.005); }
                } else if (type === 'warning' && synthWarning) { synthWarning.triggerAttackRelease("A4", "32n", now);
                } else if (type === 'timeout' && synthTimeout) { synthTimeout.triggerAttackRelease("F#3", "8n", now);
                } else if (type === 'gameOver' && synthGameOver) { synthGameOver.triggerAttackRelease("G3", "8n", now); synthGameOver.triggerAttackRelease("E3", "8n", now + 0.15); synthGameOver.triggerAttackRelease("C3", "4n", now + 0.3);
                } else if (type === 'startGame' && synthStartGame) { synthStartGame.triggerAttackRelease("C4", "16n", now); synthStartGame.triggerAttackRelease("E4", "16n", now + 0.1); synthStartGame.triggerAttackRelease("G4", "8n", now + 0.2); 
                } else if (type === 'win' && synthWin) {
                    const tempo = 0.12;
                    synthWin.triggerAttackRelease("G4", "16n", now);
                    synthWin.triggerAttackRelease("G4", "16n", now + tempo * 1);
                    synthWin.triggerAttackRelease("C5", "16n", now + tempo * 2);
                    synthWin.triggerAttackRelease("E5", "8n", now + tempo * 3);
                    synthWin.triggerAttackRelease("C5", "16n", now + tempo * 5);
                    synthWin.triggerAttackRelease("G5", "4n", now + tempo * 6);
                } else if (type === 'coinAdd' && synthCoinNoise && synthCoinChime) {
                    const duration = typeof param === 'number' ? param : 1;
                    synthCoinNoise.triggerAttackRelease(duration, now);
                    synthCoinChime.triggerAttackRelease("C6", "16n", now + Math.max(0, duration - 0.1));
                } else if (type === 'modeSwitch' && synthModeSwitch) {
                    synthModeSwitch.triggerAttackRelease('C5', '16n', now);
                } else if (type === 'modeSelect' && synthModeSelect) {
                    synthModeSelect.triggerAttackRelease('G4', '16n', now);
                    synthModeSelect.triggerAttackRelease('C5', '16n', now + 0.1);
                }
            } catch (error) { console.error("Error al reproducir sonido con Tone.js:", error); }
        }
        
        function updateMusicVolume() {
            const sliderValue = parseInt(musicVolumeSlider.value);
            if (musicVolumeValue) {
                musicVolumeValue.textContent = sliderValue;
            }
            // For HTML5 Audio, volume is 0.0 to 1.0
            const actualVolume = (sliderValue / 100) * MAX_ACTUAL_SLIDER_MAPPED_VOLUME;
            if (generalBackgroundMusic) {
                generalBackgroundMusic.volume = actualVolume;
            }
            if (inGameBackgroundMusic) {
                inGameBackgroundMusic.volume = actualVolume;
            }
            saveGameSettings();
        }

        function updateSfxVolume() {
            const sliderValue = parseInt(sfxVolumeSlider.value);
            if (sfxVolumeValue) {
                sfxVolumeValue.textContent = sliderValue;
            }
            if (sfxGain) {
                sfxGain.gain.value = sliderValue / 100;
            }
            saveGameSettings();
        }

        musicVolumeSlider.addEventListener('input', updateMusicVolume);
        sfxVolumeSlider.addEventListener('input', updateSfxVolume);

        audioToggleSelector.addEventListener('change', async function() {
            const audioSetting = this.value;
            isMusicEnabled = (audioSetting === 'all' || audioSetting === 'music_only');
            areSfxEnabled = (audioSetting === 'all' || audioSetting === 'sfx_only');

            musicVolumeSlider.disabled = (audioSetting === 'off' || audioSetting === 'sfx_only');
            sfxVolumeSlider.disabled = (audioSetting === 'off' || audioSetting === 'music_only');
            if (isMusicEnabled && !gameIntervalId) {
                musicVolumeControlGroup.classList.add("interactive-mode");
            } else {
                musicVolumeControlGroup.classList.remove("interactive-mode");
            }
            if (areSfxEnabled && !gameIntervalId) {
                sfxVolumeControlGroup.classList.add("interactive-mode");
            } else {
                sfxVolumeControlGroup.classList.remove("interactive-mode");
            }

            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            // initializeToneSynths() is called by ensureAudioContextRunning if needed
            
            if (!audioContextStarted && (isMusicEnabled || areSfxEnabled)) { // If context still not started
                console.warn("Audio context could not be unlocked by user interaction via toggle.");
            }


            if (isMusicEnabled) { // Using HTML5 Audio
                updateMusicVolume();
                updateSfxVolume();
                updateSfxVolume();
                if (gameIntervalId) { // Game is active
                    if (generalBackgroundMusic) generalBackgroundMusic.pause();
                    if (inGameBackgroundMusic && inGameBackgroundMusic.paused) {
                         inGameBackgroundMusic.play().catch(e => console.error("Error al reproducir música de juego (toggle ON):", e));
                    }
                } else { // Menu or game over
                    if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
                    if (generalBackgroundMusic && generalBackgroundMusic.paused) {
                         generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (toggle ON):", e));
                    }
                }
            } else {
                if (generalBackgroundMusic) generalBackgroundMusic.pause();
                if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
            }
            if (!isMusicEnabled) updateSfxVolume();
            saveGameSettings();
        });


        skinSelector.addEventListener('change', function() {
            applySkin(this.value);
            saveGameSettings();
        });

        foodSelector.addEventListener('change', function() {
            applyFood(this.value);
            saveGameSettings();
        });

        playerNameSelectors.forEach(sel => sel.addEventListener('change', function() {
            const previous = currentPlayerName;
            const keepDifficulty = difficultySelector.value;
            saveGameSettings(); // Save previous profile
            currentPlayerName = this.value;
            if (!playerProfiles[currentPlayerName]) {
                playerProfiles[currentPlayerName] = createDefaultProfile(currentPlayerName);
            }
            playerNameSelectors.forEach(s => { if (s !== this) s.value = this.value; });
            applyProfile(playerProfiles[currentPlayerName]);
            if (gameMode === 'classification') {
                difficultySelector.value = keepDifficulty;
                classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(keepDifficulty);
            }
            const savedCoins = parseInt(localStorage.getItem('snakeGameCoins'), 10);
            totalCoins = Number.isFinite(savedCoins) && savedCoins >= 0 ? savedCoins : 0;

            if (!gameIntervalId) {
                if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                } else if (gameMode === 'levels') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    drawStarProgress();
                }
            }

            updateCoinDisplay();
            updateGameModeUI();
            requestAnimationFrame(draw);
            saveGameSettings();
        }));

        function addNewPlayerFromInput() {
            const newName = newPlayerNameInput.value.trim().slice(0, 10);
            if (newName) {
                if (!playerProfiles[newName]) {
                    playerProfiles[newName] = createDefaultProfile(newName);
                }
                updatePlayerNameSelectors(newName);
                currentPlayerName = newName;
                newPlayerNameInput.value = '';
                const keepDifficulty = difficultySelector.value;
                applyProfile(playerProfiles[currentPlayerName]);
                if (gameMode === 'classification') {
                    difficultySelector.value = keepDifficulty;
                    classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(keepDifficulty);
                }
                updateCoinDisplay();
                updateGameModeUI();
                requestAnimationFrame(draw);
                saveGameSettings();
            }
        }

        if (confirmAddPlayerButton) {
            confirmAddPlayerButton.addEventListener('click', addNewPlayerFromInput);
        }
        if (newPlayerNameInput) {
            newPlayerNameInput.addEventListener('keyup', function(e) { if (e.key === 'Enter') addNewPlayerFromInput(); });
            newPlayerNameInput.addEventListener('blur', addNewPlayerFromInput);
            newPlayerNameInput.addEventListener('input', function() {
                if (this.value.length > 10) this.value = this.value.slice(0, 10);
            });
        }
        if (deletePlayerNameButton) {
            deletePlayerNameButton.addEventListener('click', function() {
                if (Object.keys(playerProfiles).length <= 1) return;
                const nameToDelete = getSelectedPlayerName();
                if (nameToDelete === 'Snake') return;
                if (playerProfiles[nameToDelete]) delete playerProfiles[nameToDelete];
                const remaining = Object.keys(playerProfiles);
                const newSelection = remaining[0];
                updatePlayerNameSelectors(newSelection);
                currentPlayerName = newSelection;
                const keepDifficulty = difficultySelector.value;
                applyProfile(playerProfiles[currentPlayerName]);
                if (gameMode === 'classification') {
                    difficultySelector.value = keepDifficulty;
                    classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(keepDifficulty);
                }
                updateCoinDisplay();
                updateGameModeUI();
                requestAnimationFrame(draw);
                saveGameSettings();
            });
        }

        difficultySelector.addEventListener('change', function() {
            const oldIndex = classificationDifficultyIndex;
            difficulty = this.value;
            classificationDifficultyIndex = CLASSIFICATION_DIFFICULTY_ORDER.indexOf(this.value);
            if (!gameIntervalId) {
                const cfg = (gameMode === 'freeMode') ? freeModeSettings : DIFFICULTY_SETTINGS[difficulty];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
            }
            // updateTargetScoreDisplay(); // No target score in free mode based on difficulty
            if (gameMode === 'freeMode') { // Update high score display if difficulty changes in free mode
                displayHighScoreInPanel();
            } else if (gameMode === 'classification') {
                displayClassificationHighScoreInPanel();
                populateClassificationRanking();
                // También actualizamos la dificultad mostrada en pantalla
                if (progressPanelLeftValue) {
                    progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficulty] || difficulty;
                }
            }
            if (gameMode === 'classification' &&
                screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                classificationTransitionFrom = oldIndex;
                if (classificationDifficultyIndex === oldIndex) {
                    classificationTransitionDir = 0;
                    classificationTransitionStart = null;
                } else {
                    classificationTransitionDir = (classificationDifficultyIndex > oldIndex) ? 1 : -1;
                    classificationTransitionStart = performance.now();
                }
                requestAnimationFrame(draw);
            }
            saveGameSettings();
        });

        worldsSelector.addEventListener('change', function() {
            if (gameMode === 'levels') {
                const newSelectedWorld = parseInt(this.value);
                if (newSelectedWorld > maxUnlockedWorld) {
                    this.value = currentWorld.toString(); // Revert if trying to select a locked world
                    return;
                }

                currentWorld = newSelectedWorld;
                currentLevelInWorld = worldCurrentLevels[newSelectedWorld - 1] || 1;

                // Update display variables to reflect the new selection
                displayWorld = currentWorld;
                displayLevelInWorld = currentLevelInWorld;
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else {
                    displayTargetScore = 0; 
                }
                updateTargetScoreDisplay(); // Update UI for target score
                if (progressPanelLeftValue) { // Update UI for progress panel
                    progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                }
                drawStarProgress(); // Update stars for the newly selected world


                if (!gameIntervalId) {
                    const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                    snakeSpeed = levelCfg.speed;
                    initialSnakeLength = levelCfg.initialLength;
                }
                
                screenState.showCoverForWorld = currentWorld;
                screenState.gameActuallyStarted = false; 
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;

                saveGameSettings(); 
                
                closeSettingsPanel(); 

                requestAnimationFrame(draw);
            }
        });


        

        function handleStartClick() {
            if (showModeSelect) {
                if (MODE_SELECT_ORDER[modeSelectIndex] === 'intro') return;
                introOptionAvailable = false; // remove intro option after selecting a mode
                if (areSfxEnabled) playSound('modeSelect');
                const selectedMode = MODE_SELECT_ORDER[modeSelectIndex];
                gameMode = selectedMode;
                showModeSelect = false;
                modeTransitionStart = null;

                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
                screenState.mazeResultType = '';
                screenState.gameActuallyStarted = false;

                if (selectedMode === 'levels') {
                    screenState.showCoverForWorld = currentWorld;
                } else if (selectedMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.showFreeModeEnd = false;
                    openFreeSettingsPanel();
                } else if (selectedMode === 'classification') {
                    screenState.showClassificationCover = true;
                    classificationDifficultyIndex = 0;
                    const initDiff = CLASSIFICATION_DIFFICULTY_ORDER[classificationDifficultyIndex];
                    difficultySelector.value = initDiff;
                    difficultySelector.dispatchEvent(new Event('change'));
                } else {
                    screenState.showMazeCover = true;
                }
                updateGameModeUI();
                maybeShowInitialHelpForMode(selectedMode);
                draw();
                updateMainButtonStates();
            } else {
                startGame(false);
            }
        }

        function handleBackButtonClick() {
            if (showModeSelect) {
                // Return to splash screen
                showModeSelect = false;
                introOptionAvailable = true;
                modeTransitionStart = null;
                gameMode = '';
                if (gameContainer) gameContainer.classList.add('hidden');
                if (splashScreen) splashScreen.classList.remove('hidden');
            } else {
                // Return to mode selection
                showModeSelect = true;
                modeTransitionStart = null;
                introOptionAvailable = true;
                modeSelectIndex = 0;
                gameMode = '';

                // Cancel any in-progress transitions
                worldTransitionStart = null;
                classificationTransitionStart = null;
                mazeTransitionStart = null;
                worldTransitionDir = 0;
                classificationTransitionDir = 0;
                mazeTransitionDir = 0;

                // Hide all cover images
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showFreeModeEnd = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
                screenState.mazeResultType = '';
                screenState.gameActuallyStarted = false;

                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
                draw();
            }
            updateGameModeUI();
            updateMainButtonStates();
        }

        function displayClassificationHighScoreInPanel() {
            const selectedDifficulty = difficultySelector.value;
            const highScores = loadClassificationHighScores(selectedDifficulty);
            const hsSkinValueDisplay = document.getElementById("hs-skin-value");

            if (highScores.length > 0) {
                hsScoreValue.textContent = highScores[0].score;
                if (hsSkinValueDisplay) {
                    const displayName = highScores[0].playerName || SKIN_DISPLAY_NAMES[highScores[0].skin] || highScores[0].skin || '-';
                    hsSkinValueDisplay.textContent = displayName;
                }
            } else {
                hsScoreValue.textContent = "-";
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = "-";
                }
            }
        }

        function populateClassificationRanking() {
            if (!classificationRankingList) return;
            const selectedDifficulty = difficultySelector.value;
            const scores = loadClassificationHighScores(selectedDifficulty);
            classificationRankingList.innerHTML = '';

            for (let i = 0; i < MAX_HIGH_SCORES; i++) {
                const entry = scores[i];
                const row = document.createElement('tr');
                const playerDisplay = entry ? (entry.playerName || SKIN_DISPLAY_NAMES[entry.skin] || entry.skin || '-') : '---';
                const scoreVal = entry ? entry.score : '---';
                const timeVal = entry ? formatTime(entry.time) : '---';
                row.innerHTML = `<td>${i + 1}.</td><td>${scoreVal}</td><td>${timeVal}</td><td>${playerDisplay}</td>`;
                classificationRankingList.appendChild(row);
            }
        }


        document.addEventListener("keydown", (e) => {
            const isSettingsOpen = !settingsPanel.classList.contains("settings-panel-hidden");
            const isInfoOpen = !infoPanel.classList.contains("info-panel-hidden");
            const isSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden");

            if (!isSettingsOpen && !isInfoOpen && !isSpecificInfoOpen) {
                const key = e.key.toLowerCase();
                if (screenState.showCoverForWorld && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                    if (key === 'arrowleft' || key === 'a') { startWorldTransition(-1); e.preventDefault(); return; }
                    if (key === 'arrowright' || key === 'd') { startWorldTransition(1); e.preventDefault(); return; }
                    if (key === 'enter') { if (displayWorld <= maxUnlockedWorld) startGame(false); e.preventDefault(); return; }
                } else if (screenState.showMazeCover && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                    if (key === 'arrowleft' || key === 'a') { startMazeTransition(-1); e.preventDefault(); return; }
                    if (key === 'arrowright' || key === 'd') { startMazeTransition(1); e.preventDefault(); return; }
                    if (key === 'enter') { if (displayMazeLevel <= currentMazeLevel) startGame(false); e.preventDefault(); return; }
                }
                if (gameOver && e.key !== "Enter" && gameIntervalId === null) return;
                let newDirectionCmd = null; // Use newDirectionCmd to align with function parameter
                switch (key) {
                    case "arrowup": case "w": newDirectionCmd = "up"; break;
                    case "arrowdown": case "s": newDirectionCmd = "down"; break;
                    case "arrowleft": case "a": newDirectionCmd = "left"; break;
                    case "arrowright": case "d": newDirectionCmd = "right"; break;
                    case "enter": if (gameOver || !gameIntervalId) { startGame(false); } break;
                }
                if (newDirectionCmd) { changeDirection(newDirectionCmd); }
                if (["arrowup", "arrowdown", "arrowleft", "arrowright", "w", "a", "s", "d"].includes(key)) { e.preventDefault(); }
            } else if (isSpecificInfoOpen) {
                 if (e.key === "Escape") { closeSpecificInfoPanel(); }
            } else if (isSettingsOpen) {
                 if (e.key === "Escape") { closeSettingsPanel(); }
            } else if (isInfoOpen) {
                 if (e.key === "Escape") { closeInfoPanel(); }
            }
        });

        // D-Pad Button Press Feedback
        [upButton, downButton, leftButton, rightButton].forEach(button => {
            button.addEventListener("mousedown", () => {
                if (gameIntervalId) button.classList.add("d-pad-button-pressed");
            });
            button.addEventListener("mouseup", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("mouseleave", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("touchstart", (e) => {
                e.preventDefault();
                if (gameIntervalId) button.classList.add("d-pad-button-pressed");
                changeDirection(button.id.replace('-button', ''));
            });
            button.addEventListener("touchend", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("touchcancel", () => button.classList.remove("d-pad-button-pressed"));
        });

        // Icon Button Press Feedback
        function addIconPressEvents(btn, icon) {
            if (!btn || !icon) return;
            btn.addEventListener('mousedown', () => icon.classList.add('icon-button-pressed'));
            btn.addEventListener('mouseup', () => icon.classList.remove('icon-button-pressed'));
            btn.addEventListener('mouseleave', () => icon.classList.remove('icon-button-pressed'));
            btn.addEventListener('touchstart', () => icon.classList.add('icon-button-pressed'));
            btn.addEventListener('touchend', () => icon.classList.remove('icon-button-pressed'));
            btn.addEventListener('touchcancel', () => icon.classList.remove('icon-button-pressed'));
        }

        addIconPressEvents(configButton, configButtonIcon);
        addIconPressEvents(backButton, backButtonIcon);
        addIconPressEvents(restartMazeButton, restartMazeButtonIcon);
        addIconPressEvents(modeLeftButton, modeLeftButtonIcon);
        addIconPressEvents(modeRightButton, modeRightButtonIcon);
        addIconPressEvents(startButton, startButton);
        addIconPressEvents(applyFreeSettingsBottomButton, applyFreeSettingsBottomButton);
        addIconPressEvents(resetDataButton, resetDataButton);
        addIconPressEvents(confirmResetYesButton, confirmResetYesButton);
        addIconPressEvents(confirmResetNoButton, confirmResetNoButton);

        // Original click listeners for D-Pad 
        upButton.addEventListener("click", () => changeDirection("up"));
        downButton.addEventListener("click", () => changeDirection("down"));
        leftButton.addEventListener("click", () => changeDirection("left"));
        rightButton.addEventListener("click", () => changeDirection("right"));

        function startModeTransition(dir) {
            if (modeTransitionStart !== null) return;
            modeTransitionDir = dir;
            modeTransitionFrom = modeSelectIndex;

            do {
                modeSelectIndex = (modeSelectIndex + dir + MODE_SELECT_ORDER.length) % MODE_SELECT_ORDER.length;
                if (introOptionAvailable && MODE_SELECT_ORDER[modeSelectIndex] !== 'intro') {
                    introOptionAvailable = false; // once user moves away from intro, remove it
                }
            } while (!introOptionAvailable && MODE_SELECT_ORDER[modeSelectIndex] === 'intro');

            modeTransitionStart = performance.now();
            draw();
        }

        function startClassificationTransition(dir) {
            if (classificationTransitionStart !== null) return;
            classificationTransitionDir = dir;
            classificationTransitionFrom = classificationDifficultyIndex;
            classificationDifficultyIndex = (classificationDifficultyIndex + dir + CLASSIFICATION_DIFFICULTY_ORDER.length) % CLASSIFICATION_DIFFICULTY_ORDER.length;
            const newDiff = CLASSIFICATION_DIFFICULTY_ORDER[classificationDifficultyIndex];
            difficultySelector.value = newDiff;
            difficultySelector.dispatchEvent(new Event('change'));
            updateGameModeUI();
            saveGameSettings();
            classificationTransitionStart = performance.now();
            if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                requestAnimationFrame(draw);
            }
        }
        function startWorldTransition(dir) {
            if (worldTransitionStart !== null) return;
            worldTransitionDir = dir;
            worldTransitionFrom = displayWorld;
            displayWorld = ((displayWorld - 1 + dir + TOTAL_WORLDS) % TOTAL_WORLDS) + 1;
            if (displayWorld <= maxUnlockedWorld) {
                currentWorld = displayWorld;
                currentLevelInWorld = worldCurrentLevels[currentWorld - 1] || 1;
                const absoluteIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
                displayLevelInWorld = currentLevelInWorld;
                displayTargetScore = TARGET_SCORES_LEVELS[absoluteIndex] || 0;
                if (!gameIntervalId) {
                    const cfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                    snakeSpeed = cfg.speed;
                    initialSnakeLength = cfg.initialLength;
                }
                saveGameSettings();
            } else {
                // Al mostrar la portada de un mundo bloqueado, aseguramos que el
                // nivel visualizado sea siempre 1 y se muestre su puntuación objetivo
                displayLevelInWorld = 1;
                const absoluteIndex = (displayWorld - 1) * LEVELS_PER_WORLD;
                displayTargetScore = TARGET_SCORES_LEVELS[absoluteIndex] || 0;
            }
            screenState.showCoverForWorld = displayWorld;
            screenState.showWorldCompleteCover = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showFreeModeCover = false;
            updateGameModeUI();
            worldTransitionStart = performance.now();
            if (!screenState.gameActuallyStarted) {
                requestAnimationFrame(draw);
            }
        }

        function startMazeTransition(dir) {
            if (mazeTransitionStart !== null) return;
            mazeTransitionDir = dir;
            mazeTransitionFrom = displayMazeLevel;
            displayMazeLevel = ((displayMazeLevel - 1 + dir + MAZE_LEVEL_COUNT) % MAZE_LEVEL_COUNT) + 1;

            mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
            mazeStarsEarned = mazePreviousStars;
            if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
            } else {
                displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
            }
            if (progressPanelLeftValue) {
                progressPanelLeftValue.textContent = displayMazeLevel;
            }
            drawStarProgress();

            screenState.showMazeCover = true;
            screenState.mazeResultType = '';
            updateGameModeUI();
            saveGameSettings();
            mazeTransitionStart = performance.now();
            if (!screenState.gameActuallyStarted) {
                requestAnimationFrame(draw);
            }
        }


        modeLeftButton.addEventListener("click", () => {
            if (showModeSelect) {
                startModeTransition(-1);
            } else if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                startClassificationTransition(-1);
            } else if (screenState.showCoverForWorld && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                startWorldTransition(-1);
            } else if (screenState.showMazeCover && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                startMazeTransition(-1);
            }
            if (areSfxEnabled) playSound('modeSwitch');
        });
        modeRightButton.addEventListener("click", () => {
            if (showModeSelect) {
                startModeTransition(1);
            } else if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                startClassificationTransition(1);
            } else if (screenState.showCoverForWorld && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                startWorldTransition(1);
            } else if (screenState.showMazeCover && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                startMazeTransition(1);
            }
            if (areSfxEnabled) playSound('modeSwitch');
        });

        startButton.addEventListener("click", handleStartClick);
        restartMazeButton.addEventListener("click", () => {
            if (areSfxEnabled) playSound('modeSwitch');
            startGame(true);
        });
        
        window.addEventListener('resize', resizeGameElements); 
        
        function saveGameSettings() {
            const profile = playerProfiles[currentPlayerName] || createDefaultProfile(currentPlayerName);
            profile.name = currentPlayerName;
            profile.difficulty = difficultySelector.value;
            profile.skin = skinSelector.value;
            profile.food = foodSelector.value;
            profile.audioGeneral = audioToggleSelector.value;
            profile.musicVolume = musicVolumeSlider.value;
            profile.sfxVolume = sfxVolumeSlider.value;
            profile.gameMode = gameMode;
            profile.currentWorld = currentWorld;
            profile.currentLevelInWorld = currentLevelInWorld;
            profile.maxUnlockedWorld = maxUnlockedWorld;
            profile.levelsProgress = levelsProgress;
            profile.worldCurrentLevels = worldCurrentLevels;
            profile.currentMazeLevel = currentMazeLevel;
            profile.mazeLevelStars = mazeLevelStars;
            profile.freeModeSettings = freeModeSettings;
            playerProfiles[currentPlayerName] = profile;
            savePlayerProfiles();
            localStorage.setItem('snakeGameCoins', totalCoins.toString());
            localStorage.setItem('snakePlayerNames', JSON.stringify(Object.keys(playerProfiles)));
            localStorage.setItem('snakeGamePlayerName', currentPlayerName);
            console.log("Configuraciones guardadas en localStorage.");
        }

        function loadGameSettings() {
            loadPlayerProfiles();
            updatePlayerNameSelectors();
            const savedPlayerName = localStorage.getItem('snakeGamePlayerName');
            if (savedPlayerName && playerProfiles[savedPlayerName]) {
                currentPlayerName = savedPlayerName;
            } else {
                currentPlayerName = Object.keys(playerProfiles)[0];
            }
            updatePlayerNameSelectors(currentPlayerName);
            applyProfile(playerProfiles[currentPlayerName]);
            updateSfxVolume();
            const savedCoins = parseInt(localStorage.getItem('snakeGameCoins'), 10);
            totalCoins = Number.isFinite(savedCoins) && savedCoins >= 0 ? savedCoins : 0;

            // Always start with no mode selected
            gameMode = '';

            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            modeSelectIndex = MODE_SELECT_ORDER.indexOf(gameMode);

            if (gameMode === 'levels') {
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else { // Default if out of bounds (e.g., after completing all levels)
                    displayTargetScore = TARGET_SCORES_LEVELS[TARGET_SCORES_LEVELS.length -1];
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            } else {
                displayTargetScore = 0; // No target score for free mode
            }


            difficulty = difficultySelector.value;
            const cfg = DIFFICULTY_SETTINGS[difficulty];
            snakeSpeed = cfg.speed;
            initialSnakeLength = cfg.initialLength;
            currentSkin = skinSelector.value;
            currentFood = foodSelector.value;
            currentPlayerName = getSelectedPlayerName();
            
            isMusicEnabled = (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'music_only');
            areSfxEnabled = (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'sfx_only');
            
            if(musicVolumeValue) musicVolumeValue.textContent = musicVolumeSlider.value; 

            console.log("Configuraciones cargadas de localStorage y aplicadas a selectores.");
            updateGameModeUI(); // This will use the newly set display variables
            updateCoinDisplay();
        }


        async function initializeGameLogic() { 
            if (!canvasEl) { 
                console.error("Elemento Canvas no encontrado en initializeGameLogic.");
                return;
            }
            if (!ctx) { 
                 ctx = canvasEl.getContext("2d");
                 if (!ctx) {
                    console.error("Fallo al obtener el contexto 2D del canvas en initializeGameLogic.");
                    return; 
                 }
            }
            
            // HTML5 Audio objects are now created in window.onload
            // Volume is also applied there via updateMusicVolume()
            // Tone.js synths (except splash) are initialized via ensureAudioContextRunning -> initializeToneSynths

            if (typeof Audio !== 'undefined') {
                // Music playback logic based on current game state
                const isSettingsOpen = settingsPanel && !settingsPanel.classList.contains("settings-panel-hidden");
                const isInfoOpen = infoPanel && !infoPanel.classList.contains("info-panel-hidden");
                if (isMusicEnabled && !gameIntervalId && !gameOver && !isSettingsOpen && !isInfoOpen && !screenState.showCoverForWorld && !screenState.showWorldCompleteCover && !screenState.showLevelCompleteCover && !screenState.showDefeatCoverForWorld && !screenState.showFreeModeCover && !screenState.showClassificationCover && !screenState.showMazeCover && !screenState.mazeResultType) {
                    if (inGameBackgroundMusic && !inGameBackgroundMusic.paused) {
                        inGameBackgroundMusic.pause();
                    }
                    if (generalBackgroundMusic && generalBackgroundMusic.paused) {
                        generalBackgroundMusic.play().catch(e => console.warn("Reproducción automática de música general (initializeGameLogic) fallida:", e));
                    }
                } else if (!isMusicEnabled || screenState.showCoverForWorld || screenState.showWorldCompleteCover || screenState.showLevelCompleteCover || screenState.showDefeatCoverForWorld || screenState.showTimeoutCover || screenState.showFreeModeCover || screenState.showClassificationCover || screenState.showMazeCover || screenState.mazeResultType) { // Pause if music disabled or any cover shown
                    if (generalBackgroundMusic) generalBackgroundMusic.pause();
                    if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
                }
            }


            requestAnimationFrame(() => {
                resizeGameElements(); 
                draw();                 
                updateMainButtonStates(); 
            });

            applySkin(currentSkin); // Apply skin based on loaded settings
            applyFood(currentFood);

            // Reset screen states for a fresh start after splash
            screenState.gameActuallyStarted = false; 
            screenState.showWorldCompleteCover = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showFreeModeCover = false;
            screenState.showFreeModeEnd = false;
            screenState.showClassificationCover = false;

            // Set initial display state based on current gameMode
            // but ensure correct cover screen is shown
            if (gameMode === 'levels') {
                screenState.showCoverForWorld = currentWorld; // currentWorld from loaded settings
            } else if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = true;
                screenState.showFreeModeEnd = false;
                // Ensure gameOver is false if free mode cover is shown before first game
                if (snake.length === 0) gameOver = false;
            } else if (gameMode === 'classification') {
                screenState.showClassificationCover = true;
                // Ensure gameOver is false if free mode cover is shown before first game
                if (snake.length === 0) gameOver = false;
            } else if (gameMode === 'maze') {
                screenState.showMazeCover = true;
            }
            updateGameModeUI(); // Refresh UI based on potentially new screenState

        }

        window.onload = () => {
            loadSkinImages();
            loadWorldImages();
            loadModeSelectionImages();
            loadGameSettings(); // Loads settings including audio preferences and volume
            loadLives();
            setInterval(checkLifeRecovery, 1000);

            // Initialize HTML5 Audio Players
            if (typeof Audio !== 'undefined') {
                if (!generalBackgroundMusic) {
                    generalBackgroundMusic = new Audio(generalBackgroundMusicURL);
                    generalBackgroundMusic.loop = true;
                    console.log("Reproductor de música general (HTML5 Audio) creado en window.onload.");
                }
                if (!inGameBackgroundMusic) {
                    inGameBackgroundMusic = new Audio(inGameBackgroundMusicURL);
                    inGameBackgroundMusic.loop = true;
                    console.log("Reproductor de música de partida (HTML5 Audio) creado en window.onload.");
                }
                // Apply loaded volume settings. updateMusicVolume is safe to call.
                // It reads from musicVolumeSlider.value which is set by loadGameSettings.
                updateMusicVolume();
                updateSfxVolume();
            } else {
                console.warn("HTML5 Audio no soportado, música de fondo desactivada (chequeo en window.onload).");
                isMusicEnabled = false; // Ensure this is set if Audio is not supported
                areSfxEnabled = (audioToggleSelector.value === 'sfx_only'); // Keep SFX if it was sfx_only
                if (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'music_only') {
                    audioToggleSelector.value = areSfxEnabled ? 'sfx_only' : 'off';
                }
                Array.from(audioToggleSelector.options).forEach(option => {
                   if (option.value === 'all' || option.value === 'music_only') option.disabled = true;
                });
                musicVolumeSlider.disabled = true;
                if (musicVolumeControlGroup) musicVolumeControlGroup.classList.remove("interactive-mode");
                sfxVolumeSlider.disabled = true;
                if (sfxVolumeControlGroup) sfxVolumeControlGroup.classList.remove("interactive-mode");
            }

            const splashStartButtonEl = document.getElementById('splash-start-button');
            const splashTopImageEl = document.getElementById('splash-top-image');
            const splashBottomImageEl = document.getElementById('splash-bottom-image');
            const splashInfoButtonEl = document.getElementById('splash-info-button');
            const splashSettingsButtonEl = document.getElementById('splash-settings-button');

            function attachSplashButtonEvents(btnEl, onClick) {
                if (!btnEl) return;
                btnEl.addEventListener('mousedown', () => btnEl.classList.add('splash-button-pressed'));
                btnEl.addEventListener('mouseup', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('mouseleave', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('touchstart', () => btnEl.classList.add('splash-button-pressed'));
                btnEl.addEventListener('touchend', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('touchcancel', () => btnEl.classList.remove('splash-button-pressed'));
                btnEl.addEventListener('click', onClick);
            }

// Initialize synthSplashStart (Tone.Player) here
            if (typeof Tone !== 'undefined') {
                synthSplashStart = new Tone.Player({
                    url: "https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/f8cf11c2f8447c929e260b8ad8b417d1edc6048c/start-game-v2.mp3",
                    onload: () => { console.log("Sonido del botón de inicio del splash cargado (Tone.Player)."); },
                    onerror: (error) => { console.error("Error cargando sonido del botón de inicio del splash (Tone.Player):", error); }
                }).toDestination();
                synthSplashStart.volume.value = -3.1; // Adjust volume as needed for Tone.Player
                // We no longer call initializeToneSynths() directly here.
                // ensureAudioContextRunning (on first click) will handle it.
            }

            attachSplashButtonEvents(splashInfoButtonEl, () => {
                panelOpenedFromSplash = true;
                if (gameContainer) gameContainer.classList.remove('hidden');
                openInfoPanel();
            });

            attachSplashButtonEvents(splashSettingsButtonEl, () => {
                panelOpenedFromSplash = true;
                if (gameContainer) gameContainer.classList.remove('hidden');
                openSettingsPanel();
            });



            if (splashStartButtonEl) {
                splashStartButtonEl.addEventListener('mousedown', () => {
                    splashStartButtonEl.classList.add('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('mouseup', () => {
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('mouseleave', () => { 
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchstart', (e) => {
                    splashStartButtonEl.classList.add('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchend', () => {
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchcancel', () => { 
                     splashStartButtonEl.classList.remove('splash-button-pressed');
                });

                splashStartButtonEl.addEventListener('click', async () => {
                    console.log("Splash start button CLICK event triggered.");
                    try {
                        splashStartButtonEl.classList.remove('splash-button-pressed'); // Ensure visual state resets

                        const audioContextStarted = await ensureAudioContextRunning(); // This is key for Tone.js
                        if (audioContextStarted) {
                             if (areSfxEnabled && synthSplashStart && synthSplashStart.loaded) { // synthSplashStart is Tone.Player
                                synthSplashStart.start(); // Play the preloaded sound
                             } else if (areSfxEnabled) {
                                 console.warn("Splash sound not played: SFX disabled, synth not loaded, or synth undefined.");
                             }
                        } else {
                            console.warn("Tone.js context could not be started by splash button click.");
                        }

                        if (splashScreen) splashScreen.classList.add('hidden');
                        if (gameContainer) gameContainer.classList.remove('hidden');
                        modeSelectIndex = 0;
                        showModeSelect = true;
                        introOptionAvailable = true; // reset intro visibility on fresh start
                        modeTransitionStart = null;
                        screenState.showCoverForWorld = 0;
                        screenState.showLevelCompleteCover = 0;
                        screenState.showWorldCompleteCover = 0;
                        screenState.showDefeatCoverForWorld = 0;
                        screenState.showTimeoutCover = false;
                        screenState.showFreeModeCover = false;
                        screenState.showMazeCover = false;
                        screenState.mazeResultType = '';
                        initializeGameLogic(); // This will handle playing HTML5 audio if enabled
                        draw();
                        updateMainButtonStates();
                    } catch (error) {
                        console.error("Error within splash start button click handler:", error);
                    }
                });
            } else {
                console.error("Botón de inicio del splash no encontrado!");
                if (splashScreen) splashScreen.classList.add('hidden');
                if (gameContainer) gameContainer.classList.remove('hidden');
                initializeGameLogic();
            }
        };
    </script>
</body>
</html>
