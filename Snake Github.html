<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <title>Snake Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Variable de ancho máximo para sincronizar Splash y juego */
        :root {
            --game-max-width: 520px;
        }

        @media (hover: hover) and (pointer: fine) {
            :root {
                --game-max-width: min(75vmin, 700px);
            }
        }

        /* Estilos base del cuerpo y contenedor del juego */
        html {
            height: 100%;
            overflow: hidden; 
        }
        body {
            height: 100%; 
            font-family: 'Press Start 2P', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center; 
            align-items: center;   
            background-color: #111827; 
            color: #f5f5f5; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden; 
            touch-action: none; 
        }

        .hidden {
            display: none !important;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111827;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #splash-content {
            width: 100%;
            max-width: var(--game-max-width);
            height: 100%;
            display: flex;
            background-color: #02010a;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
           border-radius: 12px;
           box-sizing: border-box;
        }

        #splash-top-image {
            width: 95%;
            max-width: var(--game-max-width); /* Límite para PC, un poco más grande que el juego */
            height: auto;
            object-fit: contain;
            box-sizing: border-box;
        }

        #splash-start-button {
            cursor: pointer;
            width: auto;
            height: auto;
            max-width: min(55vw, 180px); /* Responsivo pero con límite en PC */
            object-fit: contain;
            z-index: 2001;
            transition: transform 0.05s ease-out, filter 0.05s ease-out;
        }

        #splash-start-button.splash-button-pressed {
            transform: scale(0.90) translateY(2px);
            filter: brightness(0.7);
        }

        #splash-bottom-image {
            width: 100%;
            max-width: var(--game-max-width); /* Límite para PC, un poco más grande que el juego */
            height: auto;
            max-height: calc(25vh + 60px);
            object-fit: contain;
            box-sizing: border-box;
            padding-top: 40px;
            padding-bottom: 40px;
        }


        .game-container {
            text-align: center;
            background-color: #1F2937;
            padding-top: 10px;
            padding-left: 10px;
            padding-right: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); 
            border-radius: 12px; 
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            width: 100%; 
            max-width: var(--game-max-width); 
            box-sizing: border-box; 
            height: 100%; 
            display: flex; 
            flex-direction: column;
        }
        #play-area { position: relative; }

        #top-info-bar {
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 8px;
            width: 100%;
            margin: 0 auto 5px auto; 
            position: relative; 
            z-index: 10; 
        }

        #top-info-bar .info-group {
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: center; 
            background-color: #374151; 
            border-radius: 8px;
            padding: 8px 10px; 
            min-width: 80px; 
            min-height: 55px; 
            box-sizing: border-box;
            text-align: center;
        }
        #top-info-bar .info-label {
            font-size: 0.65em; 
            color: #a0aec0; 
            margin-bottom: 4px; 
            display: block; 
            line-height: 1.1;
            word-break: break-word; 
        }
        #top-info-bar .info-value {
            font-size: 0.85em; 
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            line-height: 1.3;
        }

        #title-panel {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px 10px;
            min-height: 55px;
            width: 100%;
            margin: 0 auto 5px auto;
            position: relative;
            z-index: 10;
        }
        #title-panel h2 {
            font-size: 1.4em;
            margin: 0;
            color: #6ee7b7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #progress-panel {
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 8px;
            width: 100%;
            margin: 0 auto 5px auto; 
            position: relative;
            z-index: 10; 
        }

        #current-world-info-group { 
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: center; 
            background-color: #374151; 
            border-radius: 8px;
            padding: 8px 10px; 
            grid-column: 1 / 2; 
            min-width: 80px; 
            min-height: 55px; 
            box-sizing: border-box;
            text-align: center;
        }
         #current-world-info-group .info-label { 
            font-size: 0.65em; 
            color: #a0aec0; 
            margin-bottom: 4px; 
            display: block; 
            line-height: 1.1;
        }
        #current-world-info-group .info-value { 
            font-size: 0.85em; 
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
        }

        #star-progress-wrapper { 
            grid-column: 2 / 4; 
            display: flex;
            justify-content: center; 
            align-items: center;
            background-color: #374151; 
            border-radius: 8px; 
            padding: 8px 10px; 
            min-height: 55px; 
            box-sizing: border-box;
            text-align: center;
        }

        #star-progress-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px; 
            padding: 0; 
            justify-items: center;
            align-items: center;
            width: 100%; 
            max-width: 260px; 
        }
        .star-svg {
            width: 38px; 
            height: 38px; 
        }

        /* --- INICIO DE CSS CORREGIDO PARA #high-score-display --- */
        #high-score-display {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            gap: 2px;
            width: 100%;
            line-height: 1.2;
            /* font-size: 0.85em; <- Eliminado para usar rem en hijos */
        }
        #high-score-display #hs-main-label { 
            font-size: 0.75rem;  /* Cambiado a rem */
            color: #a0aec0; 
            margin-bottom: 5px;
            display: block; 
            line-height: 1.1;
            text-align: center;
        }
        #hs-values-container { 
            display: flex;
            flex-direction: row;
            align-items: baseline;
            justify-content: center;
            gap: 2px;
            white-space: nowrap;
        }
        #high-score-display .hs-value { 
            color: #f5f5f5; 
            font-family: 'Press Start 2P', sans-serif;
            font-size: 0.65rem; /* Cambiado a rem */
        }
        #high-score-display .hs-label-unit { 
            color: #a0aec0; 
            font-size: 0.5rem; /* Cambiado a rem */
            margin-left: 2px; 
            margin-right: 4px;
        }
        #high-score-display .hs-separator {
            margin-right: 3px;
            color: #a0aec0;
            font-size: 0.6rem; /* Cambiado a rem */
        }
        #high-score-display #hs-skin-value.hs-value {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: baseline;
        }


        canvas {
            background-color: #374151; 
            border: 4px solid #4b5563; 
            display: block; 
            margin: 0 auto 5px auto; 
            max-width: 100%; 
            border-radius: 8px; 
            aspect-ratio: 1 / 1; 
        }

        #mobile-controls {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            margin: 0 auto;
            padding: 0 0px;
            box-sizing: border-box;
            flex-direction: column;
            flex-grow: 1;
        }


@media (hover: hover) and (pointer: fine) {
    #mobile-controls { display: none; }
    #play-area {
        display: grid;
        grid-template-rows: auto 1fr auto;
        flex-grow: 1;
        position: relative;
    }
            #gameCanvas {
                justify-self: center;
                align-self: center;
                margin-bottom: 0;
            }
            #setup-controls { margin-top: 5px; }
        }

        #d-pad-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; 
            grid-template-rows: 1fr 1fr;   
            gap: 8px; 
            width: 100%;
            min-height: 120px; 
            height: 100%; 
        }

        .control-button {
            background-color: #384152; 
            border: 1px solid #2D3748; 
            border-radius: 12px; 
            color: #fff3e1; 
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px; 
            user-select: none; 
            -webkit-user-select: none; 
            -ms-user-select: none; 
            transition: background-color 0.2s ease, transform 0.05s ease-out, filter 0.05s ease-out;
            width: 100%; 
            height: 100%; 
            box-sizing: border-box;
        }
        .d-pad-button-pressed { 
            transform: scale(0.95) translateY(1px);
            filter: brightness(0.8);
        }
        
        #up-button    { 
            grid-column: 2; 
            grid-row: 1; 
        } 
        #left-button  { 
            grid-column: 1; 
            grid-row: 1 / span 2; 
        } 
        #right-button { 
            grid-column: 3; 
            grid-row: 1 / span 2; 
        } 
        #down-button  { 
            grid-column: 2; 
            grid-row: 2; 
        } 

        .control-button:hover { background-color: #4a5568; }
        
        .arrow-svg {
            width: 60%;
            height: 60%;
            fill: currentColor;
        }

        .mode-nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(56,65,82,0.8);
            border: 1px solid #2D3748;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff3e1;
            cursor: pointer;
            z-index: 20;
        }
        #mode-left-button { left: 10px; }
        #mode-right-button { right: 10px; }
        
        #setup-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-top: 5px;
            margin-top: auto;
            margin-bottom: 0px;
            position: relative;
            width: 100%;
        }
        
        .control-row { 
            display: flex;
            align-items: stretch; 
            gap: 8px; 
            width: 100%;
            flex-wrap: wrap; 
            justify-content: center; 
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            justify-content: center;
            background-color: #374151;
            border-radius: 8px;
            padding: 8px 12px;
            flex: 1;
            min-width: 100px;
            box-sizing: border-box;
            transition: background-color 0.2s ease;
            min-height: 50px;
        }

        .control-label-icon-row {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            width: 100%;
            margin-bottom: 6px; 
        }

        .control-label { 
            font-size: 0.7em; 
            color: #a0aec0; 
            display: block; 
            line-height: 1.1;
            text-align: left; 
            flex-grow: 1; 
            margin-right: 8px; 
        }
        
        .setting-info-button {
            background-color: #384152; 
            border: none;
            border-radius: 8px;
            padding: 0; 
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;  
            height: 38px; 
            box-sizing: border-box;
            flex-shrink: 0; 
        }
        .setting-info-button:hover {
            background-color: #4a5568; 
        }
        .setting-info-icon {
            width: 24px;
            height: 24px;
            fill: #f5f5f5;
        }

        .coin-icon {
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }


        #difficultySelector, #worldsSelector, #mazeLevelSelector, #audioToggleSelector, #skinSelector, #foodSelector, #gameModeSelector {
            padding: 4px 6px; 
            font-size: 0.8em; 
            border: none; 
            border-radius: 4px; 
            background-color: transparent; 
            color: #f5f5f5; 
            font-family: 'Press Start 2P', sans-serif;
            text-align: left; 
            width: 100%; 
            height: 38px; 
            box-sizing: border-box;
            -moz-appearance: none; 
            -webkit-appearance: none; 
            appearance: none; 
            margin-top: 4px;
            margin-bottom: 4px;
        }
        
        #difficultySelector option, #worldsSelector option, #mazeLevelSelector option, #audioToggleSelector option, #skinSelector option, #foodSelector option, #gameModeSelector option {
            background-color: #374151;
            color: #f5f5f5;
            font-family: 'Press Start 2P', sans-serif;
            text-align: left; 
        }
        
        #difficultySelector, #worldsSelector, #mazeLevelSelector, #audioToggleSelector, #skinSelector, #foodSelector, #gameModeSelector {
            text-align-last: left;
        }
        select option {
            direction: ltr; 
        }


        #difficultySelector:focus, #worldsSelector:focus, #mazeLevelSelector:focus, #audioToggleSelector:focus, #skinSelector:focus, #foodSelector:focus, #gameModeSelector:focus {
            outline: 1px solid #6ee7b7; 
            box-shadow: none; 
        }
        #difficultySelector:disabled, #worldsSelector:disabled, #mazeLevelSelector:disabled, #audioToggleSelector:disabled, #skinSelector:disabled, #foodSelector:disabled, #gameModeSelector:disabled, #musicVolumeSlider:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .control-group.interactive-mode { 
            background-color: #4A5568; 
        }
        .control-group.interactive-mode:hover {
            background-color: #5A6578; 
            cursor: pointer;
        }
        .control-group.interactive-mode:hover #difficultySelector,
        .control-group.interactive-mode:hover #worldsSelector,
        .control-group.interactive-mode:hover #mazeLevelSelector,
        .control-group.interactive-mode:hover #audioToggleSelector,
        .control-group.interactive-mode:hover #skinSelector,
        .control-group.interactive-mode:hover #foodSelector,
        .control-group.interactive-mode:hover #gameModeSelector,
        .control-group.interactive-mode:hover #musicVolumeSlider {
            cursor: pointer;
        }
        
        #musicVolumeSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px; 
            background: #4B5563; 
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
             margin-top: 4px;
            margin-bottom: 4px;
        }
        #musicVolumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #6ee7b7; 
            cursor: pointer;
            border-radius: 50%;
        }
        #musicVolumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #6ee7b7; 
            cursor: pointer;
            border-radius: 50%;
            border: none; 
        }

        #action-buttons-row {
            justify-content: center; 
            min-height: 65px; 
        }
        .action-button-wrapper { 
            background-color: transparent !important; 
            padding: 0 !important; 
            min-height: auto !important;
            min-width: auto; 
            display: flex; 
        }
        #info-button-wrapper {
            flex-grow: 1;
        }
        #start-button-wrapper {
            flex-grow: 3;
            display: flex;
            gap: 4px;
        }
        #start-button-wrapper.split #startButton { flex-grow: 2; }
        #start-button-wrapper.split #restartMazeButton { flex-grow: 1; }
        #config-button-wrapper {
            flex-grow: 1;
        }


        #startButton, #restartMazeButton, #configButton, #infoButton {
            padding: 10px 15px;
            font-size: 0.85em;
            color: #f5f5f5;
            border: none;
            border-radius: 8px; 
            cursor: pointer;
            transition: background-color 0.3s ease; 
            width: 100%; 
            height: 65px; 
            font-family: 'Press Start 2P', sans-serif; 
            display: flex; 
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        #startButton {
            background-color: #4CAF50;
        }
        #restartMazeButton {
            background-color: #4CAF50;
            min-width: 65px;
        }
        #configButton, #infoButton {
            background-color: #384152;
            min-width: 65px;
        }

        #startButton:hover, #restartMazeButton:hover { background-color: #45a049; }
        #configButton:hover, #infoButton:hover { background-color: #4a5568; }

        #startButton:disabled, #restartMazeButton:disabled, #configButton:disabled, #infoButton:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
        }
        .restart-svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
        .config-svg, .info-svg { 
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .settings-panel-hidden, .info-panel-hidden, .specific-info-panel-hidden { 
            display: none !important;
        }
        #settings-panel, #info-panel, #specific-info-panel {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background-color: #1F2937;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            z-index: 1001;
            width: 100%;
            max-width: var(--game-max-width);
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 2px solid #4b5563;
            overflow-y: auto;
            opacity: 0; 
            transition: opacity 0.3s ease-out, transform 0.3s ease-out; 
        }
        #settings-panel.panel-visible, 
        #info-panel.panel-visible, 
        #specific-info-panel.panel-visible { 
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

         #specific-info-panel {
            z-index: 1002; 
        }
        .settings-header, .info-header, .specific-info-header { 
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #6ee7b7; 
            margin-bottom: 10px;
        }
        .settings-header h2, .info-header h2, .specific-info-header h2 { 
            font-size: 1.4em; 
            margin: 0;
        }
        #close-settings-button, #close-info-button, #close-specific-info-button { 
            background: none;
            border: none;
            color: #f5f5f5;
            font-size: 2em; 
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        #close-settings-button:hover, #close-info-button:hover, #close-specific-info-button:hover { 
            color: #6ee7b7;
        }
        #settings-panel .control-group { 
            background-color: #374151; 
            min-width: unset; 
            width:100%;
        }

        /* Estilos para el contenido del panel de información */
        #info-panel-content, #specific-info-content {
            line-height: 1.6;
            overflow-y: auto; 
            padding-right: 10px; 
            color: #d1d5db; 
        }
        #info-panel-content h3#main-info-title,
        #info-panel-content h4, 
        #specific-info-content h4 { 
            font-size: 1.1em; 
            color: #6ee7b7; 
            margin-top: 20px; 
            margin-bottom: 10px; 
            text-align: left; 
        }
         #specific-info-content h3 { 
            font-size: 0.85em; 
            color: #f5f5f5; 
            margin-bottom: 12px;
            text-align: center; 
        }
        #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul {
            font-size: 0.85em; 
            margin-bottom: 12px;
            text-align: justify; 
        }
        #info-panel-content ul, #specific-info-content ul {
            list-style-type: disc; 
            list-style-position: inside;
            padding-left: 5px;
        }
        #info-panel-content li, #specific-info-content li {
            margin-bottom: 6px;
        }
        #info-panel-content::-webkit-scrollbar, #specific-info-content::-webkit-scrollbar {
            width: 8px;
        }
        #info-panel-content::-webkit-scrollbar-track, #specific-info-content::-webkit-scrollbar-track {
            background: #2d3748; 
            border-radius: 4px;
        }
        #info-panel-content::-webkit-scrollbar-thumb, #specific-info-content::-webkit-scrollbar-thumb {
            background: #4b5563; 
            border-radius: 4px;
        }
        #info-panel-content::-webkit-scrollbar-thumb:hover, #specific-info-content::-webkit-scrollbar-thumb:hover {
            background: #6ee7b7; 
        }


        @media screen and (max-width: 600px) {
            /* --- INICIO DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */
            /* Ya no necesitamos reducir el font-size base del contenedor #high-score-display */
            
            #high-score-display #hs-main-label { font-size: 0.7rem; }
            #hs-values-container { gap: 3px; } 
            #high-score-display .hs-value { font-size: 0.7rem; }
            #high-score-display .hs-label-unit { font-size: 0.45rem; }
            #high-score-display .hs-separator { font-size: 0.55rem; }
            #high-score-display #hs-skin-value.hs-value { max-width: 85px; }
            /* --- FIN DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */


            #top-info-bar .info-group { min-height: 50px; padding: 6px; min-width: 70px;}
            #top-info-bar .info-label { font-size: 0.6em; }
            #top-info-bar .info-value { font-size: 0.8em; }

            #title-panel { min-height: 50px; padding: 6px; }

            #current-world-info-group { min-height: 50px; padding: 6px; min-width: 70px;}
            #current-world-info-group .info-label { font-size: 0.6em; }
            #current-world-info-group .info-value { font-size: 0.8em; }
            #star-progress-wrapper { min-height: 50px; padding: 6px;}
            .star-svg { width: 30px; height: 30px; } 
            #star-progress-container { max-width: 200px; gap: 10px;} 


            #d-pad-container {
                min-height: 110px; 
                gap: 6px;
            }
            .arrow-svg { width: 55%; height: 55%; } 
            
             #startButton, #restartMazeButton, #configButton, #infoButton {
                 font-size: 0.75em;
                 height: 55px;
            }
            #restartMazeButton, #configButton, #infoButton {
                min-width: 55px;
            }

            #settings-panel, #info-panel, #specific-info-panel { 
                width: calc(100% - 20px); 
                padding: 20px; 
            }
            .settings-header h2, .info-header h2, .specific-info-header h2 { 
                font-size: 1.1em;
            }
             #settings-panel .control-group {
                min-height: 50px;
                justify-content: center;
                padding-top: 6px;
                padding-bottom: 6px;
            }
             #settings-panel #difficultySelector,
             #settings-panel #worldsSelector,
             #settings-panel #mazeLevelSelector,
             #settings-panel #audioToggleSelector,
             #settings-panel #skinSelector,
             #settings-panel #foodSelector,
             #settings-panel #gameModeSelector,
             #settings-panel #musicVolumeSlider {
                font-size: 0.7em;
                margin-top: 2px;
                margin-bottom: 2px;
             }
             #settings-panel .control-label-icon-row { margin-bottom: 0px; }
             .setting-info-button {
                width: 36px;
                height: 32px;
             }
             .setting-info-icon {
                width: 25px;
                height: 25px;
             }


             #info-panel-content h3#main-info-title, #specific-info-content h3 { font-size: 1em; } 
             #info-panel-content h4, #specific-info-content h4 { font-size: 1em; } 
             #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul { font-size: 0.8em; } 
        }
         @media screen and (max-width: 400px) { 
            /* --- INICIO DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */
            /* Tampoco necesitamos tocar el font-size del contenedor */

            #high-score-display #hs-main-label { font-size: 0.6rem; margin-bottom: 2px;}
            #hs-values-container { gap: 2px; }
            #high-score-display .hs-value { font-size: 0.6rem; }
            #high-score-display .hs-label-unit { font-size: 0.4rem; }
            #high-score-display .hs-separator { font-size: 0.45rem; }
            #high-score-display #hs-skin-value.hs-value { max-width: 70px; }
            /* --- FIN DE MEDIA QUERY CORREGIDA PARA #high-score-display --- */


             #top-info-bar .info-label { font-size: 0.55em; }
            #top-info-bar .info-value { font-size: 0.7em; }
            #top-info-bar .info-group { min-width: 60px;} 

            #current-world-info-group .info-label { font-size: 0.55em; }
            #current-world-info-group .info-value { font-size: 0.7em; }
            #current-world-info-group { min-width: 60px;}
            .star-svg { width: 24px; height: 24px; } 
            #star-progress-container { max-width: 170px; gap: 8px;} 


            #d-pad-container {
                min-height: 100px; 
                gap: 5px;
            }
            .arrow-svg { width: 50%; height: 50%; }

             #startButton, #restartMazeButton, #configButton, #infoButton {
                 font-size: 0.7em;
                 height: 50px;
            }
            #restartMazeButton, #configButton, #infoButton {
                min-width: 50px;
            }
            .config-svg, .info-svg {  
                width: 20px;
                height: 20px;
            }
             #settings-panel, #info-panel, #specific-info-panel {
                padding: 15px;
            }
            #info-panel-content h3#main-info-title, #specific-info-content h3 { font-size: 0.9em; } 
            #info-panel-content h4, #specific-info-content h4 { font-size: 0.9em; }
            #info-panel-content p, #info-panel-content ul, #specific-info-content p, #specific-info-content ul { font-size: 0.75em; }
        }

        @media screen and (min-width: 600px) {
            #settings-panel #difficultySelector,
            #settings-panel #worldsSelector,
            #settings-panel #mazeLevelSelector,
            #settings-panel #audioToggleSelector,
            #settings-panel #skinSelector,
            #settings-panel #foodSelector,
            #settings-panel #gameModeSelector {
                height: 30px;
                margin-top: 2px;
                margin-bottom: 2px;
            }
        }

        @media screen and (min-width: 800px) {
            #splash-content { padding: 0px 0; }
            #splash-top-image { max-height: 50vh; }
            #splash-start-button {
                max-height: 20vh;
            }
            #splash-bottom-image {
                max-height: 100vh;
                padding-top: 30px;
                padding-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="splash-screen">
        <div id="splash-content">
            <img id="splash-top-image" src="https://i.imgur.com/tWVwXbv.png" alt="Logotipo superior del splash" onerror="this.src='https://placehold.co/600x200/02030D/FFFFFF?text=Splash+Top+Error'; console.error('Error loading splash-top-image');">
            <img id="splash-start-button" src="https://i.imgur.com/HqNpn3w.png" alt="Botón de iniciar juego" onerror="this.src='https://placehold.co/300x100/02030D/FFFFFF?text=Start+Error'; console.error('Error loading splash-start-button');">
            <img id="splash-bottom-image" src="https://i.imgur.com/YJ1xHZO.png" alt="Imagen inferior del splash" onerror="this.src='https://placehold.co/600x150/02030D/FFFFFF?text=Splash+Bottom+Error'; console.error('Error loading splash-bottom-image');">
        </div>
    </div>

    <div class="game-container hidden">
        <div id="title-panel" class="hidden"><h2>Snake Mobile</h2></div>
        <div id="progress-panel" class="hidden">
            <div id="current-world-info-group">
                <span id="progress-panel-left-label" class="info-label">Nivel:</span> <span id="progress-panel-left-value" class="info-value">1</span> </div>
            <div id="star-progress-wrapper">
                 <div id="star-progress-container" class="hidden">
                 </div>
                 <div id="high-score-display" class="hidden">
                    <span id="hs-main-label" class="info-label">Máxima puntuación</span>
                    <div id="hs-values-container">
                        <span id="hs-score-value" class="hs-value">-</span>
                        <span class="hs-label-unit">Puntos</span>
                        <span class="hs-separator hs-value">|</span>
                        <span id="hs-length-value" class="hs-value">-</span>
                        <span id="hs-secondary-unit" class="hs-label-unit">Long</span>
                        <span class="hs-separator hs-value">|</span>
                        <span id="hs-skin-value" class="hs-value">-</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="play-area">

        <div id="top-info-bar">
            <div class="info-group">
                <span class="info-label">Monedas:</span>
                <div class="flex items-center justify-center">
                    <svg class="coin-icon" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="9" fill="#FCD34D" stroke="#D97706" stroke-width="2" />
                    </svg>
                    <span id="coinValue" class="info-value">0</span>
                </div>
            </div>
            <div class="info-group">
                <span class="info-label">Puntos:</span>
                <div class="flex items-center justify-center">
                    <span id="scoreValue" class="info-value">0</span>
                    <span id="target-score-divider" class="info-value mx-1 hidden">/</span>
                    <span id="targetScoreValue" class="info-value hidden">0</span>
                </div>
            </div>
            <div class="info-group">
                <span id="timeLengthLabel" class="info-label">Tiempo:</span>
                <span id="timeLengthValue" class="info-value">60</span>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        <button id="mode-left-button" class="mode-nav-button hidden" aria-label="Modo anterior">
            <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M15.41 7.41L10.83 12l4.58 4.59L14 18l-6-6 6-6z"/></svg>
        </button>
        <button id="mode-right-button" class="mode-nav-button hidden" aria-label="Modo siguiente">
            <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
        </button>

        <div id="setup-controls"> 
            <div id="settings-panel" class="settings-panel-hidden">
                <div class="settings-header">
                    <h2>Configuración</h2>
                    <button id="close-settings-button" aria-label="Cerrar configuración">&times;</button>
                </div>
                <div class="control-group" id="game-mode-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="gameModeSelector">Tipo de Juego:</label>
                        <button class="setting-info-button" data-setting="gameMode" aria-label="Información sobre tipo de juego">
                            <svg class="setting-info-icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <select id="gameModeSelector">
                        <option value="" disabled hidden selected>Sin seleccionar</option>
                        <option value="levels">Modo Aventura</option>
                        <option value="freeMode">Modo Libre</option>
                        <option value="classification">Modo Clasificación</option>
                        <option value="maze">Modo Laberinto</option>
                    </select>
                </div>
                <div class="control-group" id="difficulty-control-group">
                     <div class="control-label-icon-row">
                        <label class="control-label" id="difficulty-label" for="difficultySelector">Dificultad:</label>
                        <button class="setting-info-button" data-setting="difficulty" aria-label="Información sobre dificultad/mundo">
                            <svg class="setting-info-icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <select id="difficultySelector">
                        <option value="principiante" selected>Principiante</option>
                        <option value="explorador">Explorador</option>
                        <option value="veterano">Veterano</option>
                        <option value="legendario">Legendario</option>
                    </select>
                    <select id="worldsSelector" class="hidden">
                    </select>
                    <select id="mazeLevelSelector" class="hidden">
                    </select>
                </div>
                <div class="control-group" id="skin-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="skinSelector">Jugador:</label>
                        <button class="setting-info-button" data-setting="skin" aria-label="Información sobre jugadores">
                            <svg class="setting-info-icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <select id="skinSelector">
                        <option value="snake" selected>Snake</option>
                        <option value="rubiSnake">RubiSnake</option>
                        <option value="aitorSnake">AitorSnake</option>
                        <option value="noemiSnake">NoemiSnake</option>
                        <option value="maraSnake">MaraSnake</option>
                        <option value="almuSnake">AlmuSnake</option>
                        <option value="mimiSnake">MimiSnake</option>
                    </select>
                </div>
                <div class="control-group" id="food-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="foodSelector">Comestible:</label>
                        <button class="setting-info-button" data-setting="food" aria-label="Información sobre comestibles">
                            <svg class="setting-info-icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <select id="foodSelector">
                        <option value="apple" selected>Manzana</option>
                        <option value="croqueta">Croqueta</option>
                        <option value="aguacate">Aguacate</option>
                        <option value="sushi">Sushi</option>
                        <option value="lotus">Lotus</option>
                        <option value="cerveza">Cerveza</option>
                        <option value="pan">Pan</option>
                        <option value="oreo">Oreo</option>
                    </select>
                </div>
                <div class="control-group" id="audio-control-group">
                    <div class="control-label-icon-row">
                        <label class="control-label" for="audioToggleSelector">Audio General:</label>
                        <button class="setting-info-button" data-setting="audioGeneral" aria-label="Información sobre audio general">
                            <svg class="setting-info-icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <select id="audioToggleSelector">
                        <option value="all" selected>Activado (Música y FX)</option> 
                        <option value="sfx_only">Sólo SFX</option> 
                        <option value="off">Desactivado</option> 
                    </select>
                </div>
                <div class="control-group" id="music-volume-control-group"> 
                    <div class="control-label-icon-row">
                        <label class="control-label" for="musicVolumeSlider">Volumen Música: <span id="musicVolumeValue">50</span>%</label>
                         <button class="setting-info-button" data-setting="musicVolume" aria-label="Información sobre volumen de música">
                            <svg class="setting-info-icon" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <input type="range" id="musicVolumeSlider" min="0" max="100" value="50">
                </div>
            </div>
            
            <div id="info-panel" class="info-panel-hidden">
                <div class="info-header">
                    <h2>Información</h2> 
                    <button id="close-info-button" aria-label="Cerrar información">&times;</button>
                </div>
                <div id="info-panel-content">
                    <h3 id="main-info-title">Snake Mobile</h3>
                    <p>¡Prepárate para la clásica diversión de la serpiente con un toque moderno y desafiante! Guía a tu serpiente para que devore la comida, crezca lo más posible y acumule puntos. ¡Pero cuidado! No choques contra los bordes del escenario ni contra tu propio cuerpo o la partida terminará. ¡No te rindas! Cada partida es una nueva oportunidad para superar tu récord.</p>
                    
                    <h4>Cómo Jugar</h4>
                    <p>Usa los controles en pantalla (o las teclas de flecha en escritorio) para dirigir a la serpiente. Come la comida que aparece para crecer y sumar puntos.</p>
                    <ul>
                        <li><strong>Puntos:</strong> Aumentan 10 puntos con cada comida.</li>
                        <li><strong>Racha:</strong> Consigue comida consecutivamente sin fallar para multiplicar tus puntos. La racha máxima es de x5</li>
                        <li><strong>Tiempo:</strong> En el Modo Aventura, dispones de un máximo de 60 segundos para completar cada nivel. En el Modo libre tienes tiempo ilimitado.</li>
                        <li><strong>Longitud:</strong> Indica la longitud de tu serpiente, en el Modo libre servirá para desempatar puntuaciones idénticas.</li>
                    </ul>

                    <h4>Más información</h4>
                    <p>Para más detalles sobre cada tipo de juego u opciones de configuración o personalización, accede al menú de ajustes y pulsa sobre el icono de información del elemento sobre el que te interese obtener más información.</p>
                    <p style="text-align: center; margin-top: 20px;"><strong>¡Diviértete y que crezca la serpiente!</strong></p>
                </div>
            </div>

            <div id="specific-info-panel" class="specific-info-panel-hidden">
                <div class="specific-info-header">
                    <h2 id="specific-info-title">Detalle del Ajuste</h2>
                    <button id="close-specific-info-button" aria-label="Cerrar detalle">&times;</button>
                </div>
                <div id="specific-info-content">
                 </div>
            </div>
            
            <div class="control-row" id="action-buttons-row">
                <div class="action-button-wrapper" id="info-button-wrapper">
                    <button id="infoButton" aria-label="Información">
                        <svg class="info-svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 15c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1zm1-8h-2V7h2v2z"/>
                        </svg>
                    </button>
                </div>
                <div class="action-button-wrapper" id="start-button-wrapper">
                    <button id="startButton">Empezar</button>
                    <button id="restartMazeButton" class="hidden" aria-label="Reiniciar">
                        <svg class="restart-svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 4V1L8 5l4 4V6a6 6 0 11-6 6H4a8 8 0 108-8z" />
                        </svg>
                    </button>
                </div>
                <div class="action-button-wrapper" id="config-button-wrapper">
                    <button id="configButton" aria-label="Configuración">
                        <svg class="config-svg" viewBox="0 0 24 24" fill="currentColor"> <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.25 C14.34,2.09,14.19,2,14,2h-4C9.81,2,9.66,2.09,9.6,2.25L9.22,4.65C8.63,4.89,8.1,5.21,7.6,5.59L5.22,4.63 C4.99,4.56,4.74,4.62,4.62,4.83L2.71,8.15c-0.11,0.2-0.06,0.47,0.12,0.61l2.03,1.58C4.8,10.69,4.78,11,4.78,11.31 c0,0.32,0.02,0.64,0.07,0.95l-2.03,1.58c-0.18,0.14-0.23-0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22 l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.38,2.41c0.05,0.16,0.2,0.25,0.39,0.25h4c0.19,0,0.34-0.09,0.39-0.25l0.38-2.41 c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96c0.22,0.08,0.47,0.02,0.59-0.22l1.92-3.32c0.12-0.2,0.07-0.47-0.12-0.61 L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        </div>
        
        <div id="mobile-controls">
            <div id="d-pad-container">
                <button id="up-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
                </button>
                <button id="left-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M15.41 7.41L10.83 12l4.58 4.59L14 18l-6-6 6-6z"/></svg>
                </button>
                <button id="right-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                </button>
                <button id="down-button" class="control-button">
                    <svg class="arrow-svg" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </button>
            </div>
        </div>

        </div>

    <script>
        // Helper function to adjust hex color by a percentage (lighten)
        function adjustColor(hex, percent) {
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);

            // Add white (lighten)
            r = Math.round(r + (255 - r) * percent);
            g = Math.round(g + (255 - g) * percent);
            b = Math.round(b + (255 - b) * percent);

            r = Math.min(255, Math.max(0, r));
            g = Math.min(255, Math.max(0, g));
            b = Math.min(255, Math.max(0, b));

            const toHex = (c) => {
                const hexVal = c.toString(16);
                return hexVal.length === 1 ? "0" + hexVal : hexVal;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // Draws an image tinted with a given color onto the main context
        function drawImageWithTint(ctx, img, x, y, w, h, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tctx = tempCanvas.getContext('2d');
            tctx.drawImage(img, 0, 0, w, h);
            tctx.globalCompositeOperation = 'source-atop';
            tctx.fillStyle = color;
            tctx.fillRect(0, 0, w, h);
            tctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(tempCanvas, x, y);
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Selección de elementos del DOM
        const splashScreen = document.getElementById("splash-screen"); 
        const canvasEl = document.getElementById("gameCanvas"); 
        let ctx; 
        const gameContainer = document.querySelector('.game-container'); 
        const coinValueDisplay = document.getElementById("coinValue");
        const scoreValueDisplay = document.getElementById("scoreValue");
        const targetScoreDivider = document.getElementById("target-score-divider");
        const targetScoreValueDisplay = document.getElementById("targetScoreValue");
        const timeLengthLabelEl = document.getElementById("timeLengthLabel");
        const timeLengthValueEl = document.getElementById("timeLengthValue");
        const startButton = document.getElementById("startButton");
        const restartMazeButton = document.getElementById("restartMazeButton");
        const startButtonWrapperEl = document.getElementById("start-button-wrapper");
        const difficultySelector = document.getElementById("difficultySelector");
        const worldsSelector = document.getElementById("worldsSelector");
        const mazeLevelSelector = document.getElementById("mazeLevelSelector");
        const difficultyLabel = document.getElementById("difficulty-label"); 
        const audioToggleSelector = document.getElementById("audioToggleSelector");
        const skinSelector = document.getElementById("skinSelector");
        const foodSelector = document.getElementById("foodSelector");
        const gameModeSelector = document.getElementById("gameModeSelector");
        const difficultyControlGroup = document.getElementById("difficulty-control-group");
        const audioControlGroup = document.getElementById("audio-control-group");
        const skinControlGroup = document.getElementById("skin-control-group");
        const foodControlGroup = document.getElementById("food-control-group");
        const gameModeControlGroup = document.getElementById("game-mode-control-group");
        const musicVolumeSlider = document.getElementById("musicVolumeSlider");
        const musicVolumeValue = document.getElementById("musicVolumeValue");
        const musicVolumeControlGroup = document.getElementById("music-volume-control-group");
        
        const progressPanel = document.getElementById("progress-panel");
        const titlePanel = document.getElementById("title-panel"); 
        const progressPanelLeftLabel = document.getElementById("progress-panel-left-label");
        const progressPanelLeftValue = document.getElementById("progress-panel-left-value");
        const starProgressContainer = document.getElementById("star-progress-container"); 
        const highScoreDisplay = document.getElementById("high-score-display");
        const hsScoreValue = document.getElementById("hs-score-value");
        const hsLengthValue = document.getElementById("hs-length-value");
        const hsSecondaryUnit = document.getElementById("hs-secondary-unit");
        // Se obtendrá hsSkinValue dentro de la función displayHighScoreInPanel


        const upButton = document.getElementById("up-button");
        const leftButton = document.getElementById("left-button");
        const downButton = document.getElementById("down-button");
        const rightButton = document.getElementById("right-button");
        const settingsPanel = document.getElementById("settings-panel");
        const configButton = document.getElementById("configButton");
        const closeSettingsButton = document.getElementById("close-settings-button");

        const infoButton = document.getElementById("infoButton");
        const infoPanel = document.getElementById("info-panel");
        const infoPanelContent = document.getElementById("info-panel-content"); 
        const closeInfoButton = document.getElementById("close-info-button");
        const topInfoBar = document.getElementById('top-info-bar');
        const setupControls = document.getElementById('setup-controls');
        const actionButtonsRow = document.getElementById('action-buttons-row');

        const modeLeftButton = document.getElementById("mode-left-button");
        const modeRightButton = document.getElementById("mode-right-button");

        // New DOM elements for specific info panel
        const specificInfoPanel = document.getElementById("specific-info-panel");
        const specificInfoTitle = document.getElementById("specific-info-title");
        const specificInfoContent = document.getElementById("specific-info-content");
        const closeSpecificInfoButton = document.getElementById("close-specific-info-button");


        // --- INICIO: Declaración de Objetos Image ---
        const classicSnakeHeadLeftImg = new Image(); 
        const classicSnakeHeadDownImg = new Image(); 
        const classicFoodImg = new Image();
        const snakeBodyTexture = new Image(); 

        const rubiSnakeHeadUpDownImg = new Image();
        const rubiSnakeHeadLeftImg = new Image();
        const rubiSnakeFoodImg = new Image();

        const aitorSnakeHeadUpDownImg = new Image();
        const aitorSnakeHeadLeftImg = new Image();
        const aitorSnakeFoodImg = new Image();

        const noemiSnakeHeadUpDownImg = new Image();
        const noemiSnakeHeadLeftImg = new Image();
        const noemiSnakeFoodImg = new Image();

        const maraSnakeHeadUpDownImg = new Image();
        const maraSnakeHeadLeftImg = new Image();
        const maraSnakeFoodImg = new Image();

        const almuSnakeHeadUpDownImg = new Image(); 
        const almuSnakeHeadLeftImg = new Image();   
        const almuSnakeFoodImg = new Image();   

        const mimiSnakeHeadUpDownImg = new Image();
        const mimiSnakeHeadLeftImg = new Image();
        const mimiSnakeFoodImg = new Image();

        const oreoFoodImg = new Image();
        const obstacleImg = new Image();
        const lightningYellowImg = new Image();
        const lightningRedImg = new Image();

        const mazeModeCoverImg = new Image();
        const mazeFailImg = new Image();
        const mazePartialImg = new Image();
        const mazePerfectImg = new Image();
        const mazeCompleteImg = new Image();
        const mazeFinalImg = new Image();
        const mazeAllStarsImg = new Image();
        const timeoutImg = new Image();

        const worldCoverImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const worldCompleteImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const levelCompleteImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const defeatImages = {
            1: new Image(),
            2: new Image(),
            3: new Image(),
            4: new Image(),
            5: new Image(),
            6: new Image(),
            7: new Image(),
            8: new Image(),
            9: new Image(),
            10: new Image()
        };
        const freeModeCoverImg = new Image();
        const classificationModeCoverImg = new Image();
        const modeSelectIntroImg = new Image();
        const modeSelectLevelsImg = new Image();
        const modeSelectFreeImg = new Image();
        const modeSelectClassificationImg = new Image();
        const modeSelectMazeImg = new Image();

        const worldImagesConfig = {
            1: { cover: 'https://i.imgur.com/XuoZro6.png', complete: 'https://i.imgur.com/pw2ebzf.png', level: 'https://i.imgur.com/gijG9ec.png', defeat: 'https://i.imgur.com/FZTIteF.png' },
            2: { cover: 'https://i.imgur.com/RUDshhv.png', complete: 'https://i.imgur.com/mkxGkJA.png', level: 'https://i.imgur.com/aXJoj0F.png', defeat: 'https://i.imgur.com/4DPMHU2.png' },
            3: { cover: 'https://i.imgur.com/fMBXP4Z.png', complete: 'https://i.imgur.com/aYOQ8Gx.png', level: 'https://i.imgur.com/WUfSzpY.png', defeat: 'https://i.imgur.com/0OmpfWR.png' },
            4: { cover: 'https://i.imgur.com/3bpQJ2c.png', complete: 'https://i.imgur.com/TRmh4s7.png', level: 'https://i.imgur.com/2ZlgclU.png', defeat: 'https://i.imgur.com/Y4kPsNM.png' },
            5: { cover: 'https://i.imgur.com/EYXaoSC.png', complete: 'https://i.imgur.com/R79ud6T.png', level: 'https://i.imgur.com/YULiGZW.png', defeat: 'https://i.imgur.com/yiH7BqX.png' },
            6: { cover: 'https://i.imgur.com/TUUOl01.png', complete: 'https://i.imgur.com/NXcBoXQ.png', level: 'https://i.imgur.com/bUUIGGt.png', defeat: 'https://i.imgur.com/iYpiKB7.png' },
            7: { cover: 'https://i.imgur.com/vEqjfil.png', complete: 'https://i.imgur.com/paNousf.png', level: 'https://i.imgur.com/GniQn3h.png', defeat: 'https://i.imgur.com/3FilGNV.png' },
            8: { cover: 'https://i.imgur.com/e1PtokJ.png', complete: 'https://i.imgur.com/TI5ptAd.png', level: 'https://i.imgur.com/YtiDSF1.png', defeat: 'https://i.imgur.com/ADe82lc.png' },
            9: { cover: 'https://i.imgur.com/DNGzDhl.png', complete: 'https://i.imgur.com/PlPwmLh.png', level: 'https://i.imgur.com/IY7T8Jm.png', defeat: 'https://i.imgur.com/6Bc4w92.png' },
            10: { cover: 'https://i.imgur.com/g3uQW4f.png', complete: 'https://i.imgur.com/rFUKAbD.png', level: 'https://i.imgur.com/7iK51vy.png', defeat: 'https://i.imgur.com/dd6Zkda.png' }
        };

        let worldImagesLoaded = 0;
        const totalWorldImagesToLoad = Object.keys(worldImagesConfig).length * 4 + 10;
        // --- FIN: Declaración de Objetos Image ---

        // --- Música de fondo y SFX ---
        let generalBackgroundMusic; 
        let inGameBackgroundMusic;  
        const generalBackgroundMusicURL = 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/1ffc16f7db7280cf31d5e7209c5c23e7d533d1e3/Instrumental%20fondo%20-%20Recuerdos%20Pixelados%20(1).mp3';
        const inGameBackgroundMusicURL = 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Valle%20del%20despertar%20-%20Serpiente%20de%20Ne%C3%B3n.mp3';

        const WORLD_MUSIC_URLS = {
            1: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Valle%20del%20despertar%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            2: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Cueva%20del%20crecimiento%20-%20La%20Serpiente%20de%20Ne%C3%B3n.mp3',
            3: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Templo%20de%20la%20Agilidad-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            4: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Hambre%20Voraz%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            5: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Doble%20o%20nada%2C%20comestibles%20dorados%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            6: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Racha%20demoledora%20-%20La%20serpiente%20de%20ne%C3%B3n.mp3',
            7: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Bosque%20de%20los%20enga%C3%B1os%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            8: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Jard%C3%ADn%20de%20los%20Peligros%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            9: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Lago%20del%20Reflejo%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            10:'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/4d5668697896de0068c5e942daf03042543721b5/Final%20Inesperado%20-%20serpiente%20de%20ne%C3%B3n.mp3'
        };

        const MODE_MUSIC_URLS = {
            maze: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/9705ce5b286f197add7dd7f2bb767edf09594ef9/Serpiente%20de%20Ne%C3%B3n%20(3).mp3',
            freeMode: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/bc07b0e83b7df448cb82a9a6b8a5ae4196d06758/Modo%20libre%20-%20Serpiente%20de%20Ne%C3%B3n.mp3',
            classification: 'https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/ecfea23c17b11d743d5bade6b5ef8e025ea1fff6/Modo%20clasificaci%C3%B3n%20-%20Serpiente%20de%20Ne%C3%B3n.mp3'
        };
        let synthSplashStart; 
        const MAX_ACTUAL_SLIDER_MAPPED_VOLUME = 0.2; 


        // Configuración del juego
        let GRID_SIZE = 20;
        const TILE_COUNT = 20;
        let tileCountX = TILE_COUNT;
        let tileCountY = TILE_COUNT;
        const DEFAULT_INITIAL_SNAKE_LENGTH = 3; // Used for free mode
        let initialSnakeLength = DEFAULT_INITIAL_SNAKE_LENGTH;
        const MAX_STREAK = 5;
        const STREAK_ANIMATION_DURATION = 1000; // ms that streak value is shown above head
        
        // Mapping for difficulty display names
        const DIFFICULTY_DISPLAY_NAMES = {
            principiante: "Principiante",
            explorador: "Explorador",
            veterano: "Veterano",
            legendario: "Legendario"
        };

        // Mapping para nombres de jugadores en el ranking
        const SKIN_DISPLAY_NAMES = {
            snake: "Snake",
            Snake: "Snake",
            rubiSnake: "RubiSnake",
            aitorSnake: "AitorSnake",
            noemiSnake: "NoemiSnake",
            maraSnake: "MaraSnake",
            almuSnake: "AlmuSnake",
            mimiSnake: "MimiSnake"
        };

        // Nombres descriptivos de cada mundo
        const WORLD_DISPLAY_NAMES = [
            "Valle del Despertar",
            "Cueva del Crecimiento",
            "Templo de la Agilidad",
            "Hambre Voraz",
            "Doble o nada",
            "Racha demoledora",
            "Bosque de los Engaños",
            "Jardín de los Peligros",
            "Lago del Reflejo",
            "Final Inesperado"
        ];


        // --- LEVELS MODE CONFIG ---
        const LEVELS_PER_WORLD = 5;
        const TOTAL_WORLDS = 10;
        const LEVEL_TIME_LIMIT = 60000;
        const TARGET_SCORES_LEVELS = [
            // World 1
            25, 50, 100, 150, 200,
            // World 2
            25, 50, 100, 150, 200,
            // World 3
            50, 100, 150, 200, 250,
            // World 4
            50, 100, 150, 200, 250,
            // World 5
            100, 150, 200, 250, 300,
            // World 6
            200, 300, 400, 500, 600,
            // World 7
            200, 300, 400, 500, 600,
            // World 8
            300, 400, 500, 600, 700,
            // World 9
            300, 400, 500, 600, 700,
            // World 10
            400, 500, 600, 700, 800,
        ];

        // Star thresholds for Maze Mode (puntos objetivo para cada estrella)
        const MAZE_STAR_TARGETS = [25, 50, 100, 150, 200];
        let mazeStarsEarned = 0;

        const MAZE_LEVEL_COUNT = 10;
        let currentMazeLevel = 1;
        let mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
        let mazePreviousStars = 0; // Stars achieved before starting the current run

        const MAZE_LAYOUTS = {
            // Nivel 1 - bloques en las esquinas
            1: [
                { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 },
                { x: 18, y: 0 }, { x: 19, y: 0 }, { x: 19, y: 1 },
                { x: 0, y: 18 }, { x: 0, y: 19 }, { x: 1, y: 19 },
                { x: 19, y: 18 }, { x: 19, y: 19 }, { x: 18, y: 19 }
            ],
            // Nivel 2 - cuatro bloques centrales de 2x2
            2: [
                { x: 5, y: 5 }, { x: 6, y: 5 }, { x: 5, y: 6 }, { x: 6, y: 6 },
                { x: 13, y: 5 }, { x: 14, y: 5 }, { x: 13, y: 6 }, { x: 14, y: 6 },
                { x: 5, y: 13 }, { x: 6, y: 13 }, { x: 5, y: 14 }, { x: 6, y: 14 },
                { x: 13, y: 13 }, { x: 14, y: 13 }, { x: 13, y: 14 }, { x: 14, y: 14 }
            ],
            // Nivel 3 - cruz que divide en cuadrantes
            3: (() => {
                const res = [];
                for (let i = 0; i < 12; i++) res.push({ x: i + 4, y: 10 });
                for (let i = 0; i < 12; i++) res.push({ x: 10, y: i + 4 });
                return res;
            })(),
            // Nivel 4 - dos muros verticales con hueco central
            4: (() => {
                const res = [];
                for (let y = 0; y < 20; y++) { if (y !== 9 && y !== 10) res.push({ x: 6, y }); }
                for (let y = 0; y < 20; y++) { if (y !== 9 && y !== 10) res.push({ x: 13, y }); }
                return res;
            })(),
            // Nivel 5 - rectángulo interior con aperturas en cruz
            5: (() => {
                const res = [];
                for (let i = 0; i < 10; i++) { const x = 5 + i; if (x !== 10) res.push({ x, y: 5 }); }
                for (let i = 0; i < 10; i++) { const x = 5 + i; if (x !== 10) res.push({ x, y: 14 }); }
                for (let i = 0; i < 8; i++) { const y = 6 + i; if (y !== 10) res.push({ x: 5, y }); }
                for (let i = 0; i < 8; i++) { const y = 6 + i; if (y !== 10) res.push({ x: 14, y }); }
                return res;
            })(),
            // Nivel 6 - muro vertical con bordes izquierdo e inferior
            6: (() => {
                const res = [];
                for (let x = 0; x < 20; x++) res.push({ x, y: 19 });
                for (let y = 0; y < 20; y++) res.push({ x: 0, y });
                for (let y = 5; y <= 9; y++) res.push({ x: 10, y });
                for (let y = 11; y <= 15; y++) res.push({ x: 10, y });
                return res;
            })(),
            // Nivel 7 - marco alrededor de los bordes con dos líneas horizontales
            7: (() => {
                const res = [];
                for (let i=0;i<20;i++) { res.push({x:i,y:0}); res.push({x:i,y:19}); }
                for (let i=1;i<19;i++) { res.push({x:0,y:i}); res.push({x:19,y:i}); }
                for (let i=0;i<12;i++) res.push({x:i+4,y:8});
                for (let i=0;i<12;i++) res.push({x:i+4,y:12});
                return res;
            })(),
            // Nivel 8 - líneas horizontales y verticales desplazadas
            8: (() => {
                const res = [];
                for (let y = 0; y <= 9; y++) res.push({ x: 5, y });
                for (let y = 11; y <= 19; y++) res.push({ x: 15, y });
                for (let x = 0; x <= 10; x++) res.push({ x, y: 13 });
                for (let x = 10; x <= 19; x++) res.push({ x, y: 7 });
                return res;
            })(),
            // Nivel 9 - franjas horizontales
            9: (() => {
                const res = [];
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 4 });
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 8 });
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 12 });
                for (let i = 0; i < 14; i++) res.push({ x: i + 3, y: 16 });
                return res;
            })(),
            // Nivel 10 - franjas horizontales con paredes laterales
            10: (() => {
                const res = [];
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 4 });
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 8 });
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 12 });
                for (let i = 0; i < 16; i++) res.push({ x: i + 2, y: 16 });
                for (let y = 0; y < 20; y++) res.push({ x: 0, y });
                for (let y = 0; y < 20; y++) res.push({ x: 19, y });
                return res;
            })()
        };
        const LEVEL_SETTINGS = [
            // World 1 - Valle del Despertar
            [
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 },
                { speed: 200, initialLength: 4, initialLifespan: 0 }
            ],
            // World 2 - Cueva del Crecimiento
            [
                { speed: 190, initialLength: 10, initialLifespan: 0 },
                { speed: 190, initialLength: 15, initialLifespan: 0 },
                { speed: 190, initialLength: 20, initialLifespan: 0 },
                { speed: 190, initialLength: 25, initialLifespan: 0 },
                { speed: 190, initialLength: 30, initialLifespan: 0 }
            ],
            // World 3 - Templo de la Agilidad
            Array(5).fill({ speed: 150, initialLength: 6, initialLifespan: 0 }),
            // World 4 - Hambre Voraz
            [
                { speed: 180, initialLength: 8, initialLifespan: 9500 },
                { speed: 180, initialLength: 8, initialLifespan: 9000 },
                { speed: 180, initialLength: 8, initialLifespan: 8500 },
                { speed: 180, initialLength: 8, initialLifespan: 8000 },
                { speed: 180, initialLength: 8, initialLifespan: 7500 }
            ],
            // World 5 - Doble o nada
            Array(5).fill({ speed: 170, initialLength: 10, initialLifespan: 9500 }),
            // World 6 - Racha demoledora
            Array(5).fill({ speed: 160, initialLength: 12, initialLifespan: 9000 }),
            // World 7 - Bosque de los Engaños
            Array(5).fill({ speed: 150, initialLength: 14, initialLifespan: 8500 }),
            // World 8 - Jardín de los Peligros
            Array(5).fill({ speed: 140, initialLength: 16, initialLifespan: 8000 }),
            // World 9 - Lago del Reflejo
            Array(5).fill({ speed: 130, initialLength: 18, initialLifespan: 7500 }),
            // World 10 - Desafío Final
            [
                { speed: 125, initialLength: 20, initialLifespan: 7000 },
                { speed: 120, initialLength: 25, initialLifespan: 6500 },
                { speed: 115, initialLength: 30, initialLifespan: 6000 },
                { speed: 110, initialLength: 35, initialLifespan: 5500 },
                { speed: 105, initialLength: 40, initialLifespan: 5000 }
            ]
        ];
        let currentWorld = 1;
        let currentLevelInWorld = 1; 
        let maxUnlockedWorld = 1;
        let levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);

        // --- Variables de visualización para UI ---
        let displayWorld = 1;
        let displayLevelInWorld = 1;
        let displayMazeLevel = 1;
        let displayTargetScore = TARGET_SCORES_LEVELS[0];


        // --- Configuración de Jugadores (Skins) ---
        const SKINS = {
            snake: {
                snakeHeadAsset: { 
                    upDown: classicSnakeHeadDownImg, 
                    left: classicSnakeHeadLeftImg   
                }, 
                foodAsset: classicFoodImg, 
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#A8F031',
                bodyStrokeColor: adjustColor('#A8F031', 0.30), 
            },
            rubiSnake: {
                snakeHeadAsset: { 
                    upDown: rubiSnakeHeadUpDownImg, 
                    left: rubiSnakeHeadLeftImg, 
                },
                foodAsset: rubiSnakeFoodImg,
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#E74C3C',
                bodyStrokeColor: adjustColor('#E74C3C', 0.30), 
            },
            aitorSnake: { 
                snakeHeadAsset: {
                    upDown: aitorSnakeHeadUpDownImg, 
                    left: aitorSnakeHeadLeftImg,
                },
                foodAsset: aitorSnakeFoodImg,
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#772CE8', 
                bodyStrokeColor: adjustColor('#772CE8', 0.30), 
            },
            noemiSnake: { 
                snakeHeadAsset: {
                    upDown: noemiSnakeHeadUpDownImg, 
                    left: noemiSnakeHeadLeftImg,
                },
                foodAsset: noemiSnakeFoodImg,
                snakeHeadScale: 2.0, 
                foodScale: 1.5,
                bodyTintColor: '#FFC0EB', 
                bodyStrokeColor: adjustColor('#FFC0EB', 0.30), 
            },
            maraSnake: {
                snakeHeadAsset: {
                    upDown: maraSnakeHeadUpDownImg,
                    left: maraSnakeHeadLeftImg,
                },
                foodAsset: maraSnakeFoodImg,
                snakeHeadScale: 2.0,
                foodScale: 1.5,
                bodyTintColor: '#FCE9BC',
                bodyStrokeColor: adjustColor('#FCE9BC', 0.30),
            },
            almuSnake: { 
                snakeHeadAsset: {
                    upDown: almuSnakeHeadUpDownImg,
                    left: almuSnakeHeadLeftImg,
                },
                foodAsset: almuSnakeFoodImg,
                snakeHeadScale: 2.0,
                foodScale: 1.5,
                bodyTintColor: '#C96B20',
                bodyStrokeColor: adjustColor('#C96B20', 0.30),
            },
            mimiSnake: { 
                snakeHeadAsset: {
                    upDown: mimiSnakeHeadUpDownImg,
                    left: mimiSnakeHeadLeftImg,
                },
                foodAsset: mimiSnakeFoodImg,
                snakeHeadScale: 2.0,
                foodScale: 1.5,
                bodyTintColor: '#FFFFFF',
                bodyStrokeColor: adjustColor('#FFFFFF', 0.30),
            }
        };
        let currentSkin = 'snake';
        // --- Fin Configuración de Jugadores ---

        // --- Configuración de Comestibles ---
        const FOODS = {
            apple: { asset: classicFoodImg, scale: 1.5 },
            cerveza: { asset: rubiSnakeFoodImg, scale: 1.5 },
            croqueta: { asset: aitorSnakeFoodImg, scale: 1.5 },
            aguacate: { asset: noemiSnakeFoodImg, scale: 1.5 },
            sushi: { asset: maraSnakeFoodImg, scale: 1.5 },
            lotus: { asset: almuSnakeFoodImg, scale: 1.5 },
            pan: { asset: mimiSnakeFoodImg, scale: 1.5 },
            oreo: { asset: oreoFoodImg, scale: 1.5 }
        };
        let currentFood = 'apple';
        // --- Fin Configuración de Comestibles ---


        // Estado del juego
        let snake = []; 
        let direction = "right"; 
        let nextDirection = "right"; // Buffer para la siguiente dirección (MANTENIDO DE LA VERSIÓN ANTERIOR)
        let score = 0;
        let totalCoins = 0;
        let gameOver = false;
        let gameOverByTimeout = false;
        let gameIntervalId;
        let gameTimeRemaining;
        let gameTimeElapsed;
        let gameTimerIntervalId;
        let gameMode = ''; // No mode selected initially
        let isNewHighScore = false; // Flag for new high score
        
        let currentFoodItem = {}; 
        const FOOD_SHAPE_FALLBACK = { 
            name: 'Comida', 
            color: '#FF7043', 
            borderColor: '#E64A19', 
        };

        let difficulty = 'principiante';
        let snakeSpeed = 150; 
        let foodTimeRemaining = 0; 
        let foodDisappearTimeoutId; 
        let foodVisualTimerIntervalId;
        let streakMultiplier = 1; 
        let lastWarningSoundSecond = -1; 

        // Game state variables for screen display
        let screenState = {
            showCoverForWorld: 0,
            showLevelCompleteCover: 0,
            showWorldCompleteCover: 0,
            showDefeatCoverForWorld: 0,
            showTimeoutCover: false,
            showFreeModeCover: false,
            showClassificationCover: false,
            showMazeCover: false,
            mazeResultType: '',
            gameActuallyStarted: false
        };
        let modeSelectIndex = 0;
        const MODE_SELECT_ORDER = ['intro', 'levels', 'freeMode', 'classification', 'maze'];
        let showModeSelect = false;
        let introOptionAvailable = true; // controls visibility of the intro slide
        const MODE_TRANSITION_DURATION = 300; // ms
        let modeTransitionStart = null;
        let modeTransitionDir = 0;
        let modeTransitionFrom = 0;

        const DIFFICULTY_SETTINGS = {
            principiante: {
                speed: 180,
                initialLifespan: 0,
                initialLength: 4,
                goldenFoodChance: 0.15,
                goldenFoodLifespan: 4000
            },
            explorador:   {
                speed: 160,
                initialLifespan: 8000,
                initialLength: 6,
                goldenFoodChance: 0.15,
                goldenFoodLifespan: 3500,
                lightningSpawnRange: [6000, 10000],
                lightningLifespan: 5000,
                yellowLightningChance: 0.75,
                streakReduction: 800
            },
            veterano:     {
                speed: 140,
                initialLifespan: 7500,
                initialLength: 10,
                goldenFoodChance: 0.1,
                goldenFoodLifespan: 4000,
                lightningSpawnRange: [6000, 10000],
                lightningLifespan: 5000,
                yellowLightningChance: 0.75,
                streakReduction: 800,
                falseFoodSpawnRange: [6000, 10000],
                falseFoodLifespan: 5000,
                mirrorSpawnRange: [6000, 10000],
                mirrorLifespan: 5000,
                mirrorEffectDuration: 3000,
                obstacleCount: 5
            },
            legendario:   {
                speed: 120,
                initialLifespan: 7000,
                initialLength: 15,
                goldenFoodChance: 0.1,
                goldenFoodLifespan: 4000,
                lightningSpawnRange: [6000, 10000],
                lightningLifespan: 5000,
                yellowLightningChance: 0.75,
                streakReduction: 800,
                falseFoodSpawnRange: [5000, 7000],
                falseFoodLifespan: 6000,
                mirrorSpawnRange: [5000, 7000],
                mirrorLifespan: 6000,
                mirrorEffectDuration: 3000,
                obstacleCount: 10
            }
        };
        const CLASSIFICATION_RANKS = {
            principiante: 1,
            explorador: 2,
            veterano: 3,
            legendario: 4
        };
        const MIN_FOOD_LIFESPAN = 4000;
        const FOOD_WARNING_TIME = 3000; 
        const POINTS_PER_FOOD = 10;
        const POINTS_PER_COIN = 10;
        const MAX_HIGH_SCORES = 10; 
        const FALSE_FOOD_LIFESPAN = 5000;
        const FALSE_FOOD_SPAWN_RANGES_WORLD4 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const FALSE_FOOD_SPAWN_RANGE_WORLD5 = [7000, 12000];
        const OBSTACLE_COUNTS_WORLD5 = [3, 5, 8, 11, 15];
        const OBSTACLE_COUNT_WORLD6 = 5;
        const GOLDEN_FOOD_CHANCE = 0.15;
        const GOLDEN_FOOD_LIFESPANS_WORLD5 = [4000, 3500, 3000, 2500, 2000];
        const GOLDEN_FOOD_LIFESPAN_CLASSIF_RANK1 = 4500;
        const FALSE_FOOD_SPAWN_RANGES_WORLD8 = [
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000]
        ];
        const OBSTACLE_COUNTS_WORLD8 = [5, 8, 11, 14, 17];
        const LIGHTNING_SPAWN_RANGES_WORLD6 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const LIGHTNING_SPAWN_RANGE_WORLD4 = [4000, 7000];
        const LIGHTNING_SPAWN_RANGE_WORLD7 = [7000, 12000];
        const LIGHTNING_SPAWN_RANGES_WORLD8 = [
            [7000, 9000],
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000]
        ];
        const MIRROR_SPAWN_RANGES_WORLD7 = [
            [5000, 7000],
            [4000, 6000],
            [3000, 5000],
            [2000, 4000],
            [1000, 3000]
        ];
        const MIRROR_SPAWN_RANGES_WORLD8 = [
            [7000, 9000],
            [6000, 8000],
            [5000, 7000],
            [4000, 6000],
            [3000, 5000]
        ];
        const DEFAULT_MIRROR_EFFECT_DURATION = 3000;
        let MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
        const LIGHTNING_LIFESPAN = 5000;
        const SPEED_BOOST_DURATION = 3000;
        let obstacles = [];
        let snakeSpawnRow = 0;
        let falseFoodItems = [];
        let falseFoodSpawnTimeoutId;
        let lightningItems = [];
        let lightningSpawnTimeoutId;
        let mirrorItems = [];
        let mirrorSpawnTimeoutId;
        let controlsInverted = false;
        let mirrorEffect = { active: false, startTime: 0 };
        
        function updateMirrorEffect() {
            if (!mirrorEffect.active) return;
            let duration = MIRROR_EFFECT_DURATION;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (typeof cfg.mirrorEffectDuration === 'number') {
                    duration = cfg.mirrorEffectDuration;
                }
            }
            const elapsed = Date.now() - mirrorEffect.startTime;
            if (elapsed >= duration) {
                mirrorEffect.active = false;
                controlsInverted = false;
            }
        }
        let speedBoost = { active: false, color: '', change: 0, startTime: 0 };


        // Nuevas variables para el estado del audio
        let isMusicEnabled = true; 
        let areSfxEnabled = true; 
        let synthsInitialized = false; // Flag to track synth initialization
        let synthEat, synthEatNoise, synthBadEat, synthWarning, synthTimeout, synthGameOver, synthStartGame, synthWin, synthCoinNoise, synthCoinChime;
        let synthModeSwitch, synthModeSelect;


        // --- Configuración para la animación de parpadeo del high score ---
        let blinkAnimation = {
            active: false,
            startTime: 0,
            rowIndex: -1,
            duration: 2000,
            interval: 250
        };

        // Animation data for streak multiplier display
        let streakAnimation = {
            active: false,
            value: '',
            color: '',
            startTime: 0
        };

        function startStreakAnimation(multiplier) {
            const text = `x${Number.isInteger(multiplier) ? multiplier : multiplier.toFixed(1)}`;
            let color = '#FF0000';
            if (multiplier > 2 && multiplier <= 3.5) {
                color = '#FFFF00';
            } else if (multiplier > 3.5 && multiplier <= 4.5) {
                color = '#00FF00';
            } else if (multiplier > 4.5) {
                color = '#EE82EE';
            }
            streakAnimation = { active: true, value: text, color, startTime: Date.now() };
        }

        function drawStreakAnimation(head) {
            if (!streakAnimation.active) return;
            const elapsed = Date.now() - streakAnimation.startTime;
            if (elapsed >= STREAK_ANIMATION_DURATION) {
                streakAnimation.active = false;
                return;
            }
            const alpha = 1 - (elapsed / STREAK_ANIMATION_DURATION);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = streakAnimation.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = `${Math.floor(GRID_SIZE * 0.5)}px 'Press Start 2P'`;
            const x = head.x * GRID_SIZE + GRID_SIZE / 2;
            const y = head.y * GRID_SIZE - 6;
            ctx.fillText(streakAnimation.value, x, y);
            ctx.restore();
        }
        
        // --- Funciones de Carga y Aplicación de Jugadores ---
        function loadWorldImages() {
            Object.entries(worldImagesConfig).forEach(([id, cfg]) => {
                worldCoverImages[id].src = cfg.cover;
                worldCompleteImages[id].src = cfg.complete;
                levelCompleteImages[id].src = cfg.level;
                defeatImages[id].src = cfg.defeat;
            });

            freeModeCoverImg.src = 'https://i.imgur.com/6cMWnrC.png';
            classificationModeCoverImg.src = 'https://i.imgur.com/t5n37Mw.png';

            mazeModeCoverImg.src = 'https://i.imgur.com/WY3lrHv.png';
            mazeFailImg.src = 'https://i.imgur.com/3snKeSJ.png';
            mazePartialImg.src = 'https://i.imgur.com/04vASxK.png';
            mazePerfectImg.src = 'https://i.imgur.com/YKVlhix.png';
            mazeCompleteImg.src = 'https://i.imgur.com/0s9b6JB.png';
            mazeFinalImg.src = 'https://i.imgur.com/dga8Z3q.png';
            mazeAllStarsImg.src = 'https://i.imgur.com/grMD2kr.png';
            timeoutImg.src = 'https://i.imgur.com/uEjzFbY.png';


            const allWorldImages = [
                ...Object.values(worldCoverImages),
                ...Object.values(worldCompleteImages),
                ...Object.values(levelCompleteImages),
                ...Object.values(defeatImages),
                freeModeCoverImg, classificationModeCoverImg, mazeModeCoverImg,
                mazeFailImg, mazePartialImg, mazePerfectImg, mazeCompleteImg,
                mazeFinalImg, mazeAllStarsImg, timeoutImg
            ];

            allWorldImages.forEach(img => {
                img.onload = () => {
                    worldImagesLoaded++;
                    if (worldImagesLoaded === totalWorldImagesToLoad) {
                        console.log("Todas las imágenes de mundo, completado de mundo, completado de nivel, derrota, modo libre y modo clasificación cargadas.");
                        if (ctx && (
                            (gameMode === 'levels' && (screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0) && !screenState.gameActuallyStarted) || 
                            screenState.showWorldCompleteCover > 0 ||
                            (gameMode === 'freeMode' && screenState.showFreeModeCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'classification' && screenState.showClassificationCover && !screenState.gameActuallyStarted)
                            )) {
                           requestAnimationFrame(draw); 
                        }
                    }
                };
                 img.onerror = () => {
                    console.error(`Error al cargar imagen: ${img.src}`);
                    worldImagesLoaded++; 
                     if (worldImagesLoaded === totalWorldImagesToLoad) {
                        console.log("Proceso de carga de imágenes de mundo/nivel/derrota/modo libre/modo clasificación finalizado (con errores).");
                         if (ctx && (
                            (gameMode === 'levels' && (screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0) && !screenState.gameActuallyStarted) || 
                            screenState.showWorldCompleteCover > 0 ||
                            (gameMode === 'freeMode' && screenState.showFreeModeCover && !screenState.gameActuallyStarted) ||
                            (gameMode === 'classification' && screenState.showClassificationCover && !screenState.gameActuallyStarted)
                            )) {
                            requestAnimationFrame(draw); 
                        }
                    }
                };
            });
        }

        function loadModeSelectionImages() {
            modeSelectIntroImg.src = 'https://i.imgur.com/W34ctvU.png';
            modeSelectLevelsImg.src = 'https://i.imgur.com/1Dp5GTu.png';
            modeSelectFreeImg.src = 'https://i.imgur.com/6cMWnrC.png';
            modeSelectClassificationImg.src = 'https://i.imgur.com/t5n37Mw.png';
            modeSelectMazeImg.src = 'https://i.imgur.com/WY3lrHv.png';

            [modeSelectIntroImg, modeSelectLevelsImg, modeSelectFreeImg, modeSelectClassificationImg, modeSelectMazeImg].forEach(img => {
                img.onload = () => { if (showModeSelect && ctx) requestAnimationFrame(draw); };
                img.onerror = () => { console.error(`Error al cargar imagen: ${img.src}`); if (showModeSelect && ctx) requestAnimationFrame(draw); };
            });
        }

        function loadSkinImages() {
            classicSnakeHeadLeftImg.src = 'https://i.imgur.com/x3Wrabg.png';
            classicSnakeHeadDownImg.src = 'https://i.imgur.com/lapIn2F.png';
            classicFoodImg.src = 'https://i.imgur.com/Rrvl9Fj.png'; 
            snakeBodyTexture.src = 'https://i.imgur.com/rWlvRt4.png'; 

            rubiSnakeHeadUpDownImg.src = 'https://i.imgur.com/XQzDVMk.png';
            rubiSnakeHeadLeftImg.src = 'https://i.imgur.com/XQzDVMk.png'; 
            rubiSnakeFoodImg.src = 'https://i.imgur.com/wXIXaQZ.png';

            aitorSnakeHeadUpDownImg.src = 'https://i.imgur.com/WBS3C4N.png';
            aitorSnakeHeadLeftImg.src = 'https://i.imgur.com/IfYIEkv.png';
            aitorSnakeFoodImg.src = 'https://i.imgur.com/rUCsqoq.png'; 

            noemiSnakeHeadUpDownImg.src = 'https://i.imgur.com/h84RIhq.png';
            noemiSnakeHeadLeftImg.src = 'https://i.imgur.com/TU4CgRq.png';
            noemiSnakeFoodImg.src = 'https://i.imgur.com/2bGXbM1.png';
            
            maraSnakeHeadUpDownImg.src = 'https://i.imgur.com/YvQ2uni.png';
            maraSnakeHeadLeftImg.src = 'https://i.imgur.com/oiBGoud.png';
            maraSnakeFoodImg.src = 'https://i.imgur.com/krE9lwu.png';

            almuSnakeHeadUpDownImg.src = 'https://i.imgur.com/2HqLxxp.png';
            almuSnakeHeadLeftImg.src = 'https://i.imgur.com/27Q7QvA.png';
            almuSnakeFoodImg.src = 'https://i.imgur.com/Lcurg08.png';

            mimiSnakeHeadUpDownImg.src = 'https://i.imgur.com/2UnTxTM.png';
            mimiSnakeHeadLeftImg.src = 'https://i.imgur.com/GjJrvUA.png';
            mimiSnakeFoodImg.src = 'https://i.imgur.com/kgOjgCI.png';

            oreoFoodImg.src = 'https://i.imgur.com/Yv5ioX3.png';
            obstacleImg.src = 'https://i.imgur.com/wk1u29m.png';
            lightningYellowImg.src = 'https://i.imgur.com/AJL2p3j.png';
            lightningRedImg.src = 'https://i.imgur.com/4sNOTpi.png';
            
            const allImageObjects = [ 
                classicSnakeHeadLeftImg, classicSnakeHeadDownImg, classicFoodImg, snakeBodyTexture,
                rubiSnakeHeadUpDownImg, rubiSnakeHeadLeftImg, rubiSnakeFoodImg,
                aitorSnakeHeadUpDownImg, aitorSnakeHeadLeftImg, aitorSnakeFoodImg,
                noemiSnakeHeadUpDownImg, noemiSnakeHeadLeftImg, noemiSnakeFoodImg,
                maraSnakeHeadUpDownImg, maraSnakeHeadLeftImg, maraSnakeFoodImg,
                almuSnakeHeadUpDownImg, almuSnakeHeadLeftImg, almuSnakeFoodImg,
                mimiSnakeHeadUpDownImg, mimiSnakeHeadLeftImg, mimiSnakeFoodImg,
                oreoFoodImg, obstacleImg, lightningYellowImg, lightningRedImg
            ];

            allImageObjects.forEach(imgObj => {
                imgObj.onload = () => {
                    console.log(`Imagen ${imgObj.src.split('/').pop()} cargada.`);
                    if (ctx && (gameOver || !gameIntervalId || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                        requestAnimationFrame(draw);
                    }
                };
                imgObj.onerror = () => {
                    console.error(`Error al cargar la imagen: ${imgObj.src}`);
                    if (ctx && (gameOver || !gameIntervalId || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                        requestAnimationFrame(draw);
                    }
                };
            });
        }

        function applySkin(skinName) {
            currentSkin = skinName;
            console.log(`Jugador aplicado: ${currentSkin}`);

            if (gameOver) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151"; 
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            } else { 
                if (!gameIntervalId && ctx) { 
                    draw(); 
                }
            }
        }

        function applyFood(foodName) {
            currentFood = foodName;
            console.log(`Comestible aplicado: ${currentFood}`);
            if (gameOver) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            } else {
                if (!gameIntervalId && ctx) {
                    draw();
                }
            }
        }
        
        function resizeGameElements() {
            if (!gameContainer || !canvasEl ) { 
                console.error("Error: gameContainer or canvasEl no están definidos en resizeGameElements.");
                return;
            }
            const containerComputedStyle = getComputedStyle(gameContainer);
            const canvasComputedStyle = getComputedStyle(canvasEl);

           const containerPadding = 2 * parseFloat(containerComputedStyle.paddingLeft);
           let availableWidth = gameContainer.clientWidth - containerPadding;

           const canvasBorderWidth = 2 * parseFloat(canvasComputedStyle.borderLeftWidth);
           availableWidth -= canvasBorderWidth;

            const availableHeight =
                gameContainer.clientHeight -
                topInfoBar.offsetHeight -
                setupControls.offsetHeight;

            GRID_SIZE = Math.floor(
                Math.min(availableWidth, availableHeight) / TILE_COUNT
            );

            canvasEl.width = TILE_COUNT * GRID_SIZE;
            canvasEl.height = TILE_COUNT * GRID_SIZE;

            tileCountX = TILE_COUNT;
            tileCountY = TILE_COUNT;

            // If a panel is open, re-calculate its position after resize
            if (!settingsPanel.classList.contains("settings-panel-hidden")) {
                positionPanel(settingsPanel);
            }
            if (!infoPanel.classList.contains("info-panel-hidden")) {
                positionPanel(infoPanel);
            }
            if (specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden")) {
                positionPanel(specificInfoPanel);
            }


            if (ctx && (gameIntervalId || gameOver || snake.length > 0 || screenState.showCoverForWorld > 0 || screenState.showLevelCompleteCover > 0 || screenState.showWorldCompleteCover > 0 || screenState.showDefeatCoverForWorld > 0 || screenState.showFreeModeCover || screenState.showClassificationCover)) {
                draw();
            } else if (ctx) {
                ctx.fillStyle = "#374151";
                ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            }
        }

        function resetGameUIDisplays() {
            updateCoinDisplay();
            scoreValueDisplay.textContent = "0";
            if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
            } else if (gameMode === 'classification') {
                timeLengthValueEl.textContent = formatTime(0);
            } else { // freeMode
                timeLengthValueEl.textContent = initialSnakeLength;
            }
            updateTargetScoreDisplay();
        }

        function positionPanel(panelElement) {
            let topReferenceElement = progressPanel;
            if (progressPanel.classList.contains('hidden') || !progressPanel.offsetParent) {
                if (!titlePanel.classList.contains('hidden') && titlePanel.offsetParent) {
                    topReferenceElement = titlePanel;
                } else {
                    topReferenceElement = topInfoBar;
                    if (topInfoBar.classList.contains('hidden') || !topInfoBar.offsetParent) {
                        topReferenceElement = gameContainer;
                    }
                }
            }
            
            const mobileControlsEl = document.getElementById('mobile-controls'); 

            if (!topReferenceElement || !mobileControlsEl || !panelElement || !gameContainer) { 
                console.error("positionPanel: Elemento(s) clave(s) para el posicionamiento no encontrado(s).");
                return;
            }

            const topRefRect = topReferenceElement.getBoundingClientRect();
            const mobileControlsRect = mobileControlsEl.getBoundingClientRect(); 
            const gameContainerRect = gameContainer.getBoundingClientRect();
            const panelVerticalMargin = 5; 

            let panelTopPosition = topRefRect.top - gameContainerRect.top;
            if (topReferenceElement === gameContainer) panelTopPosition = 0; 
            
            panelElement.style.top = panelTopPosition + 'px';
            
            let panelBottomLimit;
            if (mobileControlsEl.offsetParent === null) {
                panelBottomLimit = gameContainerRect.height - panelVerticalMargin;
            } else {
                panelBottomLimit = mobileControlsRect.top - gameContainerRect.top - panelVerticalMargin;
            }
            let availablePanelHeight = panelBottomLimit - panelTopPosition;

            panelElement.style.height = Math.max(100, availablePanelHeight) + 'px';
            panelElement.style.bottom = 'auto';
            const limitSource = mobileControlsEl.offsetParent === null ? 'Contenedor' : 'D-Pad';
            console.log(`Panel ${panelElement.id} posicionado. Top: ${panelElement.style.top}, Height: ${panelElement.style.height}, Referencia superior: ${topReferenceElement.id}, Límite inferior: ${limitSource}`);
        }

        function updateMainButtonStates() {
            const isSettingsVisible = !settingsPanel.classList.contains("settings-panel-hidden") && settingsPanel.classList.contains("panel-visible");
            const isInfoVisible = !infoPanel.classList.contains("info-panel-hidden") && infoPanel.classList.contains("panel-visible");
            const isAnyMainPanelEffectivelyOpen = isSettingsVisible || isInfoVisible;

            if (isAnyMainPanelEffectivelyOpen) {
                startButton.disabled = true;
                restartMazeButton.disabled = true;
                configButton.disabled = true;
                infoButton.disabled = true;
                return;
            }

            if (gameIntervalId) {
                startButton.disabled = true;
                restartMazeButton.disabled = true;
                configButton.disabled = true;
                infoButton.disabled = true;
            } else {
                const isWorldIntroCover = screenState.showCoverForWorld > 0 && !screenState.gameActuallyStarted;
                const isWorldCompleteScreen = screenState.showWorldCompleteCover > 0;
                const isLevelCompleteScreen = screenState.showLevelCompleteCover > 0 && !screenState.gameActuallyStarted;
                const isDefeatScreen = screenState.showDefeatCoverForWorld > 0 && !screenState.gameActuallyStarted;
                const isTimeoutScreen = screenState.showTimeoutCover && !screenState.gameActuallyStarted;
                const isFreeModeCoverActive = screenState.showFreeModeCover && !screenState.gameActuallyStarted;
                const isClassificationCoverActive = screenState.showClassificationCover && !screenState.gameActuallyStarted;
                const isMazeCoverActive = screenState.showMazeCover && !screenState.gameActuallyStarted;
                const isMazeResultScreen = screenState.mazeResultType && !screenState.gameActuallyStarted;
                const isModeSelectActive = showModeSelect;
                const isModeSelectIntro = isModeSelectActive && MODE_SELECT_ORDER[modeSelectIndex] === 'intro';

                startButton.disabled = isModeSelectIntro;
                restartMazeButton.disabled = restartMazeButton.classList.contains('hidden');
                configButton.disabled = false;
                infoButton.disabled = false;

                if (isModeSelectActive) {
                    startButton.textContent = "Seleccionar";
                } else if (isLevelCompleteScreen) {
                    // Text is set by handleLevelsModeEnd
                } else if (isWorldCompleteScreen) {
                    // Text is set by handleLevelsModeEnd
                } else if (isDefeatScreen || isTimeoutScreen) {
                    startButton.textContent = "Reintentar";
                } else if (isMazeResultScreen) {
                    // Text already set by handleMazeModeEnd
                } else if (isWorldIntroCover || isFreeModeCoverActive || isClassificationCoverActive || isMazeCoverActive) {
                    startButton.textContent = "Empezar";
                } else if (gameOver && (gameMode === 'freeMode' || gameMode === 'classification')) {
                    startButton.textContent = "Empezar";
                } else if (gameOver && gameMode === 'levels') {
                    // finalizeGameOver (via handleLevelsModeEnd) sets the text
                    // If we are here after closing settings, it should be "Empezar"
                     if (!isWorldIntroCover && !isWorldCompleteScreen && !isLevelCompleteScreen && !isDefeatScreen) {
                        startButton.textContent = "Empezar";
                    }
                } else { 
                    startButton.textContent = "Empezar";
                }
                
                const isAnyCoverScreenActive = isWorldIntroCover || isWorldCompleteScreen || isLevelCompleteScreen || isDefeatScreen || isTimeoutScreen || isFreeModeCoverActive || isClassificationCoverActive || isMazeCoverActive || isMazeResultScreen || isModeSelectActive;
                if (!isAnyCoverScreenActive && !gameOver) {
                     if (isMusicEnabled && generalBackgroundMusic && generalBackgroundMusic.paused) {
                        if (inGameBackgroundMusic && !inGameBackgroundMusic.paused) inGameBackgroundMusic.pause();
                        generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (updateMainButtonStates):", e));
                    }
                }
            }
        }

        // --- Panel Management Refactor ---
        function togglePanel(panelElement, contentContainer, show) {
            if (!panelElement) {
                console.error("togglePanel: panelElement no encontrado.");
                return;
            }
            const panelId = panelElement.id;
            let hiddenClassName;
            const visibleClassName = "panel-visible";

            if (panelId === "settings-panel") hiddenClassName = "settings-panel-hidden";
            else if (panelId === "info-panel") hiddenClassName = "info-panel-hidden";
            else if (panelId === "specific-info-panel") hiddenClassName = "specific-info-panel-hidden";
            else {
                console.error("togglePanel: Clase oculta no definida para el panel:", panelId);
                return;
            }

            if (show) {
                if (panelElement === settingsPanel && !infoPanel.classList.contains("info-panel-hidden")) {
                    togglePanel(infoPanel, infoPanelContent, false);
                }
                if (panelElement === infoPanel && !settingsPanel.classList.contains("settings-panel-hidden")) {
                    togglePanel(settingsPanel, settingsPanel, false);
                }
                if (panelElement !== specificInfoPanel && specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden")) {
                    togglePanel(specificInfoPanel, specificInfoContent, false);
                }

                panelElement.classList.remove(hiddenClassName);
                positionPanel(panelElement);
                
                requestAnimationFrame(() => { 
                    panelElement.classList.add(visibleClassName);
                    const targetScrollElement = contentContainer || panelElement;
                     if(targetScrollElement) targetScrollElement.scrollTop = 0;
                });
                
                startButton.disabled = true;
                configButton.disabled = true;
                infoButton.disabled = true;

                if (panelElement === settingsPanel && !gameIntervalId) {
                    gameModeSelector.disabled = false;
                    skinSelector.disabled = false;
                    foodSelector.disabled = false;
                    gameModeControlGroup.classList.add("interactive-mode");
                    skinControlGroup.classList.add("interactive-mode");
                    foodControlGroup.classList.add("interactive-mode");
                    if (gameMode === 'levels') worldsSelector.disabled = false; else difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                    if (typeof Tone !== 'undefined') {
                        audioToggleSelector.disabled = false;
                        audioControlGroup.classList.add("interactive-mode");
                        musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                        if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                        else musicVolumeControlGroup.classList.remove("interactive-mode");
                    }
                     settingsPanel.querySelectorAll('.setting-info-button').forEach(btn => btn.disabled = false);
                }
            } else { // Hiding a panel
                panelElement.classList.remove(visibleClassName); 
                setTimeout(() => {
                    panelElement.classList.add(hiddenClassName); 
                    panelElement.style.top = '';
                    panelElement.style.bottom = '';
                    panelElement.style.height = '';
                    // Caller of togglePanel(..., false) is now responsible for updateMainButtonStates
                }, 300); 
            }
        }


        function openSettingsPanel() {
            togglePanel(settingsPanel, settingsPanel, true);
            if (gameOver && !gameIntervalId) { // Game is over and not running
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
                
                score = 0; // Reset internal score
                streakMultiplier = 1; // Reset internal streak
                
                if (gameMode === 'levels' || gameMode === 'maze') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = []; // Vaciar la serpiente para que updateTimeLengthDisplay use initialSnakeLength
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = [];
                }
                resetGameUIDisplays(); // Update UI for score, streak, AND length (if free mode and snake is empty)
                updateGameModeUI(); // This will refresh panel values and target scores
                requestAnimationFrame(draw); // Redraw canvas to show cover
            } else {
                updateGameModeUI(); // Ensure panel reflects current mode when opening during gameplay
            }
        }

        function closeSettingsPanel() {
            const wasSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden");
            
            togglePanel(settingsPanel, settingsPanel, false); // Hides panel

            if (wasSpecificInfoOpen) {
                togglePanel(specificInfoPanel, specificInfoContent, false); // Hides specific info
            }

            if (gameOver && !gameIntervalId) { // If game was over and not running
                if (gameMode === 'levels') {

                    screenState.showCoverForWorld = currentWorld; // Show current world cover
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    
                    // Score and streak should have been reset when settings panel was opened if game was over
                    updateScoreDisplay(); // Ensure score 0 is displayed
                    updateTargetScoreDisplay(); // Ensure correct target is displayed
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true; // Ensure cover is shown when returning from settings
                    screenState.gameActuallyStarted = false;
                    // Score, streak and snake length (via snake=[]) reset when settings opened
                    updateScoreDisplay();
                    updateTimeLengthDisplay(); // Ensure length is updated based on empty snake array
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true; // Ensure cover is shown when returning from settings
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                }
                updateGameModeUI(); 
                requestAnimationFrame(draw); 
            }
            
            setTimeout(() => { // Ensure buttons are updated after panel animation
                updateMainButtonStates();
            }, 0); 
        }

        function openInfoPanel() {
            togglePanel(infoPanel, infoPanelContent, true);
            if (gameOver && !gameIntervalId) {
                if (ctx && canvasEl) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
                score = 0;
                streakMultiplier = 1;

                if (gameMode === 'levels' || gameMode === 'maze') {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showTimeoutCover = false;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                } else if (gameMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = []; // Vaciar la serpiente
                } else if (gameMode === 'classification') {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    snake = [];
                }
                resetGameUIDisplays(); // Llamar aquí para que la UI se actualice con los valores reseteados
                updateGameModeUI();
                requestAnimationFrame(draw);
            }
        }

        function closeInfoPanel() {
            togglePanel(infoPanel, infoPanelContent, false);
             if (gameOver && !gameIntervalId) { // If game was over and not running
                if (gameMode === "levels") {
                    screenState.showCoverForWorld = currentWorld;
                    screenState.gameActuallyStarted = false;
                    screenState.showLevelCompleteCover = 0;
                    screenState.showWorldCompleteCover = 0;
                    screenState.showDefeatCoverForWorld = 0;
                    screenState.showFreeModeCover = false;
                    screenState.showClassificationCover = false;
                    updateScoreDisplay();
                    updateTargetScoreDisplay();
                } else if (gameMode === "freeMode") {
                    screenState.showFreeModeCover = true;
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                } else if (gameMode === "classification") {
                    screenState.showClassificationCover = true;
                    screenState.gameActuallyStarted = false;
                    updateScoreDisplay();
                    updateTimeLengthDisplay();
                }
                updateGameModeUI();
                requestAnimationFrame(draw);
            }
            setTimeout(() => {
                updateMainButtonStates();
            }, 0);
        }
        
        configButton.addEventListener('click', openSettingsPanel);
        closeSettingsButton.addEventListener('click', closeSettingsPanel);
        infoButton.addEventListener('click', openInfoPanel); 
        closeInfoButton.addEventListener('click', closeInfoPanel); 

        // --- Specific Info Panel Logic ---
        const specificHelpTexts = {
            gameMode: {
                title: "Tipo de Juego",
                text: "<p>Define la estructura principal de tus partidas, eligiendo entre:</p><h4>Modo Aventura</h4><p>Embárcate en un viaje progresivo a través de diversos mundos. En este modo:</p><ul><li>Cada mundo presenta un diseño de escenario único y puede introducir nuevos obstáculos o mecánicas.</li><li>Deberás alcanzar una <strong>puntuación objetivo</strong> en cada nivel para superarlo.</li><li>Desbloquea <strong>nuevos mundos</strong> superando todos los niveles del mundo en el que te encuentras.</li><li>La dificultad de los niveles y mundos aumenta gradualmente, ¿Serás capaz de superarlos todos?</li></ul><h4>Modo Libre</h4><p>Disfruta de la experiencia clásica de Snake sin la presión de superar niveles específicos. En este modo:</p><ul><li>El objetivo principal es conseguir la <strong>máxima puntuación</strong> y la <strong>serpiente más larga</strong> posible en una única partida.</li><li>La dificultad que selecciones (Principiante, Explorador, Veterano o Legendario) afectará directamente la velocidad inicial de la serpiente y a la clasificación en la que se registran las puntuaciones.</li></ul><h4>Modo Clasificación</h4><p>Un modo similar al Modo Libre donde también competirás por lograr la mejor puntuación posible. Las puntuaciones se almacenan de forma independiente para este modo.</p>"
            },
            difficulty: { 
                title: "Dificultad / Mundo", 
                text_adventure: "<h4> (Solo en Modo Aventura)</h4><p>Cuando juegas en <strong>Modo Aventura</strong>, tendrás disponibles un total de 8 mundos. Cada uno de ellos dispone de 5 niveles de creciente dificultad. Tendrás que superarlos todos para poder avanzar al siguiente mundo. Complétalos todos para finalizar este modo de juego.</p><p>El selector de <strong>Mundos</strong> (que aparece al seleccionar \"Modo Aventura\") te permite elegir en qué mundo específico deseas comenzar tu aventura, siempre y cuando ya lo hayas desbloqueado previamente jugando y superando los anteriores en la dificultad seleccionada. ¡Supera los mundos para acceder a nuevos escenarios y desafíos más emocionantes o volver a jugar a los que ya hayas superado!</p><p>No olvides estar atento a las novedades del juego, ¡Puede que haya nuevos niveles muy pronto!</p>",
                text_free: "<h4> (Solo en Modo Libre)</h4><p>Ajusta el nivel de desafío para que se adapte a tu habilidad y preferencias. La dificultad influye principalmente en la velocidad de la serpiente y el tiempo de desaparición de los comestibles.</p><h4>Principiante</h4><p>Un modo relajado pensado para quienes se inician. La serpiente avanza despacio y la comida nunca desaparece.</p><h4>Explorador</h4><p>Aumenta ligeramente la velocidad y se introduce la racha junto con la desaparición de la comida y la aparición de rayos.</p><h4>Veterano</h4><p>La velocidad sube un poco más y se añaden obstáculos, espejos y comida falsa que puede restar puntos.</p><h4>Legendario</h4><p>Solo para expertos: la serpiente es muy rápida, la comida dura muy poco y todas las mecánicas combinadas te pondrán a prueba.</p>",
                text_classification: "<h4> (Solo en Modo Clasificación)</h4><p>Compite por la mejor puntuación al igual que en el Modo Libre, pero con una tabla de récords independiente.</p>"
            },
            skin: {
                title: "Jugador",
                text: "<p>Personaliza tu serpiente, juega con el look que más te guste y convierte tu experiencia en algo único y divertido</p><h4>Selección de Jugador</h4><p>Elige entre una variedad de estilos visuales disponibles en el selector. Cada jugador ofrece una estética diferente para tu reptil protagonista, desde aspectos clásicos hasta diseños más originales y temáticos.</p><p>Algunos jugadores pueden estar disponibles desde el inicio, mientras que otros podrían requerir ser desbloqueados mediante logros en el juego o estar disponibles en futuras actualizaciones.</p><p>Es importante destacar que la elección del jugador es <strong>puramente estética</strong>. Cambiar la apariencia de tu serpiente no afecta de ninguna manera su velocidad, longitud, la forma en que come, ni las puntuaciones que obtienes.</p><p>¡Así que siéntete libre de experimentar y elegir el que más te guste sin preocuparte por ventajas o desventajas en el juego!</p>"
            },
            food: {
                title: "Comestible",
                text: "<p>Selecciona el alimento que quieres que aparezca en el escenario. Esta elección solo afecta al aspecto visual y no modifica la jugabilidad.</p>"
            },
            audioGeneral: {
                title: "Audio General",
                text: "<p>Controla los elementos sonoros del juego para crear la atmósfera perfecta para ti.</p><h4>Activado (Música y FX)</h4><p>Selecciona esta opción para disfrutar de la experiencia sonora completa. Esto incluye:</p><ul><li><strong>Música de fondo:</strong> Utilizada para ambientar, tanto el juego en general, como tus partidas.</li><li><strong>Efectos de sonido (SFX):</strong> Indicaciones auditivas para acciones cruciales como comenzar una partida, comer, superar un nivel, perder, conseguir un récord...</li></ul><h4>Sólo SFX</h4><p>Si la música de fondo te resulta distractora pero aun así deseas la retroalimentación auditiva de tus acciones en el juego, esta es tu opción.</p><h4>Desactivado</h4><p>Elige esta opción para silenciar completamente el juego. Es ideal si prefieres jugar mientras escuchas tu propia música o podcast mientras juegas.</p>"
            },
            musicVolume: {
                title: "Volumen Música",
                text: "<p>Ajusta con precisión qué tan fuerte o suave quieres que suene la música de fondo del juego, siempre que la tengas activada.</p><h4>Control de Volumen</h4><p>Utiliza el deslizador (slider) para regular el nivel del volumen de la música. Moviéndolo hacia la derecha aumentarás el volumen, y hacia la izquierda lo disminuirás.</p><p>Encuentra el punto perfecto que te permita disfrutar de la banda sonora del juego sin que resulte abrumadora o tape otros sonidos importantes, especialmente si también tienes los efectos de sonido (SFX) activados.</p><h4>Condiciones de Uso</h4><p>Es fundamental recordar que para que este ajuste de volumen de música tenga algún efecto, la opción de <strong>\"Audio General\"</strong> debe estar configurada en <strong>\"Activado (Música y FX)\"</strong>.</p><p>Si el \"Audio General\" está seleccionado como \"Sólo SFX\" o \"Desactivado\", no escucharás la música independientemente del nivel que establezcas en este control de volumen, ya que la fuente principal de música estará deshabilitada.</p>"
            }
        };

        function openSpecificInfoPanel(settingKey) {
            if (!specificInfoPanel || !specificInfoTitle || !specificInfoContent) return;

            let helpData = specificHelpTexts[settingKey];
            if (!helpData) {
                console.error(`No help text found for setting: ${settingKey}`);
                return;
            }
            
            specificInfoTitle.textContent = helpData.title;

            if (settingKey === 'difficulty') {
                if (gameMode === 'levels') {
                    specificInfoTitle.textContent = "Mundos";
                    specificInfoContent.innerHTML = helpData.text_adventure;
                } else {
                    specificInfoTitle.textContent = "Dificultad";
                    if (gameMode === 'classification') {
                        specificInfoContent.innerHTML = helpData.text_classification;
                    } else {
                        specificInfoContent.innerHTML = helpData.text_free;
                    }
                }
            } else {
                specificInfoContent.innerHTML = helpData.text;
            }
            
            // Disable controls in the settings panel before showing specific info
            Array.from(settingsPanel.querySelectorAll('select, input[type="range"], .setting-info-button')).forEach(el => el.disabled = true);
            Array.from(settingsPanel.querySelectorAll('.control-group.interactive-mode')).forEach(el => el.classList.remove("interactive-mode")); // Visually indicate disabled state

            togglePanel(specificInfoPanel, specificInfoContent, true);
        }

        function closeSpecificInfoPanel() {
            togglePanel(specificInfoPanel, specificInfoContent, false); // Hide specific info panel

            // Re-enable controls in the settings panel if it's still meant to be open
            if (!settingsPanel.classList.contains("settings-panel-hidden") && !gameIntervalId) {
                gameModeSelector.disabled = false;
                skinSelector.disabled = false;
                foodSelector.disabled = false;
                gameModeControlGroup.classList.add("interactive-mode");
                skinControlGroup.classList.add("interactive-mode");
                foodControlGroup.classList.add("interactive-mode");

                if (gameMode === 'levels') {
                    worldsSelector.disabled = false;
                } else if (gameMode === 'maze') {
                    mazeLevelSelector.disabled = false;
                } else {
                    difficultySelector.disabled = false;
                }
                difficultyControlGroup.classList.add("interactive-mode");

                if (typeof Tone !== 'undefined') {
                    audioToggleSelector.disabled = false;
                    audioControlGroup.classList.add("interactive-mode");
                    musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                    if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                    else musicVolumeControlGroup.classList.remove("interactive-mode");
                }
                settingsPanel.querySelectorAll('.setting-info-button').forEach(btn => btn.disabled = false);
                
                // Ensure main action buttons reflect that settings panel is still the context
                startButton.disabled = true;
                configButton.disabled = true;
                infoButton.disabled = true;
            } else {
                // If settings panel was not open, or game is running, update main buttons normally
                updateMainButtonStates();
            }
        }


        if (closeSpecificInfoButton) {
            closeSpecificInfoButton.addEventListener('click', closeSpecificInfoPanel);
        }

        document.querySelectorAll('.setting-info-button').forEach(button => { 
            button.addEventListener('click', function() {
                const settingKey = this.dataset.setting;
                openSpecificInfoPanel(settingKey);
            });
        });


        function drawFoodItem(x, y) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS['apple'];
            const foodImg = foodData.asset;
            
            let foodVisualTopY;
            let foodVisualHeight;

            if (foodImg && foodImg.complete && foodImg.naturalHeight !== 0) {
                const drawSize = GRID_SIZE * foodData.scale;
                const offset = (drawSize - GRID_SIZE) / 2;
                foodVisualTopY = y * GRID_SIZE - offset;
                foodVisualHeight = drawSize;
            } else {
                foodVisualTopY = y * GRID_SIZE + 2; 
                foodVisualHeight = GRID_SIZE - 4; 
            }
            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            let foodIsVisible = true;
            if (!gameOver && foodTimeRemaining <= FOOD_WARNING_TIME && foodTimeRemaining > 0) {
                const blinkInterval = 500; 
                foodIsVisible = (Math.floor(foodTimeRemaining / blinkInterval) % 2 !== 0);
            }

            if (foodIsVisible && (foodTimeRemaining > 0 || currentFoodItem.initialLifespanForThisFood === 0)) {
                if (foodImg && foodImg.complete && foodImg.naturalHeight !== 0) {
                    const drawSize = GRID_SIZE * foodData.scale;
                    const offset = (drawSize - GRID_SIZE) / 2;
                    if (currentFoodItem.isGolden) {
                        ctx.filter = 'hue-rotate(-50deg) brightness(1.4)';
                    }
                    ctx.drawImage(foodImg, x * GRID_SIZE - offset, y * GRID_SIZE - offset, drawSize, drawSize);
                    ctx.filter = 'none';
                } else {
                    ctx.fillStyle = currentFoodItem.isGolden ? 'gold' : FOOD_SHAPE_FALLBACK.color;
                    ctx.fillRect(x * GRID_SIZE + 2, y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                    ctx.strokeStyle = FOOD_SHAPE_FALLBACK.borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x * GRID_SIZE + 2, y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                }
            }

            if (!gameOver && foodTimeRemaining > 0 && currentFoodItem.initialLifespanForThisFood > 0) {
                const barProgress = foodTimeRemaining / currentFoodItem.initialLifespanForThisFood;
                const barWidth = (GRID_SIZE - 4) * barProgress; 
                const barHeight = 3;
                const barGap = 2; 

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                   timeBarYPosition = canvasEl.height - barHeight -1; 
                }
                 if (timeBarYPosition < 0){ 
                       timeBarYPosition = 1; 
                }
                
                let barColor = 'rgba(76, 175, 80, 0.85)'; 
                const percentageRemaining = (foodTimeRemaining / currentFoodItem.initialLifespanForThisFood) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)'; 
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)'; 
                }
                
                ctx.fillStyle = barColor;
                ctx.fillRect(
                    x * GRID_SIZE + 2, 
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }
        
        function calculateNextFoodLifespan() {
            let baseLifespan;
            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                baseLifespan = levelCfg.initialLifespan || 0;
            } else {
                baseLifespan = DIFFICULTY_SETTINGS[difficulty].initialLifespan;
            }
            if (baseLifespan <= 0) return 0;
            let streakReduction = 0;
            const effectiveStreak = Math.min(streakMultiplier, MAX_STREAK);
            if (effectiveStreak > 1) {
                // Reduce food lifespan by 0.5 s per 0.5 streak increase
                const reductionPerStep = DIFFICULTY_SETTINGS[difficulty].streakReduction || 1000;
                streakReduction = (effectiveStreak - 1) * reductionPerStep;
            }
            const calculatedLifespan = baseLifespan - streakReduction;
            return Math.max(MIN_FOOD_LIFESPAN, calculatedLifespan);
        }

        function generateFood() {
            clearTimeout(foodDisappearTimeoutId);
            clearInterval(foodVisualTimerIntervalId);
            lastWarningSoundSecond = -1; 
            let newFoodPosition;
            do {
                newFoodPosition = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                };
            } while ((isFoodOnSnake(newFoodPosition) || obstacles.some(ob => ob.x === newFoodPosition.x && ob.y === newFoodPosition.y)) && tileCountX > 0 && tileCountY > 0);
            
            if (tileCountX <=0 || tileCountY <=0) { 
                console.warn("Canvas too small to generate food.");
                currentFoodItem = {}; 
                return;
            }

            const classificationRank = CLASSIFICATION_RANKS[difficulty] || 0;
            const diffCfg = DIFFICULTY_SETTINGS[difficulty] || {};
            const goldenChance = diffCfg.goldenFoodChance !== undefined ? diffCfg.goldenFoodChance : GOLDEN_FOOD_CHANCE;
            const isGolden = ((gameMode === 'levels' && currentWorld === 5) || (gameMode === 'classification' && classificationRank >= 1)) && Math.random() < goldenChance;
            let lifespan = calculateNextFoodLifespan();
            if (isGolden) {
                if (gameMode === 'classification' && classificationRank === 1 && diffCfg.goldenFoodLifespan === undefined) {
                    lifespan = GOLDEN_FOOD_LIFESPAN_CLASSIF_RANK1;
                } else if (gameMode === 'levels') {
                    lifespan = GOLDEN_FOOD_LIFESPANS_WORLD5[currentLevelInWorld - 1] || lifespan;
                } else if (diffCfg.goldenFoodLifespan !== undefined) {
                    lifespan = diffCfg.goldenFoodLifespan;
                }
            }
            currentFoodItem = {
                x: newFoodPosition.x,
                y: newFoodPosition.y,
                isGolden,
                initialLifespanForThisFood: lifespan
            };
            foodTimeRemaining = currentFoodItem.initialLifespanForThisFood;
            if (foodTimeRemaining > 0) {
                foodDisappearTimeoutId = setTimeout(handleFoodTimeout, foodTimeRemaining);
                foodVisualTimerIntervalId = setInterval(() => {
                if (gameOver) {
                    clearInterval(foodVisualTimerIntervalId);
                    return;
                }
                foodTimeRemaining -= 100;
                if (foodTimeRemaining < 0) foodTimeRemaining = 0;
                if (foodTimeRemaining <= FOOD_WARNING_TIME && foodTimeRemaining > 0) {
                    const currentSecondInWarning = Math.ceil(foodTimeRemaining / 1000);
                    if (currentSecondInWarning !== lastWarningSoundSecond) { 
                        if (areSfxEnabled) playSound('warning');
                        lastWarningSoundSecond = currentSecondInWarning;
                    }
                } else {
                    lastWarningSoundSecond = -1; 
                }
            }, 100);
            } else {
                foodDisappearTimeoutId = null;
                foodVisualTimerIntervalId = null;
            }
        }
        
        function handleFoodTimeout() {
            if (gameOver) return;
            console.log("¡Comida no recogida! Racha perdida."); 
            if (areSfxEnabled) playSound('timeout');
            streakMultiplier = 1;
            const classRank = CLASSIFICATION_RANKS[difficulty] || 0;
            if ((gameMode === 'levels' && currentWorld >= 6) || (gameMode === 'classification' && classRank >= 2)) {
                startStreakAnimation(streakMultiplier);
            }
            foodTimeRemaining = 0;
            generateFood(); 
            updateScoreDisplay();
            draw(); 
        }

        function isFoodOnSnake(foodPosition) {
            for (let segment of snake) {
                if (segment.x === foodPosition.x && segment.y === foodPosition.y) {
                    return true;
                }
            }
            return false;
        }

        function isAdjacentToAnyFood(pos) {
            if (currentFoodItem.x !== undefined) {
                if (Math.abs(currentFoodItem.x - pos.x) <= 1 && Math.abs(currentFoodItem.y - pos.y) <= 1) {
                    return true;
                }
            }
            for (let ff of falseFoodItems) {
                if (Math.abs(ff.x - pos.x) <= 1 && Math.abs(ff.y - pos.y) <= 1) {
                    return true;
                }
            }
            return false;
        }

        function isAdjacentToAnyObstacle(pos) {
            for (let ob of obstacles) {
                if (Math.abs(ob.x - pos.x) <= 1 && Math.abs(ob.y - pos.y) <= 1) {
                    return true;
                }
            }
            return false;
        }

        function drawFalseFoodItem(item) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS["apple"];
            const img = foodData.asset;
            let foodVisualTopY;
            let foodVisualHeight;
            if (img && img.complete && img.naturalHeight !== 0) {
                const size = GRID_SIZE * foodData.scale;
                const off = (size - GRID_SIZE) / 2;
                foodVisualTopY = item.y * GRID_SIZE - off;
                foodVisualHeight = size;
                drawImageWithTint(ctx, img, item.x * GRID_SIZE - off, item.y * GRID_SIZE - off, size, size, 'rgba(255,0,0,0.2)');
            } else {
                foodVisualTopY = item.y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(item.x * GRID_SIZE + 2, item.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            }

            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            if (!gameOver && item.remaining > 0) {
                const totalLifespan = item.lifespan || FALSE_FOOD_LIFESPAN;
                const barProgress = item.remaining / totalLifespan;
                const barWidth = (GRID_SIZE - 4) * barProgress;
                const barHeight = 3;
                const barGap = 2;

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                    timeBarYPosition = canvasEl.height - barHeight - 1;
                }
                if (timeBarYPosition < 0) {
                    timeBarYPosition = 1;
                }

                let barColor = 'rgba(76, 175, 80, 0.85)';
                const percentageRemaining = (item.remaining / totalLifespan) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)';
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)';
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(
                    item.x * GRID_SIZE + 2,
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }

        function drawObstacle(ob) {
            if (!ctx) return;
            const drawSize = GRID_SIZE;
            const img = ob.img || obstacleImg;
            const offset = 0;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, ob.x * GRID_SIZE - offset, ob.y * GRID_SIZE - offset, drawSize, drawSize);
            } else {
                ctx.fillStyle = "#555";
                ctx.fillRect(ob.x * GRID_SIZE - offset, ob.y * GRID_SIZE - offset, drawSize, drawSize);
            }
        }

        function drawLightningItem(item) {
            if (!ctx) return;
            const img = item.color === 'yellow' ? lightningYellowImg : lightningRedImg;
            const drawSize = GRID_SIZE * 1.5;
            const offset = (drawSize - GRID_SIZE) / 2;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, item.x * GRID_SIZE - offset, item.y * GRID_SIZE - offset, drawSize, drawSize);
            } else {
                const color = item.color === 'yellow' ? 'yellow' : 'red';
                ctx.fillStyle = color;
                ctx.fillRect(item.x * GRID_SIZE + 2 - offset, item.y * GRID_SIZE + 2 - offset, GRID_SIZE - 4 + (drawSize - GRID_SIZE), GRID_SIZE - 4 + (drawSize - GRID_SIZE));
            }
        }

        function removeFalseFoodItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = falseFoodItems.indexOf(item);
            if (idx !== -1) falseFoodItems.splice(idx, 1);
        }

        function generateFalseFood() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos;
            let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isFoodOnSnake(pos) ||
                    (currentFoodItem.x === pos.x && currentFoodItem.y === pos.y) ||
                    falseFoodItems.some(f => f.x === pos.x && f.y === pos.y) ||
                    isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let lifespan = FALSE_FOOD_LIFESPAN;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (typeof cfg.falseFoodLifespan === 'number') {
                    lifespan = cfg.falseFoodLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeFalseFoodItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeFalseFoodItem(item); }, 100);
            falseFoodItems.push(item);
        }

        function scheduleNextFalseFoodSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                range = cfg.falseFoodSpawnRange || [5000, 7000];
            } else if (gameMode === "levels" && (currentWorld === 7 || currentWorld === 8 || currentWorld === 10)) {
                if (currentWorld === 7) {
                    range = FALSE_FOOD_SPAWN_RANGES_WORLD4[currentLevelInWorld - 1] || [5000,8000];
                } else if (currentWorld === 10) {
                    range = FALSE_FOOD_SPAWN_RANGES_WORLD8[currentLevelInWorld - 1] || [5000,7000];
                } else {
                    range = FALSE_FOOD_SPAWN_RANGE_WORLD5;
                }
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            falseFoodSpawnTimeoutId = setTimeout(() => {
                generateFalseFood();
                scheduleNextFalseFoodSpawn();
            }, delay);
        }

        function startWorld4FalseFoodMechanics() {
            stopWorld4FalseFoodMechanics();
            scheduleNextFalseFoodSpawn();
        }

        function stopWorld4FalseFoodMechanics() {
            if (falseFoodSpawnTimeoutId) {
                clearTimeout(falseFoodSpawnTimeoutId);
                falseFoodSpawnTimeoutId = null;
            }
            falseFoodItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            falseFoodItems = [];
        }

        function generateWorld5Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : (OBSTACLE_COUNTS_WORLD5[currentLevelInWorld - 1] || 0);
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isFoodOnSnake(pos) ||
                          obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld5Obstacles(customCount) {
            generateWorld5Obstacles(customCount);
        }

        function stopWorld5Obstacles() {
            obstacles = [];
        }

        function generateWorld6Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : OBSTACLE_COUNT_WORLD6;
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isFoodOnSnake(pos) ||
                          obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld6Obstacles(customCount) {
            generateWorld6Obstacles(customCount);
        }

        function stopWorld6Obstacles() {
            obstacles = [];
        }

        function generateWorld8Obstacles(customCount) {
            obstacles = [];
            const count = typeof customCount === 'number' ? customCount : (OBSTACLE_COUNTS_WORLD8[currentLevelInWorld - 1] || 0);
            for (let i = 0; i < count; i++) {
                let pos; let attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (tileCountX - 2)) + 1,
                        y: Math.floor(Math.random() * (tileCountY - 2)) + 1,
                    };
                    attempts++;
                } while ((pos.y === snakeSpawnRow ||
                          isFoodOnSnake(pos) ||
                          obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                          isAdjacentToAnyObstacle(pos)) && attempts < 100);
                if (attempts < 100) obstacles.push(pos);
            }
        }

        function startWorld8Obstacles(customCount) {
            generateWorld8Obstacles(customCount);
        }

        function stopWorld8Obstacles() {
            obstacles = [];
        }

        function removeLightningItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = lightningItems.indexOf(item);
            if (idx !== -1) lightningItems.splice(idx, 1);
        }

        function generateLightning() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos; let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isFoodOnSnake(pos) ||
                    obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                    lightningItems.some(l => l.x === pos.x && l.y === pos.y) ||
                    isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let yellowChance = 0.75;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (typeof cfg.yellowLightningChance === 'number') {
                    yellowChance = cfg.yellowLightningChance;
                }
            }
            const color = Math.random() < yellowChance ? 'yellow' : 'red';
            let lifespan = LIGHTNING_LIFESPAN;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (typeof cfg.lightningLifespan === 'number') {
                    lifespan = cfg.lightningLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, color, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeLightningItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeLightningItem(item); }, 100);
            lightningItems.push(item);
        }

        function scheduleNextLightningSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === "classification") {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                range = cfg.lightningSpawnRange || [5000, 7000];
            } else if (gameMode === "levels" && (currentWorld === 3 || currentWorld === 4 || currentWorld === 9 || currentWorld === 10)) {
                if (currentWorld === 3) {
                    range = LIGHTNING_SPAWN_RANGES_WORLD6[currentLevelInWorld - 1] || [5000, 7000];
                } else if (currentWorld === 4) {
                    range = LIGHTNING_SPAWN_RANGE_WORLD4;
                } else if (currentWorld === 10) {
                    range = LIGHTNING_SPAWN_RANGES_WORLD8[currentLevelInWorld - 1] || [5000, 7000];
                } else {
                    range = LIGHTNING_SPAWN_RANGE_WORLD7;
                }
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            lightningSpawnTimeoutId = setTimeout(() => {
                generateLightning();
                scheduleNextLightningSpawn();
            }, delay);
        }

        function startWorld6LightningMechanics() {
            stopWorld6LightningMechanics();
            scheduleNextLightningSpawn();
        }

        function stopWorld6LightningMechanics() {
            if (lightningSpawnTimeoutId) {
                clearTimeout(lightningSpawnTimeoutId);
                lightningSpawnTimeoutId = null;
            }
            lightningItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            lightningItems = [];
        }

        function drawMirrorItem(item) {
            if (!ctx) return;
            const foodData = FOODS[currentFood] || FOODS["apple"];
            const img = foodData.asset;
            let foodVisualTopY;
            let foodVisualHeight;
            if (img && img.complete && img.naturalHeight !== 0) {
                const size = GRID_SIZE * foodData.scale;
                const off = (size - GRID_SIZE) / 2;
                foodVisualTopY = item.y * GRID_SIZE - off;
                foodVisualHeight = size;
                drawImageWithTint(ctx, img, item.x * GRID_SIZE - off, item.y * GRID_SIZE - off, size, size, 'rgba(0,0,255,0.2)');
            } else {
                foodVisualTopY = item.y * GRID_SIZE + 2;
                foodVisualHeight = GRID_SIZE - 4;
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(item.x * GRID_SIZE + 2, item.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            }

            const foodVisualBottomY = foodVisualTopY + foodVisualHeight;

            if (!gameOver && item.remaining > 0) {
                const totalLifespan = item.lifespan || FALSE_FOOD_LIFESPAN;
                const barProgress = item.remaining / totalLifespan;
                const barWidth = (GRID_SIZE - 4) * barProgress;
                const barHeight = 3;
                const barGap = 2;

                let timeBarYPosition = foodVisualBottomY + barGap;

                if (timeBarYPosition + barHeight > canvasEl.height) {
                    timeBarYPosition = canvasEl.height - barHeight - 1;
                }
                if (timeBarYPosition < 0) {
                    timeBarYPosition = 1;
                }

                let barColor = 'rgba(76, 175, 80, 0.85)';
                const percentageRemaining = (item.remaining / totalLifespan) * 100;

                if (percentageRemaining <= 25) {
                    barColor = 'rgba(220, 38, 38, 0.85)';
                } else if (percentageRemaining <= 50) {
                    barColor = 'rgba(255, 235, 59, 0.85)';
                }

                ctx.fillStyle = barColor;
                ctx.fillRect(
                    item.x * GRID_SIZE + 2,
                    timeBarYPosition,
                    barWidth,
                    barHeight
                );
            }
        }

        function removeMirrorItem(item) {
            clearTimeout(item.timeoutId);
            clearInterval(item.intervalId);
            const idx = mirrorItems.indexOf(item);
            if (idx !== -1) mirrorItems.splice(idx, 1);
        }

        function generateMirror() {
            if (tileCountX <= 0 || tileCountY <= 0) return;
            let pos; let attempts = 0;
            do {
                pos = { x: Math.floor(Math.random()*tileCountX), y: Math.floor(Math.random()*tileCountY) };
                attempts++;
            } while ((isFoodOnSnake(pos) ||
                    obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                    mirrorItems.some(m => m.x === pos.x && m.y === pos.y) ||
                    isAdjacentToAnyFood(pos)) && attempts < 100);
            if (attempts >= 100) return;
            let lifespan = FALSE_FOOD_LIFESPAN;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (typeof cfg.mirrorLifespan === 'number') {
                    lifespan = cfg.mirrorLifespan;
                }
            }
            const item = { x: pos.x, y: pos.y, remaining: lifespan, lifespan };
            item.timeoutId = setTimeout(() => removeMirrorItem(item), lifespan);
            item.intervalId = setInterval(() => { item.remaining -= 100; if (item.remaining <= 0) removeMirrorItem(item); }, 100);
            mirrorItems.push(item);
        }

        function scheduleNextMirrorSpawn() {
            if (gameOver) return;
            let range;
            if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                range = cfg.mirrorSpawnRange || [5000, 7000];
            } else if (gameMode === "levels" && (currentWorld === 9 || currentWorld === 10)) {
                range = currentWorld === 9 ?
                    (MIRROR_SPAWN_RANGES_WORLD7[currentLevelInWorld - 1] || [5000, 7000]) :
                    (MIRROR_SPAWN_RANGES_WORLD8[currentLevelInWorld - 1] || [5000, 7000]);
            } else {
                return;
            }
            const delay = Math.random() * (range[1] - range[0]) + range[0];
            mirrorSpawnTimeoutId = setTimeout(() => {
                generateMirror();
                scheduleNextMirrorSpawn();
            }, delay);
        }

        function startWorld7MirrorMechanics() {
            stopWorld7MirrorMechanics();
            scheduleNextMirrorSpawn();
        }

        function stopWorld7MirrorMechanics() {
            if (mirrorSpawnTimeoutId) {
                clearTimeout(mirrorSpawnTimeoutId);
                mirrorSpawnTimeoutId = null;
            }
            mirrorItems.forEach(item => {
                clearTimeout(item.timeoutId);
                clearInterval(item.intervalId);
            });
            mirrorItems = [];
            controlsInverted = false;
            mirrorEffect = { active: false, startTime: 0 };
        }

        function generateMazeLevel(levelIndex) {
            obstacles = [];
            const layout = MAZE_LAYOUTS[levelIndex];
            if (layout) {
                obstacles = layout.map(pos => ({ x: pos.x, y: pos.y, img: obstacleImg }));
            }
        }

        function startMazeLevel() {
            generateMazeLevel(displayMazeLevel);
        }

        function stopMazeLevel() {
            obstacles = [];
        }

        function applySpeedChange(change) {
            clearInterval(gameIntervalId);
            snakeSpeed = Math.max(50, snakeSpeed + change);
            gameIntervalId = setInterval(update, snakeSpeed);
        }

        function activateSpeedBoost(color) {
            const change = color === 'yellow' ? -25 : -50;
            if (speedBoost.active) {
                applySpeedChange(-speedBoost.change);
            }
            applySpeedChange(change);
            speedBoost = { active: true, color, change, startTime: Date.now() };
        }

        function updateSpeedBoost() {
            if (!speedBoost.active) return;
            const elapsed = Date.now() - speedBoost.startTime;
            if (elapsed >= SPEED_BOOST_DURATION) {
                applySpeedChange(-speedBoost.change);
                speedBoost.active = false;
            }
        }
        function splitTextIntoLines(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            if (words.length === 0) return lines;
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + " " + word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth < maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // --- High Score Functions ---
        function getHighScoreKey(difficultyLevel) {
            return `snakeHighScores_${difficultyLevel}`;
        }

        function loadHighScores(difficultyLevel) {
            const key = getHighScoreKey(difficultyLevel);
            const scoresJSON = localStorage.getItem(key);
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function getClassificationHighScoreKey(difficultyLevel) {
            return `snakeClassificationHighScores_${difficultyLevel}`;
        }

        function loadClassificationHighScores(difficultyLevel) {
            const key = getClassificationHighScoreKey(difficultyLevel);
            const scoresJSON = localStorage.getItem(key);
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function saveClassificationHighScore(currentScore, timeValue, difficultyLevel) {
            const key = getClassificationHighScoreKey(difficultyLevel);
            let highScores = loadClassificationHighScores(difficultyLevel);
            const newEntry = {
                score: currentScore,
                time: timeValue,
                difficulty: DIFFICULTY_DISPLAY_NAMES[difficultyLevel],
                skin: currentSkin,
            };

            let insertIndex = highScores.findIndex(entry => {
                if (currentScore > entry.score) return true;
                if (currentScore === entry.score) {
                    if (timeValue < entry.time) return true;
                    if (timeValue === entry.time) return true;
                }
                return false;
            });

            if (insertIndex === -1) {
                highScores.push(newEntry);
                insertIndex = highScores.length - 1;
            } else {
                highScores.splice(insertIndex, 0, newEntry);
            }

            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            localStorage.setItem(key, JSON.stringify(highScores));
            console.log(`Puntuaciones Modo Clasificación guardadas para ${difficultyLevel}:`, highScores);

            const isActuallyNewHighScoreThisGame = insertIndex < MAX_HIGH_SCORES;
            const newRecordIndex = isActuallyNewHighScoreThisGame ? insertIndex : -1;
            return { isNewRecord: isActuallyNewHighScoreThisGame, rowIndex: newRecordIndex };
        }

        function saveHighScore(currentScore, snakeLengthValue, difficultyLevel) {
            const key = getHighScoreKey(difficultyLevel);
            let highScores = loadHighScores(difficultyLevel);
            const newEntry = {
                score: currentScore,
                length: snakeLengthValue,
                difficulty: DIFFICULTY_DISPLAY_NAMES[difficultyLevel],
                skin: currentSkin, // Guardamos el 'value' del skin actual
            };

            let insertIndex = highScores.findIndex(entry => {
                if (currentScore > entry.score) return true;
                if (currentScore === entry.score) {
                    if (snakeLengthValue > entry.length) return true;
                    if (snakeLengthValue === entry.length) return true; // Nuevo registro se coloca antes de los empates
                }
                return false;
            });

            if (insertIndex === -1) {
                highScores.push(newEntry);
                insertIndex = highScores.length - 1;
            } else {
                highScores.splice(insertIndex, 0, newEntry);
            }

            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            localStorage.setItem(key, JSON.stringify(highScores));
            console.log(`Puntuaciones guardadas para ${difficultyLevel}:`, highScores);

            const isActuallyNewHighScoreThisGame = insertIndex < MAX_HIGH_SCORES;
            const newRecordIndex = isActuallyNewHighScoreThisGame ? insertIndex : -1;
            return { isNewRecord: isActuallyNewHighScoreThisGame, rowIndex: newRecordIndex };
        }

        // --- Funciones de Refactorización de finalizeGameOver ---
        function clearGameTimersAndMusic() {
            clearInterval(gameIntervalId);
            gameIntervalId = null;
            clearTimeout(foodDisappearTimeoutId);
            clearInterval(foodVisualTimerIntervalId);
            clearInterval(gameTimerIntervalId);
            stopWorld4FalseFoodMechanics();
            stopWorld5Obstacles();
            stopWorld6Obstacles();
            stopWorld8Obstacles();
            stopWorld6LightningMechanics();
            stopWorld7MirrorMechanics();

            if (inGameBackgroundMusic) {
                inGameBackgroundMusic.pause();
                console.log("Música de partida pausada (clearGameTimersAndMusic).");
            }
        }

        function handleFreeModeEnd(currentScore, snakeLengthValue, difficultyValue) {
            const highScoreData = saveHighScore(currentScore, snakeLengthValue, difficultyValue);
            
            console.log("FinalizeGameOver - Modo Libre - isNewRecord:", highScoreData.isNewRecord, "Score:", currentScore, "Length:", snakeLengthValue, "Difficulty:", difficultyValue, "Blink Row Index:", highScoreData.rowIndex);
            
            if (highScoreData.isNewRecord) {
                blinkAnimation.startTime = Date.now();
                blinkAnimation.active = true; 
                console.log("Blink animation activated for new high score.");
            }
            return { isNewRecord: highScoreData.isNewRecord, isEffectivelyWon: highScoreData.isNewRecord, rowIndex: highScoreData.rowIndex };
        }

        function handleClassificationModeEnd(currentScore, timeElapsedValue, difficultyValue) {
            const highScoreData = saveClassificationHighScore(currentScore, timeElapsedValue, difficultyValue);

            console.log("FinalizeGameOver - Modo Clasificación - isNewRecord:", highScoreData.isNewRecord, "Score:", currentScore, "Time:", timeElapsedValue, "Difficulty:", difficultyValue, "Blink Row Index:", highScoreData.rowIndex);

            if (highScoreData.isNewRecord) {
                blinkAnimation.startTime = Date.now();
                blinkAnimation.active = true;
                console.log("Blink animation activated for new classification high score.");
            }
            return { isNewRecord: highScoreData.isNewRecord, isEffectivelyWon: highScoreData.isNewRecord, rowIndex: highScoreData.rowIndex };
        }

        function handleLevelsModeEnd(currentScore, timeRemaining) {
            const absoluteLevelIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
            const currentTarget = TARGET_SCORES_LEVELS[absoluteLevelIndex];
            const levelWon = (currentScore >= currentTarget && timeRemaining > 0);

            if (levelWon) {
                levelsProgress[absoluteLevelIndex] = true; // Se marca la estrella

                if (currentLevelInWorld === LEVELS_PER_WORLD) { // Mundo completado
                    screenState.showWorldCompleteCover = currentWorld;

                    if (currentWorld === TOTAL_WORLDS) { // Juego completado
                        startButton.textContent = "Ajustes";
                        // No hay más niveles a los que avanzar. currentWorld y currentLevelInWorld permanecen en el máximo.
                    } else { // Avanzar al siguiente mundo
                        startButton.textContent = "Nuevo Mundo";
                        // Actualizamos inmediatamente el estado para el próximo inicio
                        currentWorld++;
                        currentLevelInWorld = 1;
                        if (currentWorld > maxUnlockedWorld) {
                            maxUnlockedWorld = currentWorld;
                        }
                    }
                } else { // Nivel completado (no es el último del mundo)
                    currentLevelInWorld++; // Avanzamos el nivel inmediatamente
                    screenState.showLevelCompleteCover = currentWorld;
                    startButton.textContent = `Nivel ${currentWorld}.${currentLevelInWorld}`; // Botón para el *nuevo* nivel actual
                }
                // Limpiamos otros estados de pantalla
                screenState.showCoverForWorld = 0;
                screenState.showDefeatCoverForWorld = 0;

            } else { // Nivel perdido
                startButton.textContent = "Reintentar";
                screenState.showDefeatCoverForWorld = currentWorld;
                // Limpiamos otros estados de pantalla por si acaso
                screenState.showCoverForWorld = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
            }
            drawStarProgress(); // Dibuja las estrellas con la nueva completada
            return levelWon;
        }

        function handleMazeModeEnd(currentScore, timeRemaining) {
            const isLastLevel = displayMazeLevel === MAZE_LEVEL_COUNT;
            let levelWon = false;
            let resultType = 'fail';

            const levelIndex = displayMazeLevel - 1;
            const previousStars = mazePreviousStars;
            const improved = mazeStarsEarned > previousStars;

            if (isLastLevel && improved && mazeStarsEarned >= 3) {
                levelWon = true;
                resultType = 'final';
                startButton.textContent = 'Ajustes';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            } else if (improved && mazeStarsEarned >= MAZE_STAR_TARGETS.length) {
                levelWon = true;
                if (isLastLevel) {
                    resultType = 'final';
                    startButton.textContent = 'Ajustes';
                } else {
                    resultType = 'perfect';
                    startButton.textContent = 'Continuar';
                }
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            } else if (improved && mazeStarsEarned >= 3) {
                if (!isLastLevel) {
                    levelWon = true;
                    resultType = 'partial';
                    startButton.textContent = 'Continuar';
                    restartMazeButton.classList.remove('hidden');
                    startButtonWrapperEl.classList.add('split');
                } else {
                    startButton.textContent = 'Reintentar';
                    resultType = 'fail';
                    restartMazeButton.classList.add('hidden');
                    startButtonWrapperEl.classList.remove('split');
                }
            } else {
                startButton.textContent = 'Reintentar';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
            }

            if (levelWon && !isLastLevel && displayMazeLevel === currentMazeLevel) {
                currentMazeLevel++;
            }

            if (levelIndex >= 0 && levelIndex < MAZE_LEVEL_COUNT && mazeStarsEarned > mazePreviousStars) {
                mazeLevelStars[levelIndex] = mazeStarsEarned;
            }

            saveGameSettings();

            const allStarsAchieved = mazeLevelStars.every(s => s >= MAZE_STAR_TARGETS.length);
            if (levelWon && allStarsAchieved) {
                resultType = 'allstars';
            }

        screenState.mazeResultType = resultType;
        return levelWon;
        }

        function getNextIncompleteMazeLevel(currentLevel) {
            let next = currentLevel + 1;
            while (next <= currentMazeLevel && mazeLevelStars[next - 1] >= MAZE_STAR_TARGETS.length) {
                next++;
            }
            if (next <= currentMazeLevel) {
                return next;
            }
            return currentMazeLevel;
        }


        function playSoundForGameOver(levelWon) {
            if (areSfxEnabled) {
                if (levelWon) {
                    playSound('win');
                } else {
                    playSound('gameOver');
                }
            }
        }
        
        function managePostGameOverMusicAndAnimation() {
            if (blinkAnimation.active && gameOver) { 
                requestAnimationFrame(gameEndAnimationLoop);
            } else {
                const isSettingsCurrentlyOpen = settingsPanel && !settingsPanel.classList.contains("settings-panel-hidden");
                const isInfoCurrentlyOpen = infoPanel && !infoPanel.classList.contains("info-panel-hidden");
                if (isMusicEnabled && generalBackgroundMusic && !isSettingsCurrentlyOpen && !isInfoCurrentlyOpen) {
                    if (generalBackgroundMusic.paused) {
                        generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (managePostGameOverMusic):", e));
                        console.log("Música general iniciada (managePostGameOverMusic - no blink).");
                    }
                }
            }
        }
        
        function gameEndAnimationLoop() { // This is the loop for the blinking animation
            if (gameOver && blinkAnimation.active) { 
                draw(); 
                const elapsedTime = Date.now() - blinkAnimation.startTime;
                if (elapsedTime >= blinkAnimation.duration) {
                    blinkAnimation.active = false; 
                    draw(); 
                    managePostGameOverMusicAndAnimation(); // Check for music again once blink is done
                } else {
                    requestAnimationFrame(gameEndAnimationLoop); 
                }
            }
        }

        function updateUIOnGameOver() {
            updateMainButtonStates();

            gameModeSelector.disabled = false;
            skinSelector.disabled = false;
            foodSelector.disabled = false;
            gameModeControlGroup.classList.add("interactive-mode");
            skinControlGroup.classList.add("interactive-mode");
            foodControlGroup.classList.add("interactive-mode");

            if (gameMode === 'levels') {
                worldsSelector.disabled = false; 
            } else { 
                difficultySelector.disabled = false;
            }
            difficultyControlGroup.classList.add("interactive-mode"); 
            
            if (typeof Tone !== 'undefined') { 
                 audioToggleSelector.disabled = false;
                 audioControlGroup.classList.add("interactive-mode");
                 musicVolumeSlider.disabled = (audioToggleSelector.value === 'off' || audioToggleSelector.value === 'sfx_only');
                 if (!musicVolumeSlider.disabled) musicVolumeControlGroup.classList.add("interactive-mode");
                 else musicVolumeControlGroup.classList.remove("interactive-mode");
            } else {
                 audioToggleSelector.disabled = true;
                 audioControlGroup.classList.remove("interactive-mode");
                 musicVolumeSlider.disabled = true;
                 musicVolumeControlGroup.classList.remove("interactive-mode");
            }
            
            updateScoreDisplay(); 
            updateTimeLengthDisplay();
            updateGameModeUI(); 
        }
        // --- Fin de Funciones de Refactorización ---

        function finalizeGameOver() {
            if (gameOver && startButton.disabled === false && configButton.disabled === false && infoButton.disabled === false && gameIntervalId === null) return;

            gameOver = true;
            screenState.gameActuallyStarted = false; // Game is no longer "actually started"

            // Crucial for Free Mode: Ensure cover is not shown when game ends, so classification appears
            if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = false; // Ensure no cover is shown
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
            } else if (gameMode === 'classification') {
                screenState.showClassificationCover = false;
                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
            }


            clearGameTimersAndMusic();

            // Ensure any active speed boost or mirror effect ends when the game does
            if (speedBoost.active) {
                speedBoost = { active: false, color: '', change: 0, startTime: 0 };
            }
            controlsInverted = false;
            mirrorEffect = { active: false, startTime: 0 };

            let levelEffectivelyWon = false; 
            isNewHighScore = false; 

            if (gameMode === 'freeMode') {
                const freeModeResult = handleFreeModeEnd(score, snake.length, difficulty);
                isNewHighScore = freeModeResult.isNewRecord;
                levelEffectivelyWon = freeModeResult.isEffectivelyWon;
                if (isNewHighScore) {
                    blinkAnimation.rowIndex = freeModeResult.rowIndex;
                }
            } else if (gameMode === 'classification') {
                const classificationResult = handleClassificationModeEnd(score, Math.floor(gameTimeElapsed / 1000), difficulty);
                isNewHighScore = classificationResult.isNewRecord;
                levelEffectivelyWon = classificationResult.isEffectivelyWon;
                if (isNewHighScore) {
                    blinkAnimation.rowIndex = classificationResult.rowIndex;
                }
            } else if (gameMode === 'levels') {
                levelEffectivelyWon = handleLevelsModeEnd(score, gameTimeRemaining);
            } else if (gameMode === 'maze') {
                levelEffectivelyWon = handleMazeModeEnd(score, gameTimeRemaining);
            }

            if (!levelEffectivelyWon && gameOverByTimeout && (gameMode === 'levels' || gameMode === 'maze')) {
                screenState.showTimeoutCover = true;
                screenState.showDefeatCoverForWorld = 0;
                if (gameMode === 'maze') {
                    screenState.mazeResultType = '';
                }
            }
            gameOverByTimeout = false;

            playSoundForGameOver(levelEffectivelyWon);
            draw(); 
            managePostGameOverMusicAndAnimation();

            const earnedCoins = Math.floor(score / POINTS_PER_COIN);
            const previousCoins = totalCoins;
            totalCoins += earnedCoins;
            animateCoinGain(previousCoins, totalCoins);
            localStorage.setItem('snakeGameCoins', totalCoins.toString());

            updateUIOnGameOver();

            if (gameMode === 'levels' || gameMode === 'maze') {
                saveGameSettings(); // Guardamos el estado actualizado (nivel/mundo avanzado)
            }
        }
        
        function drawWorldCoverImage(worldNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = worldCoverImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Mundo ${worldNumber}`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }
        
        function drawWorldCompleteScreen(worldNumber) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = worldCompleteImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                 ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                // Fallback text if image fails to load
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 10)}px 'Press Start 2P'`;
                if (worldNumber === TOTAL_WORLDS) {
                    ctx.fillText("¡JUEGO COMPLETADO!", canvasEl.width / 2, canvasEl.height / 2);
                } else {
                    ctx.fillText(`¡MUNDO ${worldNumber} SUPERADO!`, canvasEl.width / 2, canvasEl.height / 2);
                }
                 if (!img.complete) {
                    console.warn(`Imagen de mundo completado para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de mundo completado para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawLevelCompleteImage(worldNumber) { 
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151"; 
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = levelCompleteImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`¡Nivel Superado!`, canvasEl.width / 2, canvasEl.height / 2 - 20);
                ctx.font = `${Math.floor(canvasEl.width / 25)}px 'Press Start 2P'`;
                ctx.fillText(`(Mundo ${worldNumber})`, canvasEl.width / 2, canvasEl.height / 2 + 20);

                if (!img.complete) {
                    console.warn(`Imagen de nivel completado para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de nivel completado para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawDefeatScreen(worldNumber) { // New function for defeat screen
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = defeatImages[worldNumber];
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`¡Has Perdido!`, canvasEl.width / 2, canvasEl.height / 2 - 20);
                ctx.font = `${Math.floor(canvasEl.width / 25)}px 'Press Start 2P'`;
                ctx.fillText(`(Mundo ${worldNumber})`, canvasEl.width / 2, canvasEl.height / 2 + 20);

                if (!img.complete) {
                    console.warn(`Imagen de derrota para Mundo ${worldNumber} aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de derrota para Mundo ${worldNumber} parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawTimeoutScreen() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = timeoutImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText('¡Tiempo agotado!', canvasEl.width / 2, canvasEl.height / 2);
            }
        }
        function drawFreeModeCover() { // New function for free mode cover
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = freeModeCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Modo Libre`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de Modo Libre aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de Modo Libre parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawClassificationCover() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = classificationModeCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Modo Clasificación`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de Modo Clasificación aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de Modo Clasificación parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawMazeCover() {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            const img = mazeModeCoverImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                ctx.fillText(`Modo Laberinto`, canvasEl.width / 2, canvasEl.height / 2);
                if (!img.complete) {
                    console.warn(`Imagen de portada de Modo Laberinto aún no cargada.`);
                } else if (img.naturalHeight === 0) {
                    console.warn(`Imagen de portada de Modo Laberinto parece estar corrupta o no es una imagen válida.`);
                }
            }
        }

        function drawMazeResultScreen(resultType) {
            if (!ctx || !canvasEl) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
            let img;
            if (resultType === 'fail') img = mazeFailImg;
            else if (resultType === 'partial') img = mazePartialImg;
            else if (resultType === 'perfect') img = mazePerfectImg;
            else if (resultType === 'complete') img = mazeCompleteImg;
            else if (resultType === 'final') img = mazeFinalImg;
            else if (resultType === 'allstars') img = mazeAllStarsImg;
            if (img && img.complete && img.naturalHeight !== 0) {
                ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
            } else {
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                const textMap = {
                    fail: 'Reintentar',
                    partial: 'Continuar',
                    perfect: 'Perfecto',
                    complete: '¡Completado!',
                    final: '¡Completado!',
                    allstars: '¡Completado!'
                };
                ctx.fillText(textMap[resultType] || '', canvasEl.width / 2, canvasEl.height / 2);
            }
        }

        function getModeImage(mode) {
            if (mode === 'intro') return modeSelectIntroImg;
            if (mode === 'levels') return modeSelectLevelsImg;
            if (mode === 'freeMode') return modeSelectFreeImg;
            if (mode === 'classification') return modeSelectClassificationImg;
            return modeSelectMazeImg;
        }

        function drawModeSelection() {
            modeLeftButton.classList.remove('hidden');
            modeRightButton.classList.remove('hidden');

            const now = performance.now();
            let progress = 1;
            if (modeTransitionStart !== null) {
                progress = Math.min((now - modeTransitionStart) / MODE_TRANSITION_DURATION, 1);
            }

            const fromImg = getModeImage(MODE_SELECT_ORDER[modeTransitionStart !== null ? modeTransitionFrom : modeSelectIndex]);
            const toImg = getModeImage(MODE_SELECT_ORDER[modeSelectIndex]);

            if (modeTransitionStart !== null && progress < 1) {
                const offset = canvasEl.width * progress;
                const dir = modeTransitionDir;
                if (fromImg && fromImg.complete && fromImg.naturalHeight !== 0) {
                    ctx.drawImage(fromImg, -dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, canvasEl.width * dir - dir * offset, 0, canvasEl.width, canvasEl.height);
                }
                requestAnimationFrame(draw);
            } else {
                modeTransitionStart = null;
                if (toImg && toImg.complete && toImg.naturalHeight !== 0) {
                    ctx.drawImage(toImg, 0, 0, canvasEl.width, canvasEl.height);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.font = `${Math.floor(canvasEl.width / 15)}px 'Press Start 2P'`;
                    ctx.fillText('Selecciona modo', canvasEl.width / 2, canvasEl.height / 2);
                }
            }
        }


        function draw() {
             if (!ctx) return;
            ctx.fillStyle = "#374151";
            ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

            if (showModeSelect) {
                drawModeSelection();
                updateMainButtonStates();
                return;
            } else {
                modeLeftButton.classList.add('hidden');
                modeRightButton.classList.add('hidden');
            }

            let speedBoostVisible = false;
            let speedBoostOverlayColor = '';
            if (speedBoost.active) {
                const remaining = SPEED_BOOST_DURATION - (Date.now() - speedBoost.startTime);
                if (remaining > 0) {
                    speedBoostOverlayColor = speedBoost.color === 'yellow' ? 'rgba(255,255,0,0.3)' : 'rgba(255,0,0,0.3)';
                    speedBoostVisible = remaining > 1000 || Math.floor(remaining / 100) % 2 === 0;
                }
            }
            let mirrorVisible = false;
            let mirrorOverlayColor = 'rgba(0,0,255,0.3)';
            if (mirrorEffect.active) {
                let effectDuration = MIRROR_EFFECT_DURATION;
                if (gameMode === 'classification') {
                    const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                    if (typeof cfg.mirrorEffectDuration === 'number') {
                        effectDuration = cfg.mirrorEffectDuration;
                    }
                }
                const remaining = effectDuration - (Date.now() - mirrorEffect.startTime);
                if (remaining > 0) {
                    mirrorVisible = remaining > 1000 || Math.floor(remaining / 100) % 2 === 0;
                } else {
                    mirrorEffect.active = false;
                }
            }

            if (screenState.showFreeModeCover && !screenState.gameActuallyStarted) {
                drawFreeModeCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.showClassificationCover && !screenState.gameActuallyStarted) {
                drawClassificationCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.showMazeCover && !screenState.gameActuallyStarted) {
                drawMazeCover();
                updateMainButtonStates();
                return;
            }
            if (screenState.mazeResultType && gameMode === 'maze' && !screenState.gameActuallyStarted) {
                drawMazeResultScreen(screenState.mazeResultType);
                updateMainButtonStates();
                return;
            }
            if (screenState.showTimeoutCover && !screenState.gameActuallyStarted) {
                drawTimeoutScreen();
                updateMainButtonStates();
                return;
            }
            if (screenState.showDefeatCoverForWorld > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                drawDefeatScreen(screenState.showDefeatCoverForWorld);
                updateMainButtonStates();
                return;
            }
            if (screenState.showWorldCompleteCover > 0 && gameMode === 'levels') { 
                drawWorldCompleteScreen(screenState.showWorldCompleteCover);
                updateMainButtonStates(); 
                return;
            }
            if (screenState.showLevelCompleteCover > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) { 
                drawLevelCompleteImage(screenState.showLevelCompleteCover); 
                updateMainButtonStates(); 
                return;
            }
            if (screenState.showCoverForWorld > 0 && gameMode === 'levels' && !screenState.gameActuallyStarted) {
                drawWorldCoverImage(screenState.showCoverForWorld);
                updateMainButtonStates(); 
                return; 
            }


            if (tileCountX <= 0 || tileCountY <= 0) return; 

            const currentSkinData = SKINS[currentSkin]; 

            if (!gameOver) {
                if (obstacles.length > 0) {
                    obstacles.forEach(ob => drawObstacle(ob));
                }
                // Draw snake body
                for (let i = 1; i < snake.length; i++) {
                    const segmentX = snake[i].x * GRID_SIZE;
                    const segmentY = snake[i].y * GRID_SIZE;
                    const skinData = SKINS[currentSkin]; 

                    if (snakeBodyTexture && snakeBodyTexture.complete && snakeBodyTexture.naturalHeight !== 0) {
                        ctx.drawImage(snakeBodyTexture, segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                        if (skinData.bodyTintColor) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = skinData.bodyTintColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (speedBoostVisible) {
                            drawImageWithTint(ctx, snakeBodyTexture, segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1, speedBoostOverlayColor);
                        }
                        if (mirrorVisible) {
                            drawImageWithTint(ctx, snakeBodyTexture, segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1, mirrorOverlayColor);
                        }
                    } else {
                        ctx.fillStyle = skinData.bodyTintColor || '#A8F031';
                        ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                        if (speedBoostVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = speedBoostOverlayColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (mirrorVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = mirrorOverlayColor;
                            ctx.fillRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                    if (skinData.bodyStrokeColor) {
                        ctx.strokeStyle = skinData.bodyStrokeColor;
                        ctx.lineWidth = 1; 
                        ctx.strokeRect(segmentX, segmentY, GRID_SIZE - 1, GRID_SIZE - 1);
                    }
                }

                // Draw food
                if (currentFoodItem.x !== undefined) {
                    drawFoodItem(currentFoodItem.x, currentFoodItem.y);
                }
                if (falseFoodItems.length > 0) {
                    falseFoodItems.forEach(item => drawFalseFoodItem(item));
                }
                if (lightningItems.length > 0) {
                    lightningItems.forEach(item => drawLightningItem(item));
                }
                if (mirrorItems.length > 0) {
                    mirrorItems.forEach(item => drawMirrorItem(item));
                }

                // Draw snake head
                if (snake.length > 0) {
                    const head = snake[0];
                    if (currentSkinData && currentSkinData.snakeHeadAsset) {
                        let imgToDraw;
                        let baseImageForUp = currentSkinData.snakeHeadAsset.upDown;
                        let baseImageForDown = currentSkinData.snakeHeadAsset.upDown;
                        let baseImageForLeft = currentSkinData.snakeHeadAsset.left;
                        let baseImageForRight = currentSkinData.snakeHeadAsset.left; 
                        let flipHorizontal = false;
                        let flipVertical = false;

                        if (direction === 'up') { imgToDraw = baseImageForUp; flipVertical = true; }
                        else if (direction === 'down') { imgToDraw = baseImageForDown; }
                        else if (direction === 'left') { imgToDraw = baseImageForLeft; }
                        else if (direction === 'right') { imgToDraw = baseImageForRight; flipHorizontal = true; }

                        if (imgToDraw && imgToDraw.complete && imgToDraw.naturalHeight !== 0) {
                            const drawSize = GRID_SIZE * currentSkinData.snakeHeadScale;
                            const offset = (drawSize - GRID_SIZE) / 2;
                            const drawX = head.x * GRID_SIZE - offset;
                            const drawY = head.y * GRID_SIZE - offset;
                            ctx.save();
                            ctx.translate(drawX + drawSize / 2, drawY + drawSize / 2);
                            let scaleX = 1; let scaleY = 1;
                            if (flipHorizontal) scaleX = -1; if (flipVertical) scaleY = -1;
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                            if (speedBoostVisible) {
                                drawImageWithTint(ctx, imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize, speedBoostOverlayColor);
                            }
                            if (mirrorVisible) {
                                drawImageWithTint(ctx, imgToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize, mirrorOverlayColor);
                            }
                            ctx.restore();
                        } else {
                            ctx.fillStyle = "#a7f3d0";
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                            if (speedBoostVisible) {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = speedBoostOverlayColor;
                                ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                                ctx.globalCompositeOperation = 'source-over';
                            }
                            if (mirrorVisible) {
                                ctx.globalCompositeOperation = 'multiply';
                                ctx.fillStyle = mirrorOverlayColor;
                                ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                                ctx.globalCompositeOperation = 'source-over';
                            }
                        }
                    } else {
                        ctx.fillStyle = "#a7f3d0";
                        ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                        ctx.strokeStyle = "#065f46";
                        ctx.strokeRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                        if (speedBoostVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = speedBoostOverlayColor;
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                        if (mirrorVisible) {
                            ctx.globalCompositeOperation = 'multiply';
                            ctx.fillStyle = mirrorOverlayColor;
                            ctx.fillRect(head.x * GRID_SIZE, head.y * GRID_SIZE, GRID_SIZE -1, GRID_SIZE -1);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                    drawStreakAnimation(head);
                }
            } else { // Game Over Screen (but not world/level complete or defeat screen)
                if (!screenState.showWorldCompleteCover && !screenState.showLevelCompleteCover && !screenState.showDefeatCoverForWorld && !screenState.showFreeModeCover) { 
                    ctx.fillStyle = "rgba(0, 0, 0, 0.65)"; 
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                    
                    const baseFontSize = Math.min(16, Math.floor(canvasEl.width / 20)); 
                    const highScoreTitleFontSize = Math.max(9, baseFontSize * 0.9);
                    const highScoreEntryFontSize = Math.max(7, baseFontSize * 0.7);
                    const tableHeaderFontSize = Math.max(7, baseFontSize * 0.7);
                    
                    let endMessageFontSize = baseFontSize;
                    let mainTitle = "";
                    let subTitle = "";
                    let titleColor = "rgba(220, 38, 38, 1)"; 

                    if (gameMode === 'levels') {
                        mainTitle = `Nivel ${displayWorld}.${displayLevelInWorld} Fallido`; // Use display variables
                        subTitle = "Inténtalo de nuevo";
                    } else if (gameMode === 'freeMode' || gameMode === 'classification') {
                        mainTitle = isNewHighScore ? "¡Nuevo Récord!" : "Game Over";
                         if (isNewHighScore) titleColor = "rgba(76, 175, 80, 1)";
                    }


                    const targetWidthForEndMessage = canvasEl.width * 0.9;
                    let optimalSizeForEndMessage = Math.floor(canvasEl.height / 5); 
                    if (optimalSizeForEndMessage < 15) optimalSizeForEndMessage = 15;
                    ctx.font = `${optimalSizeForEndMessage}px 'Press Start 2P'`;
                    while(ctx.measureText(mainTitle).width > targetWidthForEndMessage && optimalSizeForEndMessage > 10) {
                        optimalSizeForEndMessage--;
                        ctx.font = `${optimalSizeForEndMessage}px 'Press Start 2P'`;
                    }
                    endMessageFontSize = optimalSizeForEndMessage;

                    let currentY = canvasEl.height * 0.08;

                    ctx.fillStyle = titleColor;
                    ctx.font = `${endMessageFontSize}px 'Press Start 2P'`;
                    ctx.textAlign = "center";
                    ctx.shadowColor = "rgba(0,0,0,0.8)";
                    ctx.shadowBlur = 10;

                    const mainTitleMetrics = ctx.measureText(mainTitle);
                    const mainTitleHeight = mainTitleMetrics.actualBoundingBoxAscent + mainTitleMetrics.actualBoundingBoxDescent;
                    const mainTitleBaseline = currentY + mainTitleMetrics.actualBoundingBoxAscent - mainTitleHeight / 2;

                    ctx.textBaseline = "alphabetic";
                    ctx.fillText(mainTitle, canvasEl.width / 2, mainTitleBaseline);

                    ctx.shadowBlur = 0;
                    currentY = mainTitleBaseline + mainTitleMetrics.actualBoundingBoxDescent + endMessageFontSize * 0.7;

                    if (subTitle) {
                        const subTitleFontSize = Math.max(10, Math.floor(endMessageFontSize * 0.7));
                        ctx.font = `${subTitleFontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = titleColor;

                        const subTitleMetrics = ctx.measureText(subTitle);
                        const subTitleHeight = subTitleMetrics.actualBoundingBoxAscent + subTitleMetrics.actualBoundingBoxDescent;
                        const subTitleBaseline = currentY + subTitleMetrics.actualBoundingBoxAscent - subTitleHeight / 2;

                        ctx.textBaseline = "alphabetic";
                        ctx.fillText(subTitle, canvasEl.width / 2, subTitleBaseline);

                        currentY = subTitleBaseline + subTitleMetrics.actualBoundingBoxDescent + subTitleFontSize * 0.7;
                    }

                    currentY += 10;

                    if (gameMode === 'freeMode' || gameMode === 'classification') {
                        const tableOuterTopPadding = 30; 
                        const tableBottomPadding = 10; 
                        const tableSidePadding = canvasEl.width * 0.05;
                        const tableRectX = tableSidePadding;
                        const tableRectWidth = canvasEl.width - (2 * tableSidePadding);
                        const tableCornerRadius = 10; 
                        const tableBorderWidth = 2;
                        const tableBorderColor = "#4B5563";
                        const internalLineWidth = tableBorderWidth; 

                        const classificationTitleText = `Clasificación`;
                        let classificationTitleY = currentY; 
                        
                        const titleRowBgColor = "#1F2937"; 
                        const headerRowBgColor = "#1F2937"; 
                        const titleRowPaddingY = 5;

                        const titleRowHeight = highScoreTitleFontSize + 2 * titleRowPaddingY;
                        const headerRowHeight = tableHeaderFontSize + 10; 
                        
                        const tableContentStartY = classificationTitleY - highScoreTitleFontSize * 0.5 - titleRowPaddingY; 
                        const tableBgEndY = canvasEl.height - tableBottomPadding;
                        const tableBgHeight = tableBgEndY - tableContentStartY;

                        const availableHeightForScores = tableBgHeight - titleRowHeight - headerRowHeight - (tableBorderWidth * 2);
                        let dynamicScoreRowHeight = highScoreEntryFontSize + 10; 
                        if (MAX_HIGH_SCORES > 0 && availableHeightForScores > 0) {
                            dynamicScoreRowHeight = Math.max(highScoreEntryFontSize + 4, availableHeightForScores / MAX_HIGH_SCORES);
                        }

                        if (tableBgHeight > 0) {
                            ctx.fillStyle = "#374151"; 
                            ctx.strokeStyle = tableBorderColor;
                            ctx.lineWidth = tableBorderWidth;
                            ctx.beginPath();
                            ctx.roundRect(tableRectX, tableContentStartY, tableRectWidth, tableBgHeight, tableCornerRadius);
                            ctx.fill();
                            ctx.stroke();
                        }
                        
                        const titleRowActualY = tableContentStartY;
                        ctx.fillStyle = titleRowBgColor;
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(tableRectX + tableBorderWidth / 2, titleRowActualY + tableBorderWidth / 2, tableRectWidth - tableBorderWidth, titleRowHeight);
                        ctx.clip(); 
                        ctx.beginPath();
                        ctx.roundRect(tableRectX, titleRowActualY, tableRectWidth, titleRowHeight + tableCornerRadius, [tableCornerRadius, tableCornerRadius, 0, 0]); 
                        ctx.fill();
                        ctx.restore();
                        
                        ctx.font = `${highScoreTitleFontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = "#6ee7b7";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(classificationTitleText, canvasEl.width / 2, titleRowActualY + titleRowHeight / 2);

                        let currentDrawingYForTable = titleRowActualY + titleRowHeight;
                        
                        const headerRowActualY = currentDrawingYForTable;
                        ctx.fillStyle = headerRowBgColor;
                        ctx.fillRect(tableRectX + tableBorderWidth/2, headerRowActualY, tableRectWidth - tableBorderWidth, headerRowHeight);

                        const headerTextY = headerRowActualY + headerRowHeight / 2;
                        // AJUSTE DE POSICIONES X PARA LA TABLA DE PUNTUACIONES
                        const rankX = tableRectX + tableRectWidth * 0.08;    // Para "Nº"
                        const scoreX = tableRectX + tableRectWidth * 0.27;   // Para "PUNTOS"
                        const lengthX = tableRectX + tableRectWidth * 0.50;  // Para valor secundario
                        const skinX = tableRectX + tableRectWidth * 0.79;   // Para "JUGADOR" (más espacio)

                        const headerFont = `${tableHeaderFontSize}px 'Press Start 2P'`;
                        const headerColor = "#F5F5F5";
                        ctx.font = headerFont;
                        ctx.fillStyle = headerColor;
                        ctx.textAlign = "center"; // Asegurar alineación central
                        ctx.textBaseline = "middle"; // Asegurar alineación vertical

                        ctx.fillText("Nº", rankX, headerTextY);
                        ctx.fillText("PUNTOS", scoreX, headerTextY);
                        const secondaryHeader = gameMode === 'classification' ? 'TIEM.' : 'LONG.';
                        ctx.fillText(secondaryHeader, lengthX, headerTextY);
                        ctx.fillText("JUGADOR", skinX, headerTextY); // Usar el texto "JUGADOR"
                        currentDrawingYForTable = headerRowActualY + headerRowHeight;

                        const highScores = gameMode === 'freeMode' ? loadHighScores(difficulty) : loadClassificationHighScores(difficulty);
                        const entryFont = `${highScoreEntryFontSize}px 'Press Start 2P'`;
                        const defaultEntryColor = "#F5F5F5";
                        const highlightEntryColor = "#6ee7b7"; 
                        const blinkOffColor = "#5A6578"; 
                        
                        let newHighScoreEntryProcessedForVisuals = false; 

                        for (let i = 0; i < MAX_HIGH_SCORES; i++) { 
                            const scoreRowActualY = currentDrawingYForTable;
                            if (scoreRowActualY + dynamicScoreRowHeight > tableBgEndY - tableBorderWidth/2) break; 

                            const rowTextY = scoreRowActualY + dynamicScoreRowHeight / 2; 
                            
                            if (i > 0 || headerRowActualY + headerRowHeight < scoreRowActualY) {
                                ctx.strokeStyle = tableBorderColor; 
                                ctx.lineWidth = internalLineWidth; 
                                ctx.beginPath();
                                ctx.moveTo(tableRectX + tableBorderWidth / 2, scoreRowActualY); 
                                ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, scoreRowActualY);
                                ctx.stroke();
                            }
                            
                            if (highScores[i]) {
                                const entry = highScores[i];
                                let currentEntryColor = defaultEntryColor;
                                
                                let isThisTheNewRecordFromThisGame = isNewHighScore &&
                                                                entry.score === score &&
                                                                ((gameMode === 'classification' && entry.time === Math.floor(gameTimeElapsed / 1000)) ||
                                                                 (gameMode !== 'classification' && entry.length === snake.length)) &&
                                                                i === blinkAnimation.rowIndex &&
                                                                !newHighScoreEntryProcessedForVisuals;


                                if (blinkAnimation.active && isThisTheNewRecordFromThisGame) {
                                    const visible = Math.floor((Date.now() - blinkAnimation.startTime) / blinkAnimation.interval) % 2 === 0;
                                    currentEntryColor = visible ? highlightEntryColor : blinkOffColor;
                                } else if (isThisTheNewRecordFromThisGame && !blinkAnimation.active) { 
                                    currentEntryColor = highlightEntryColor;
                                } else if (isNewHighScore && i === blinkAnimation.rowIndex && !blinkAnimation.active) { 
                                    currentEntryColor = highlightEntryColor;
                                }
                                
                                ctx.fillStyle = currentEntryColor;
                                ctx.font = entryFont;
                                // textAlign y textBaseline ya están en "center" y "middle"
                                ctx.fillText(`${i + 1}.`, rankX, rowTextY);
                                ctx.fillText(`${entry.score}`, scoreX, rowTextY);
                                const secondaryValue = gameMode === 'classification' ? formatTime(entry.time) : entry.length;
                                ctx.fillText(`${secondaryValue}`, lengthX, rowTextY);
                                // USAR SKIN_DISPLAY_NAMES para mostrar el nombre del jugador
                                const skinDisplayName = SKIN_DISPLAY_NAMES[entry.skin] || entry.skin || '-';
                                ctx.fillText(skinDisplayName, skinX, rowTextY);
                            } else {
                                ctx.fillStyle = defaultEntryColor;
                                ctx.font = entryFont;
                                ctx.fillText(`${i + 1}.`, rankX, rowTextY);
                                ctx.fillText("---", scoreX, rowTextY);
                                ctx.fillText("---", lengthX, rowTextY);
                                ctx.fillText("---", skinX, rowTextY); // Placeholder para skin
                            }
                            currentDrawingYForTable += dynamicScoreRowHeight; 
                        }
                        ctx.strokeStyle = tableBorderColor;
                        ctx.lineWidth = internalLineWidth; 
                        ctx.beginPath();
                        ctx.moveTo(tableRectX + tableBorderWidth / 2, titleRowActualY + titleRowHeight);
                        ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, titleRowActualY + titleRowHeight);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(tableRectX + tableBorderWidth / 2, headerRowActualY + headerRowHeight);
                        ctx.lineTo(tableRectX + tableRectWidth - tableBorderWidth / 2, headerRowActualY + headerRowHeight);
                        ctx.stroke();
                    }
                    ctx.textBaseline = "alphabetic"; 
                }
            }
        }
        
       function update() {
            if (gameOver || tileCountX <= 0 || tileCountY <= 0) return;
            updateSpeedBoost();
            updateMirrorEffect();

            direction = nextDirection; // Actualizar la dirección actual con la siguiente dirección almacenada

            let nextHeadX = snake[0].x;
            let nextHeadY = snake[0].y;
            switch (direction) {
                case "up":    nextHeadY--; break;
                case "down":  nextHeadY++; break;
                case "left":  nextHeadX--; break;
                case "right": nextHeadX++; break;
            }

            if (nextHeadX < 0) nextHeadX = tileCountX - 1;
            else if (nextHeadX >= tileCountX) nextHeadX = 0;
            if (nextHeadY < 0) nextHeadY = tileCountY - 1;
            else if (nextHeadY >= tileCountY) nextHeadY = 0;

            if (!gameOver) {
                for (let i = 1; i < snake.length; i++) {
                    if (nextHeadX === snake[i].x && nextHeadY === snake[i].y) {
                        gameOver = true;
                        break;
                    }
                }
            }
            
            const nextHead = { x: nextHeadX, y: nextHeadY };
            let growth = 0; 
            if (currentFoodItem.x !== undefined && nextHead.x === currentFoodItem.x && nextHead.y === currentFoodItem.y) {
                let gained = POINTS_PER_FOOD;
                const rank = CLASSIFICATION_RANKS[difficulty] || 0;
                if ((gameMode === 'levels' && currentWorld >= 6) || (gameMode === 'classification' && rank >= 2)) {
                    gained *= streakMultiplier;
                    if (streakMultiplier < MAX_STREAK) { streakMultiplier += 0.5; }
                    if (streakMultiplier > MAX_STREAK) { streakMultiplier = MAX_STREAK; }
                    startStreakAnimation(streakMultiplier);
                }
                if (currentFoodItem.isGolden) gained *= 2;
                score += gained;
                if(areSfxEnabled) playSound('eat');

                growth = 1;
                clearTimeout(foodDisappearTimeoutId);
                clearInterval(foodVisualTimerIntervalId);
                foodTimeRemaining = 0;
                generateFood();

                if (gameMode === 'levels') {
                    const absoluteLevelIndex = (currentWorld - 1) * LEVELS_PER_WORLD + (currentLevelInWorld - 1);
                    if (score >= TARGET_SCORES_LEVELS[absoluteLevelIndex]) {
                        gameOver = true; // Level won by score
                    }
                } else if (gameMode === 'maze') {
                    while (mazeStarsEarned < MAZE_STAR_TARGETS.length && score >= MAZE_STAR_TARGETS[mazeStarsEarned]) {
                        mazeStarsEarned++;
                        if (mazeStarsEarned === MAZE_STAR_TARGETS.length) {
                            gameOver = true;
                            break;
                        } else {
                            displayTargetScore = MAZE_STAR_TARGETS[mazeStarsEarned];
                        }
                    }
                    drawStarProgress();
                    updateTargetScoreDisplay();
                }
            }

            if (gameOver) {
                finalizeGameOver();
                return;
            }
            for (let i = falseFoodItems.length - 1; i >= 0; i--) {
                const ff = falseFoodItems[i];
                if (nextHead.x === ff.x && nextHead.y === ff.y) {
                    score = Math.max(0, score - 30);
                    streakMultiplier = 1;
                    const rank = CLASSIFICATION_RANKS[difficulty] || 0;
                    if ((gameMode === 'levels' && currentWorld >= 6) || (gameMode === 'classification' && rank >= 2)) startStreakAnimation(streakMultiplier);
                    removeFalseFoodItem(ff);
                    if (areSfxEnabled) playSound('badEat');
                }
            }
            for (let i = lightningItems.length - 1; i >= 0; i--) {
                const lt = lightningItems[i];
                if (nextHead.x === lt.x && nextHead.y === lt.y) {
                    activateSpeedBoost(lt.color);
                    removeLightningItem(lt);
                    if (areSfxEnabled) playSound('eat');
                }
            }
            for (let i = mirrorItems.length - 1; i >= 0; i--) {
                const mi = mirrorItems[i];
                if (nextHead.x === mi.x && nextHead.y === mi.y) {
                    controlsInverted = true;
                    mirrorEffect = { active: true, startTime: Date.now() };
                    removeMirrorItem(mi);
                    if (areSfxEnabled) playSound('eat');
                }
            }
            for (const ob of obstacles) {
                if (nextHead.x === ob.x && nextHead.y === ob.y) {
                    gameOver = true;
                    break;
                }
            }
            if (gameOver) {
                finalizeGameOver();
                return;
            }

            snake.unshift(nextHead);
            if (growth === 0) { snake.pop(); }

            updateScoreDisplay(); 
            if (gameMode === 'freeMode' || gameMode === 'levels') { 
                updateTimeLengthDisplay(); 
            }
            draw();
        }
        
        function updateScoreDisplay() {
            scoreValueDisplay.textContent = score;
        }

        function updateCoinDisplay() {
            coinValueDisplay.textContent = totalCoins;
        }

        function animateCoinGain(oldTotal, newTotal) {
            const diff = newTotal - oldTotal;
            if (diff <= 0) {
                coinValueDisplay.textContent = newTotal;
                return;
            }
            const duration = Math.min(2000, diff * 60);
            const start = performance.now();
            if (areSfxEnabled) playSound('coinAdd', duration / 1000);
            function step(now) {
                const progress = Math.min(1, (now - start) / duration);
                const value = Math.floor(oldTotal + diff * progress);
                coinValueDisplay.textContent = value;
                if (progress < 1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function updateTargetScoreDisplay() {
            if (targetScoreValueDisplay && targetScoreDivider) {
                 if (gameMode === 'levels' || gameMode === 'maze') { 
                    // Use displayTargetScore which is updated at the start of a game or when settings change
                    targetScoreValueDisplay.textContent = displayTargetScore;
                    targetScoreValueDisplay.classList.remove('hidden');
                    targetScoreDivider.classList.remove('hidden');
                } else { 
                    targetScoreValueDisplay.classList.add('hidden');
                    targetScoreDivider.classList.add('hidden');
                }
            }
        }
        
        function updateTimeLengthDisplay() {
            if (!gameMode) {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            } else if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = Math.max(0, Math.ceil(gameTimeRemaining / 1000));
            } else if (gameMode === 'classification') {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
            } else { // freeMode
                timeLengthLabelEl.textContent = "Longitud:";
                timeLengthValueEl.textContent = snake.length > 0 ? snake.length : initialSnakeLength;
            }
        }

        function displayHighScoreInPanel() {
            const selectedDifficulty = difficultySelector.value; // Esto es para el modo libre
            const highScores = loadHighScores(selectedDifficulty);
            const hsSkinValueDisplay = document.getElementById("hs-skin-value");

            if (highScores.length > 0) {
                hsScoreValue.textContent = highScores[0].score;
                hsLengthValue.textContent = highScores[0].length;
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = SKIN_DISPLAY_NAMES[highScores[0].skin] || highScores[0].skin || '-';
                }
            } else {
                hsScoreValue.textContent = "-";
                hsLengthValue.textContent = "-";
                if (hsSkinValueDisplay) { 
                    hsSkinValueDisplay.textContent = "-"; 
                }
            }
        }
        
        function updateGameModeUI() {
            gameMode = gameModeSelector.value;
            
            const isGameCurrentlyRunning = !!gameIntervalId;
            const isSettingsPanelCurrentlyOpen = !settingsPanel.classList.contains("settings-panel-hidden");

            if (!gameMode) {
                titlePanel.classList.remove('hidden');
                progressPanel.classList.add('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = "No disponible";

                difficultyLabel.textContent = "Nivel:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                mazeLevelSelector.classList.add('hidden');

                if (isSettingsPanelCurrentlyOpen) {
                    difficultySelector.disabled = true;
                    worldsSelector.disabled = true;
                    mazeLevelSelector.disabled = true;
                    difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'levels') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                
                difficultyLabel.textContent = "Mundo Actual:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.remove('hidden');
                mazeLevelSelector.classList.add('hidden');
                populateWorldsSelector();
                drawStarProgress(); 

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    worldsSelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    worldsSelector.disabled = true;
                     if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode"); 
                     else difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'freeMode') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.add('hidden'); // Ocultar estrellas
                highScoreDisplay.classList.remove('hidden'); // Mostrar panel de high score
                
                // Ya no se usa progressPanelLeftLabel/Value para el high score.
                // El label "Máxima puntuación" está dentro de #high-score-display.
                // Y progressPanelLeftLabel/Value se ocultan o se dejan como están si se quiere mostrar la dificultad actual del juego.
                // Por ahora, mantendremos la lógica de que #current-world-info-group muestre la dificultad actual del juego.
                progressPanelLeftLabel.textContent = "Dificultad:"; 
                progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;
                
                displayHighScoreInPanel(); 
                if (hsSecondaryUnit) hsSecondaryUnit.textContent = "Long";

                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                mazeLevelSelector.classList.add('hidden');
                
                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'classification') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.add('hidden');
                highScoreDisplay.classList.remove('hidden');

                progressPanelLeftLabel.textContent = "Dificultad:";
                progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;

                displayClassificationHighScoreInPanel();
                if (hsSecondaryUnit) hsSecondaryUnit.textContent = "Seg";

                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                mazeLevelSelector.classList.add('hidden');

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else if (gameMode === 'maze') {
                titlePanel.classList.add('hidden');
                progressPanel.classList.remove('hidden');
                starProgressContainer.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');
                progressPanelLeftLabel.textContent = "Nivel:";
                progressPanelLeftValue.textContent = displayMazeLevel;
                drawStarProgress();

                difficultyLabel.textContent = "Nivel Actual:";
                difficultySelector.classList.add('hidden');
                worldsSelector.classList.add('hidden');
                mazeLevelSelector.classList.remove('hidden');
                populateMazeLevelSelector();

                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    mazeLevelSelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    mazeLevelSelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            } else {
                titlePanel.classList.add('hidden');
                progressPanel.classList.add('hidden');
                difficultyLabel.textContent = "Dificultad:";
                difficultySelector.classList.remove('hidden');
                worldsSelector.classList.add('hidden');
                mazeLevelSelector.classList.add('hidden');
                if (isSettingsPanelCurrentlyOpen && !isGameCurrentlyRunning) {
                    difficultySelector.disabled = false;
                    difficultyControlGroup.classList.add("interactive-mode");
                } else {
                    difficultySelector.disabled = true;
                    if (!isGameCurrentlyRunning) difficultyControlGroup.classList.add("interactive-mode");
                    else difficultyControlGroup.classList.remove("interactive-mode");
                }
            }

            updateTargetScoreDisplay();

            if (!gameMode) {
                timeLengthLabelEl.textContent = "Tiempo:";
                timeLengthValueEl.textContent = 0;
            } else if (gameMode === 'levels' || gameMode === 'maze') {
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                     timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
                } else if (!gameOver) {
                     timeLengthValueEl.textContent = Math.max(0, Math.ceil(gameTimeRemaining / 1000));
                } else {
                     timeLengthValueEl.textContent = Math.ceil(LEVEL_TIME_LIMIT / 1000);
                }
            } else if (gameMode === 'classification') {
                timeLengthLabelEl.textContent = "Tiempo:";
                if (!screenState.gameActuallyStarted && !gameOver) {
                    timeLengthValueEl.textContent = formatTime(0);
                } else {
                    timeLengthValueEl.textContent = formatTime(Math.floor(gameTimeElapsed / 1000));
                }
            } else { // freeMode
                timeLengthLabelEl.textContent = "Longitud:";
                timeLengthValueEl.textContent = snake.length > 0 ? snake.length : initialSnakeLength;
            }
        }

        function populateWorldsSelector() {
            worldsSelector.innerHTML = '';
            for (let i = 1; i <= TOTAL_WORLDS; i++) {
                const option = document.createElement('option');
                option.value = i;
                const name = WORLD_DISPLAY_NAMES[i - 1] || '';
                option.textContent = name ? `${i}.${name}` : `${i}`;
                option.disabled = i > maxUnlockedWorld;
                if (i === currentWorld) {
                    option.selected = true;
                }
                worldsSelector.appendChild(option);
            }
        }

        function populateMazeLevelSelector() {
            mazeLevelSelector.innerHTML = '';
            for (let i = 1; i <= MAZE_LEVEL_COUNT; i++) {
                const option = document.createElement('option');
                option.value = i;
                const starsEarned = mazeLevelStars[i - 1] || 0;
                const starSymbols = '⭐'.repeat(starsEarned) + '☆'.repeat(MAZE_STAR_TARGETS.length - starsEarned);
                option.textContent = `Nivel ${i} ${starSymbols}`;
                option.disabled = i > currentMazeLevel;
                if (i === displayMazeLevel) {
                    option.selected = true;
                }
                mazeLevelSelector.appendChild(option);
            }
        }

        function drawStarProgress() {
            starProgressContainer.innerHTML = '';
            if (gameMode === 'levels') {
                const worldToDisplayStarsFor = gameOver ? displayWorld : currentWorld;
                const worldLevelStartIndex = (worldToDisplayStarsFor - 1) * LEVELS_PER_WORLD;
                for (let i = 0; i < LEVELS_PER_WORLD; i++) {
                    const levelIndexInTotal = worldLevelStartIndex + i;
                    const isCompleted = levelsProgress[levelIndexInTotal];
                    const starSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    starSvg.setAttribute("class", "star-svg");
                    starSvg.setAttribute("viewBox", "0 0 24 24");
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z");
                    starSvg.appendChild(path);
                    starSvg.setAttribute("fill", isCompleted ? "#FACC15" : "#6B7280");
                    starProgressContainer.appendChild(starSvg);
                }
            } else if (gameMode === 'maze') {
                for (let i = 0; i < MAZE_STAR_TARGETS.length; i++) {
                    const isEarned = i < mazeStarsEarned;
                    const starSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    starSvg.setAttribute("class", "star-svg");
                    starSvg.setAttribute("viewBox", "0 0 24 24");
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z");
                    starSvg.appendChild(path);
                    starSvg.setAttribute("fill", isEarned ? "#FACC15" : "#6B7280");
                    starProgressContainer.appendChild(starSvg);
                }
            }
        }
        
        async function ensureAudioContextRunning() {
            if (typeof Tone === 'undefined') return false;
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start(); 
                    console.log("Tone.js context (re)started/resumed by ensureAudioContextRunning.");
                    if (Tone.context.state === 'running' && !synthsInitialized) { 
                        initializeToneSynths();
                    }
                    return Tone.context.state === 'running';
                } catch (e) {
                    console.error("Error trying to start/resume Tone.js context in ensureAudioContextRunning:", e);
                    return false;
                }
            } else if (!synthsInitialized) { 
                 initializeToneSynths();
            }
            return true; 
        }
        
        function initializeToneSynths() {
            if (typeof Tone === 'undefined' || Tone.context.state !== 'running') {
                console.warn("Tone.js context not running. Synth initialization deferred or skipped.");
                synthsInitialized = false; 
                return;
            }
            if (synthsInitialized) return; 

            console.log("Initializing Tone.js Synths...");
            synthEat = new Tone.MonoSynth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.04, sustain: 0.01, release: 0.08 }, filterEnvelope: { attack: 0.002, decay: 0.01, sustain: 0, release: 0.02, baseFrequency: 1500, octaves: 1.5, exponent: 2 } }).toDestination();
            synthEat.volume.value = 0;
            synthEatNoise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 } }).toDestination();
            synthEatNoise.volume.value = -10;
            synthBadEat = new Tone.MonoSynth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.15 }, filterEnvelope: { attack: 0.002, decay: 0.02, sustain: 0, release: 0.05, baseFrequency: 500, octaves: 1.2, exponent: 2 } }).toDestination();
            synthBadEat.volume.value = 0;
            synthWarning = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
            synthWarning.volume.value = 0;
            synthTimeout = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
            synthTimeout.volume.value = 0; 
            synthGameOver = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.3 } }).toDestination();
            synthGameOver.volume.value = 0; 
            synthStartGame = new Tone.Synth({ oscillator: {type: 'triangle'}, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
            synthStartGame.volume.value = 0;
            synthWin = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 } }).toDestination();
            synthWin.volume.value = 0;
            synthCoinNoise = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination();
            synthCoinNoise.volume.value = -8;
            synthCoinChime = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            synthCoinChime.volume.value = -2;
            synthModeSwitch = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
            synthModeSwitch.volume.value = -2;
            synthModeSelect = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.05 } }).toDestination();
            synthModeSelect.volume.value = -2;
            // synthSplashStart is initialized in window.onload

            synthsInitialized = true;
            console.log("Tone.js Synths initialized.");
        }


async function startGame(isRestart = false) {
    isNewHighScore = false;
    blinkAnimation.active = false;
    blinkAnimation.rowIndex = -1;
    streakAnimation.active = false;
    gameOverByTimeout = false;

    // Reset any lingering speed boost or mirror effect from a previous game
    speedBoost = { active: false, color: '', change: 0, startTime: 0 };
    controlsInverted = false;

    mirrorEffect = { active: false, startTime: 0 };

    if (gameMode === 'maze') {
        if (isRestart && (screenState.mazeResultType === 'partial' || screenState.mazeResultType === 'perfect')) {
            displayMazeLevel = Math.max(1, currentMazeLevel - 1);
        } else if (screenState.mazeResultType === 'partial' || screenState.mazeResultType === 'perfect') {
            if (displayMazeLevel < currentMazeLevel) {
                displayMazeLevel = getNextIncompleteMazeLevel(displayMazeLevel);
            } else {
                displayMazeLevel = currentMazeLevel;
            }
        }
    }
            
            const wasOnWorldCompleteCoverForNewWorld = screenState.showWorldCompleteCover > 0 && startButton.textContent === "Nuevo Mundo";
        
            // Reset all visual state flags that are managed before game loop starts
            screenState.showCoverForWorld = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showWorldCompleteCover = 0;
            screenState.showFreeModeCover = false;
            screenState.showMazeCover = false;
            screenState.mazeResultType = '';
            restartMazeButton.classList.add('hidden');
            startButtonWrapperEl.classList.remove('split');
        
            if (startButton.textContent === "Ajustes") {
                openSettingsPanel();
                screenState.gameActuallyStarted = false; 
            } else {
                closeSettingsPanel(); 
                closeInfoPanel(); 
        
                if (gameMode === 'levels' && wasOnWorldCompleteCoverForNewWorld) {
                    // currentWorld and currentLevelInWorld are already set for the new world
                    screenState.showCoverForWorld = currentWorld; 
                    screenState.gameActuallyStarted = false; 

                    // Update display variables for the new world's cover screen
                    displayWorld = currentWorld;
                    displayLevelInWorld = 1; // New world starts at level 1
                    const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                    if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                        displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                    } else {
                        displayTargetScore = 0; // Should not happen if TOTAL_WORLDS is correct
                    }
                    score = 0; // Reset score when transitioning to new world cover
                    streakMultiplier = 1; // Reset streak
                    updateScoreDisplay(); // Update UI to show 0 score & x1 streak

                    // Update UI elements that depend on display variables
                    updateTargetScoreDisplay();
                    if (progressPanelLeftValue) {
                        progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                    }
                    drawStarProgress(); // Update stars for the new world being displayed

                } else {
                    screenState.gameActuallyStarted = true;
                }
            }
            
            if (!screenState.gameActuallyStarted) { 
                draw(); 
                updateMainButtonStates(); 
                return;
            }
            
            // If we reach here, screenState.gameActuallyStarted is true.
            // Update display variables to the actual level being started
            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);

            if (gameMode === 'levels') {
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else { // Should only happen if all levels/worlds are completed
                    displayTargetScore = TARGET_SCORES_LEVELS[TARGET_SCORES_LEVELS.length -1];
                    console.warn("Attempting to start a level beyond defined targets. Using last target score.");
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            } else { // freeMode
                displayTargetScore = 0; // No target score in free mode
            }

            updateTargetScoreDisplay(); // Update UI with the target of the level to be played
            if (progressPanelLeftValue && gameMode === 'levels') { // Update progress panel UI
                progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
            } else if (progressPanelLeftValue && gameMode === 'maze') {
                progressPanelLeftValue.textContent = displayMazeLevel;
            } else if (progressPanelLeftValue && (gameMode === 'freeMode' || gameMode === 'classification')) {
                // El panel de #high-score-display ahora se encarga de su propio label.
                // progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficultySelector.value] || difficultySelector.value;
            }
            drawStarProgress(); // Update stars for the current world being played


            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            if (audioContextStarted && areSfxEnabled) {
                 playSound('startGame');
            }

            let desiredMusic = inGameBackgroundMusicURL;
            if (gameMode === 'levels') {
                desiredMusic = WORLD_MUSIC_URLS[currentWorld] || inGameBackgroundMusicURL;
            } else if (gameMode === 'maze') {
                desiredMusic = MODE_MUSIC_URLS.maze;
            } else if (gameMode === 'freeMode') {
                desiredMusic = MODE_MUSIC_URLS.freeMode;
            } else if (gameMode === 'classification') {
                desiredMusic = MODE_MUSIC_URLS.classification;
            }
            let sourceChanged = false;
            if (inGameBackgroundMusic && inGameBackgroundMusic.src !== desiredMusic) {
                inGameBackgroundMusic.src = desiredMusic;
                sourceChanged = true;
            }

            if (generalBackgroundMusic) {
                generalBackgroundMusic.pause();
                console.log("Música general pausada (startGame).");
            }
            if (isMusicEnabled && inGameBackgroundMusic) {
                if (sourceChanged) {
                    inGameBackgroundMusic.currentTime = 0;
                }
                inGameBackgroundMusic.play().catch(e => console.error("Error al reproducir música de partida (startGame):", e));
                console.log("Música de partida iniciada (startGame).");
            } else if (inGameBackgroundMusic) {
                inGameBackgroundMusic.pause();
            }


            if (gameMode === 'levels') {
                const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                snakeSpeed = levelCfg.speed;
                initialSnakeLength = levelCfg.initialLength;
                MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
            } else if (gameMode === 'freeMode') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
            } else if (gameMode === 'classification') {
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
                MIRROR_EFFECT_DURATION = cfg.mirrorEffectDuration || DEFAULT_MIRROR_EFFECT_DURATION;
            } else { // maze
                snakeSpeed = DIFFICULTY_SETTINGS.principiante.speed;
                initialSnakeLength = DIFFICULTY_SETTINGS.principiante.initialLength;
                MIRROR_EFFECT_DURATION = DEFAULT_MIRROR_EFFECT_DURATION;
            }

            applySkin(skinSelector.value); 
            
            resizeGameElements(); 
            if (tileCountX <= 0 || tileCountY <= 0) { 
                console.error("Pantalla demasiado pequeña para jugar.");
                updateMainButtonStates();
                return;
            }

            snake = [];
            let startX = Math.floor(tileCountX / 2);
            let startY = Math.floor(tileCountY / 2);
            if (gameMode === 'maze' && displayMazeLevel === 3) {
                startX = 1;
                startY = 1;
            }
            snakeSpawnRow = startY;
            for (let i = 0; i < initialSnakeLength; i++) {
                if (startX - i >= 0) { snake.push({ x: startX - i, y: startY }); }
                else { snake.push({ x: 0, y: startY }); }
            }
             if (snake.length === 0 && initialSnakeLength > 0) {
                console.error("Error al iniciar la serpiente. Pantalla muy pequeña.");
                updateMainButtonStates();
                return;
            }

            score = 0;
            streakMultiplier = 1; 
            gameOver = false; 
            direction = "right"; 
            nextDirection = "right"; // Asegurar que nextDirection también se reinicia
            
            if (gameMode === 'levels' || gameMode === 'maze') {
                gameTimeRemaining = LEVEL_TIME_LIMIT;
                // Target score already updated via displayTargetScore
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = setInterval(() => {
                    if (gameOver) { clearInterval(gameTimerIntervalId); return; }
                    gameTimeRemaining -= 1000;
                    updateTimeLengthDisplay();
                    if (gameTimeRemaining <= 0) {
                        if (!gameOver) {
                            gameOver = true;
                            gameOverByTimeout = true;
                            finalizeGameOver();
                        }
                        clearInterval(gameTimerIntervalId);
                    }
                }, 1000);
            } else if (gameMode === 'classification') {
                gameTimeElapsed = 0;
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
                gameTimerIntervalId = setInterval(() => {
                    if (gameOver) { clearInterval(gameTimerIntervalId); return; }
                    gameTimeElapsed += 1000;
                    updateTimeLengthDisplay();
                }, 1000);
            } else { // freeMode
                gameTimeElapsed = 0;
                gameTimeRemaining = Infinity;
                updateTimeLengthDisplay();
                clearInterval(gameTimerIntervalId);
            }
            if (gameMode === "levels" && (currentWorld === 7 || currentWorld === 8 || currentWorld === 10)) {
                startWorld4FalseFoodMechanics();
            } else {
                stopWorld4FalseFoodMechanics();
            }
            if (gameMode === "levels" && currentWorld === 8) {
                startWorld5Obstacles();
            } else if (gameMode === "levels" && currentWorld === 3) {
                stopWorld6Obstacles();
                startWorld6LightningMechanics();
            } else if (gameMode === "levels" && currentWorld === 4) {
                stopWorld6Obstacles();
                startWorld6LightningMechanics();
            } else if (gameMode === "levels" && currentWorld === 9) {
                startWorld6Obstacles();
                startWorld6LightningMechanics();
                startWorld7MirrorMechanics();
            } else if (gameMode === "levels" && currentWorld === 10) {
                startWorld8Obstacles();
                startWorld6LightningMechanics();
                startWorld7MirrorMechanics();
            } else if (gameMode === 'classification') {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                stopWorld4FalseFoodMechanics();
                const rank = CLASSIFICATION_RANKS[difficultySelector.value] || 0;
                const cfg = DIFFICULTY_SETTINGS[difficultySelector.value] || {};
                if (rank >= 2) startWorld6LightningMechanics();
                if (rank >= 3) {
                    startWorld4FalseFoodMechanics();
                    const count = cfg.obstacleCount;
                    if (rank >= 4) {
                        startWorld8Obstacles(count);
                    } else {
                        startWorld6Obstacles(count);
                    }
                    startWorld7MirrorMechanics();
                }
            } else if (gameMode === 'maze') {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
                startMazeLevel();
            } else {
                stopWorld5Obstacles();
                stopWorld6Obstacles();
                stopWorld6LightningMechanics();
                stopWorld7MirrorMechanics();
                stopWorld8Obstacles();
            }
            
            generateFood(); 
            updateScoreDisplay();
            clearInterval(gameIntervalId); 
            gameIntervalId = setInterval(update, snakeSpeed); 

            updateMainButtonStates(); 
            
            gameModeSelector.disabled = true;
            difficultySelector.disabled = true;
            worldsSelector.disabled = true;
            audioToggleSelector.disabled = true;
            skinSelector.disabled = true;
            foodSelector.disabled = true;
            musicVolumeSlider.disabled = true;
            gameModeControlGroup.classList.remove("interactive-mode");
            difficultyControlGroup.classList.remove("interactive-mode");
            audioControlGroup.classList.remove("interactive-mode");
            skinControlGroup.classList.remove("interactive-mode");
            foodControlGroup.classList.remove("interactive-mode");
            musicVolumeControlGroup.classList.remove("interactive-mode");
            draw(); 
        }

        function changeDirection(newDirectionCmd) { // Renamed parameter for clarity
            if (gameOver) return;
            // Invert controls if mirror effect active
            if (controlsInverted) {
                switch (newDirectionCmd) {
                    case "up": newDirectionCmd = "down"; break;
                    case "down": newDirectionCmd = "up"; break;
                    case "left": newDirectionCmd = "right"; break;
                    case "right": newDirectionCmd = "left"; break;
                }
            }
            // Solo actualizar nextDirection, no direction directamente
            switch (newDirectionCmd) {
                case "up":    if (direction !== "down")  nextDirection = "up"; break;
                case "down":  if (direction !== "up")    nextDirection = "down"; break;
                case "left":  if (direction !== "right") nextDirection = "left"; break;
                case "right": if (direction !== "left")  nextDirection = "right"; break;
            }
        }

        async function playSound(type, param = null) {
            if (!areSfxEnabled) return; 
            
            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            if (!audioContextStarted) {
                console.warn(`Audio context not running, cannot play sound: ${type}`);
                return;
            }
            // initializeToneSynths() is called by ensureAudioContextRunning if needed

            if (!synthsInitialized) { // Check again if initialization failed even after ensureAudioContextRunning
                 console.warn(`Synths not initialized, cannot play sound: ${type}`);
                return;
            }

            const now = Tone.now();
            try {
                if (type === 'eat') {
                    if (synthEat) { const baseNote = "D5"; const targetNote = "A4"; const duration = 0.07; synthEat.triggerAttack(baseNote, now); synthEat.frequency.linearRampToValueAtTime(targetNote, now + duration * 0.7); synthEat.triggerRelease(now + duration); }
                    if (synthEatNoise) { synthEatNoise.triggerAttackRelease("64n", now + 0.005); }
                } else if (type === 'badEat' && synthBadEat) {
                    const duration = 0.1;
                    synthBadEat.triggerAttack("G4", now);
                    synthBadEat.frequency.linearRampToValueAtTime("C4", now + duration * 0.7);
                    synthBadEat.triggerRelease(now + duration);
                    if (synthEatNoise) { synthEatNoise.triggerAttackRelease("64n", now + 0.005); }
                } else if (type === 'warning' && synthWarning) { synthWarning.triggerAttackRelease("A4", "32n", now);
                } else if (type === 'timeout' && synthTimeout) { synthTimeout.triggerAttackRelease("F#3", "8n", now);
                } else if (type === 'gameOver' && synthGameOver) { synthGameOver.triggerAttackRelease("G3", "8n", now); synthGameOver.triggerAttackRelease("E3", "8n", now + 0.15); synthGameOver.triggerAttackRelease("C3", "4n", now + 0.3);
                } else if (type === 'startGame' && synthStartGame) { synthStartGame.triggerAttackRelease("C4", "16n", now); synthStartGame.triggerAttackRelease("E4", "16n", now + 0.1); synthStartGame.triggerAttackRelease("G4", "8n", now + 0.2); 
                } else if (type === 'win' && synthWin) {
                    const tempo = 0.12;
                    synthWin.triggerAttackRelease("G4", "16n", now);
                    synthWin.triggerAttackRelease("G4", "16n", now + tempo * 1);
                    synthWin.triggerAttackRelease("C5", "16n", now + tempo * 2);
                    synthWin.triggerAttackRelease("E5", "8n", now + tempo * 3);
                    synthWin.triggerAttackRelease("C5", "16n", now + tempo * 5);
                    synthWin.triggerAttackRelease("G5", "4n", now + tempo * 6);
                } else if (type === 'coinAdd' && synthCoinNoise && synthCoinChime) {
                    const duration = typeof param === 'number' ? param : 1;
                    synthCoinNoise.triggerAttackRelease(duration, now);
                    synthCoinChime.triggerAttackRelease("C6", "16n", now + Math.max(0, duration - 0.1));
                } else if (type === 'modeSwitch' && synthModeSwitch) {
                    synthModeSwitch.triggerAttackRelease('C5', '16n', now);
                } else if (type === 'modeSelect' && synthModeSelect) {
                    synthModeSelect.triggerAttackRelease('G4', '16n', now);
                    synthModeSelect.triggerAttackRelease('C5', '16n', now + 0.1);
                }
            } catch (error) { console.error("Error al reproducir sonido con Tone.js:", error); }
        }
        
        function updateMusicVolume() {
            const sliderValue = parseInt(musicVolumeSlider.value);
            if (musicVolumeValue) {
                musicVolumeValue.textContent = sliderValue;
            }
            // For HTML5 Audio, volume is 0.0 to 1.0
            const actualVolume = (sliderValue / 100) * MAX_ACTUAL_SLIDER_MAPPED_VOLUME; 
            if (generalBackgroundMusic) {
                generalBackgroundMusic.volume = actualVolume;
            }
            if (inGameBackgroundMusic) {
                inGameBackgroundMusic.volume = actualVolume;
            }
            saveGameSettings(); 
        }

        musicVolumeSlider.addEventListener('input', updateMusicVolume);

        audioToggleSelector.addEventListener('change', async function() { 
            const audioSetting = this.value;
            isMusicEnabled = (audioSetting === 'all');
            areSfxEnabled = (audioSetting === 'all' || audioSetting === 'sfx_only');

            musicVolumeSlider.disabled = !isMusicEnabled;
            if (isMusicEnabled && !gameIntervalId) { 
                musicVolumeControlGroup.classList.add("interactive-mode");
            } else {
                musicVolumeControlGroup.classList.remove("interactive-mode");
            }

            const audioContextStarted = await ensureAudioContextRunning(); // Ensures context is running and synths are initialized
            // initializeToneSynths() is called by ensureAudioContextRunning if needed
            
            if (!audioContextStarted && (isMusicEnabled || areSfxEnabled)) { // If context still not started
                console.warn("Audio context could not be unlocked by user interaction via toggle.");
            }


            if (isMusicEnabled) { // Using HTML5 Audio
                updateMusicVolume(); 
                if (gameIntervalId) { // Game is active
                    if (generalBackgroundMusic) generalBackgroundMusic.pause();
                    if (inGameBackgroundMusic && inGameBackgroundMusic.paused) {
                         inGameBackgroundMusic.play().catch(e => console.error("Error al reproducir música de juego (toggle ON):", e));
                    }
                } else { // Menu or game over
                    if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
                    if (generalBackgroundMusic && generalBackgroundMusic.paused) {
                         generalBackgroundMusic.play().catch(e => console.error("Error al reproducir música general (toggle ON):", e));
                    }
                }
            } else { 
                if (generalBackgroundMusic) generalBackgroundMusic.pause();
                if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
            }
            saveGameSettings(); 
        });


        skinSelector.addEventListener('change', function() {
            applySkin(this.value);
            saveGameSettings();
        });

        foodSelector.addEventListener('change', function() {
            applyFood(this.value);
            saveGameSettings();
        });

        difficultySelector.addEventListener('change', function() {
            difficulty = this.value;
            if (!gameIntervalId) {
                const cfg = DIFFICULTY_SETTINGS[difficulty];
                snakeSpeed = cfg.speed;
                initialSnakeLength = cfg.initialLength;
            }
            // updateTargetScoreDisplay(); // No target score in free mode based on difficulty
            if (gameMode === 'freeMode') { // Update high score display if difficulty changes in free mode
                displayHighScoreInPanel();
                if (hsSecondaryUnit) hsSecondaryUnit.textContent = "Long";
                if (hsSecondaryUnit) hsSecondaryUnit.textContent = 'Long';
                if (hsSecondaryUnit) hsSecondaryUnit.textContent = 'Long';
            } else if (gameMode === 'classification') {
                displayClassificationHighScoreInPanel();
                if (hsSecondaryUnit) hsSecondaryUnit.textContent = 'Seg';
                // También actualizamos la dificultad mostrada en pantalla
                if (progressPanelLeftValue) {
                    progressPanelLeftValue.textContent = DIFFICULTY_DISPLAY_NAMES[difficulty] || difficulty;
                }
            }
            saveGameSettings();
        });

        worldsSelector.addEventListener('change', function() {
            if (gameMode === 'levels') {
                const newSelectedWorld = parseInt(this.value);
                if (newSelectedWorld > maxUnlockedWorld) {
                    this.value = currentWorld.toString(); // Revert if trying to select a locked world
                    return;
                }

                currentWorld = newSelectedWorld;
                currentLevelInWorld = 1; 

                // Update display variables to reflect the new selection
                displayWorld = currentWorld;
                displayLevelInWorld = currentLevelInWorld;
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else {
                    displayTargetScore = 0; 
                }
                updateTargetScoreDisplay(); // Update UI for target score
                if (progressPanelLeftValue) { // Update UI for progress panel
                    progressPanelLeftValue.textContent = `${displayWorld}.${displayLevelInWorld}`;
                }
                drawStarProgress(); // Update stars for the newly selected world


                if (!gameIntervalId) {
                    const levelCfg = LEVEL_SETTINGS[currentWorld - 1][currentLevelInWorld - 1];
                    snakeSpeed = levelCfg.speed;
                    initialSnakeLength = levelCfg.initialLength;
                }
                
                screenState.showCoverForWorld = currentWorld;
                screenState.gameActuallyStarted = false; 
                screenState.showWorldCompleteCover = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;

                saveGameSettings(); 
                
                closeSettingsPanel(); 

                requestAnimationFrame(draw);
            }
        });

        mazeLevelSelector.addEventListener('change', function() {
            if (gameMode === 'maze') {
                const newLevel = parseInt(this.value);
                if (newLevel > currentMazeLevel) {
                    this.value = currentMazeLevel.toString();
                    return;
                }

                displayMazeLevel = newLevel;
                mazePreviousStars = mazeLevelStars[newLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
                updateTargetScoreDisplay();
                if (progressPanelLeftValue) {
                    progressPanelLeftValue.textContent = displayMazeLevel;
                }
                drawStarProgress();

                screenState.showMazeCover = true;
                screenState.gameActuallyStarted = false;
                screenState.mazeResultType = '';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');

                saveGameSettings();

                closeSettingsPanel();

                requestAnimationFrame(draw);
            }
        });
        
        gameModeSelector.addEventListener('change', () => {
            const previousMode = gameMode;
            gameMode = gameModeSelector.value; // Update gameMode first

            // If a mode is chosen via settings while the mode selection screen
            // is visible, hide that screen and sync indexes
            if (showModeSelect) {
                showModeSelect = false;
                introOptionAvailable = false;
                modeTransitionStart = null;
                modeSelectIndex = MODE_SELECT_ORDER.indexOf(gameMode);
            }

            if (previousMode === 'maze' && gameMode !== 'maze') {
                screenState.mazeResultType = '';
                restartMazeButton.classList.add('hidden');
                startButtonWrapperEl.classList.remove('split');
                // Ensure maze level display is synced when leaving maze mode
                displayMazeLevel = currentMazeLevel;
            }

            if (gameMode === 'levels') {
                // Set display variables to current game state for levels mode
                displayWorld = currentWorld;
                displayLevelInWorld = currentLevelInWorld;
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else {
                    displayTargetScore = TARGET_SCORES_LEVELS[0]; // Default or last
                }
                
                screenState.showCoverForWorld = currentWorld;
                screenState.gameActuallyStarted = false;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showWorldCompleteCover = 0;
                screenState.showFreeModeCover = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
            } else if (gameMode === 'freeMode') {
                displayTargetScore = 0; // No target score in free mode

                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showWorldCompleteCover = 0;
                screenState.showFreeModeCover = true; // Show free mode cover
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
                screenState.gameActuallyStarted = false;
                gameOver = false;
                snake = [];
                currentFoodItem = {};
                if (ctx) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            } else if (gameMode === 'classification') {
                displayTargetScore = 0;

                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showWorldCompleteCover = 0;
                screenState.showFreeModeCover = false;
                screenState.showClassificationCover = true;
                screenState.showMazeCover = false;
                screenState.gameActuallyStarted = false;
                gameOver = false;
                snake = [];
                currentFoodItem = {};
                if (ctx) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            } else { // maze mode
                // Sync displayed level with actual progress when entering maze mode
                displayMazeLevel = currentMazeLevel;
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }

                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showWorldCompleteCover = 0;
                screenState.showFreeModeCover = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = true;
                screenState.gameActuallyStarted = false;
                gameOver = false;
                snake = [];
                currentFoodItem = {};
                if (ctx) {
                    ctx.fillStyle = "#374151";
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                }
            }
            updateGameModeUI(); // This will now use the correct display variables
            updateMainButtonStates();
            requestAnimationFrame(draw);
            saveGameSettings();
        });

        function handleStartClick() {
            if (showModeSelect) {
                if (MODE_SELECT_ORDER[modeSelectIndex] === 'intro') return;
                introOptionAvailable = false; // remove intro option after selecting a mode
                if (areSfxEnabled) playSound('modeSelect');
                const selectedMode = MODE_SELECT_ORDER[modeSelectIndex];
                gameModeSelector.value = selectedMode;
                gameMode = selectedMode;
                showModeSelect = false;
                modeTransitionStart = null;

                screenState.showCoverForWorld = 0;
                screenState.showLevelCompleteCover = 0;
                screenState.showWorldCompleteCover = 0;
                screenState.showDefeatCoverForWorld = 0;
                screenState.showTimeoutCover = false;
                screenState.showFreeModeCover = false;
                screenState.showClassificationCover = false;
                screenState.showMazeCover = false;
                screenState.mazeResultType = '';
                screenState.gameActuallyStarted = false;

                if (selectedMode === 'levels') {
                    screenState.showCoverForWorld = currentWorld;
                } else if (selectedMode === 'freeMode') {
                    screenState.showFreeModeCover = true;
                } else if (selectedMode === 'classification') {
                    screenState.showClassificationCover = true;
                } else {
                    screenState.showMazeCover = true;
                }
                updateGameModeUI();
                draw();
                updateMainButtonStates();
            } else {
                startGame(false);
            }
        }

        function displayClassificationHighScoreInPanel() {
            const selectedDifficulty = difficultySelector.value;
            const highScores = loadClassificationHighScores(selectedDifficulty);
            const hsSkinValueDisplay = document.getElementById("hs-skin-value");

            if (highScores.length > 0) {
                hsScoreValue.textContent = highScores[0].score;
                hsLengthValue.textContent = formatTime(highScores[0].time);
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = SKIN_DISPLAY_NAMES[highScores[0].skin] || highScores[0].skin || '-';
                }
            } else {
                hsScoreValue.textContent = "-";
                hsLengthValue.textContent = "-";
                if (hsSkinValueDisplay) {
                    hsSkinValueDisplay.textContent = "-";
                }
            }
        }


        document.addEventListener("keydown", (e) => {
            const isSettingsOpen = !settingsPanel.classList.contains("settings-panel-hidden");
            const isInfoOpen = !infoPanel.classList.contains("info-panel-hidden");
            const isSpecificInfoOpen = specificInfoPanel && !specificInfoPanel.classList.contains("specific-info-panel-hidden");

            if (!isSettingsOpen && !isInfoOpen && !isSpecificInfoOpen) {
                if (gameOver && e.key !== "Enter" && gameIntervalId === null) return;
                let newDirectionCmd = null; // Use newDirectionCmd to align with function parameter
                const key = e.key.toLowerCase();
                switch (key) {
                    case "arrowup": case "w": newDirectionCmd = "up"; break;
                    case "arrowdown": case "s": newDirectionCmd = "down"; break;
                    case "arrowleft": case "a": newDirectionCmd = "left"; break;
                    case "arrowright": case "d": newDirectionCmd = "right"; break;
                    case "enter": if (gameOver || !gameIntervalId) { startGame(false); } break;
                }
                if (newDirectionCmd) { changeDirection(newDirectionCmd); } // Call with newDirectionCmd
                if (["arrowup", "arrowdown", "arrowleft", "arrowright", "w", "a", "s", "d"].includes(key)) { e.preventDefault(); }
            } else if (isSpecificInfoOpen) {
                 if (e.key === "Escape") { closeSpecificInfoPanel(); }
            } else if (isSettingsOpen) {
                 if (e.key === "Escape") { closeSettingsPanel(); }
            } else if (isInfoOpen) {
                 if (e.key === "Escape") { closeInfoPanel(); }
            }
        });

        // D-Pad Button Press Feedback
        [upButton, downButton, leftButton, rightButton].forEach(button => {
            button.addEventListener("mousedown", () => {
                if (gameIntervalId) button.classList.add("d-pad-button-pressed");
            });
            button.addEventListener("mouseup", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("mouseleave", () => button.classList.remove("d-pad-button-pressed")); 
            button.addEventListener("touchstart", (e) => {
                e.preventDefault(); 
                if (gameIntervalId) button.classList.add("d-pad-button-pressed");
                changeDirection(button.id.replace('-button', '')); 
            });
            button.addEventListener("touchend", () => button.classList.remove("d-pad-button-pressed"));
            button.addEventListener("touchcancel", () => button.classList.remove("d-pad-button-pressed"));
        });

        // Original click listeners for D-Pad 
        upButton.addEventListener("click", () => changeDirection("up"));
        downButton.addEventListener("click", () => changeDirection("down"));
        leftButton.addEventListener("click", () => changeDirection("left"));
        rightButton.addEventListener("click", () => changeDirection("right"));

        function startModeTransition(dir) {
            if (modeTransitionStart !== null) return;
            modeTransitionDir = dir;
            modeTransitionFrom = modeSelectIndex;

            do {
                modeSelectIndex = (modeSelectIndex + dir + MODE_SELECT_ORDER.length) % MODE_SELECT_ORDER.length;
                if (introOptionAvailable && MODE_SELECT_ORDER[modeSelectIndex] !== 'intro') {
                    introOptionAvailable = false; // once user moves away from intro, remove it
                }
            } while (!introOptionAvailable && MODE_SELECT_ORDER[modeSelectIndex] === 'intro');

            modeTransitionStart = performance.now();
            draw();
        }

        modeLeftButton.addEventListener("click", () => {
            startModeTransition(-1);
            if (areSfxEnabled) playSound('modeSwitch');
        });
        modeRightButton.addEventListener("click", () => {
            startModeTransition(1);
            if (areSfxEnabled) playSound('modeSwitch');
        });

        startButton.addEventListener("click", handleStartClick);
        restartMazeButton.addEventListener("click", () => startGame(true));
        
        window.addEventListener('resize', resizeGameElements); 
        
        function saveGameSettings() {
            localStorage.setItem('snakeGameDifficulty', difficultySelector.value);
            localStorage.setItem('snakeGameSkin', skinSelector.value);
            localStorage.setItem('snakeGameFood', foodSelector.value);
            localStorage.setItem('snakeGameAudioGeneral', audioToggleSelector.value);
            localStorage.setItem('snakeGameMusicVolume', musicVolumeSlider.value);
            localStorage.setItem('snakeGameMode', gameModeSelector.value);
            // Levels mode specific
            localStorage.setItem('snakeCurrentWorld', currentWorld.toString());
            localStorage.setItem('snakeCurrentLevelInWorld', currentLevelInWorld.toString());
            localStorage.setItem('snakeMaxUnlockedWorld', maxUnlockedWorld.toString());
            localStorage.setItem('snakeLevelsProgress', JSON.stringify(levelsProgress));
            localStorage.setItem('snakeCurrentMazeLevel', currentMazeLevel.toString());
            localStorage.setItem('snakeMazeLevelStars', JSON.stringify(mazeLevelStars));
            console.log("Configuraciones guardadas en localStorage.");
        }

        function loadGameSettings() {
            const savedDifficulty = localStorage.getItem('snakeGameDifficulty');
            if (savedDifficulty && DIFFICULTY_SETTINGS[savedDifficulty]) {
                difficultySelector.value = savedDifficulty;
            } else {
                difficultySelector.value = 'principiante';
            }

            const savedSkin = localStorage.getItem('snakeGameSkin');
            if (savedSkin) skinSelector.value = savedSkin;

            const savedFood = localStorage.getItem('snakeGameFood');
            if (savedFood) foodSelector.value = savedFood;
            
            const savedAudioGeneral = localStorage.getItem('snakeGameAudioGeneral');
            if (savedAudioGeneral) audioToggleSelector.value = savedAudioGeneral;

            const savedMusicVolume = parseInt(localStorage.getItem('snakeGameMusicVolume'), 10);
            if (Number.isFinite(savedMusicVolume) && savedMusicVolume >= 0 && savedMusicVolume <= 100) {
                musicVolumeSlider.value = savedMusicVolume;
            } else {
                musicVolumeSlider.value = 50;
            }
            if (musicVolumeValue) musicVolumeValue.textContent = musicVolumeSlider.value;

            const savedCoins = parseInt(localStorage.getItem('snakeGameCoins'), 10);
            totalCoins = Number.isFinite(savedCoins) && savedCoins >= 0 ? savedCoins : 0;
            
            // Always start with no mode selected, regardless of any previously
            // saved preference. Users must actively choose their mode each time
            // they open the game.
            gameModeSelector.value = '';
            gameMode = '';
            
            // Levels mode specific
            const savedCurrentWorld = parseInt(localStorage.getItem('snakeCurrentWorld'), 10);
            currentWorld = Number.isFinite(savedCurrentWorld) && savedCurrentWorld >= 1 ? savedCurrentWorld : 1;

            const savedCurrentLevelInWorld = parseInt(localStorage.getItem('snakeCurrentLevelInWorld'), 10);
            currentLevelInWorld = Number.isFinite(savedCurrentLevelInWorld) && savedCurrentLevelInWorld >= 1 ? savedCurrentLevelInWorld : 1;

            const savedMaxUnlockedWorld = parseInt(localStorage.getItem('snakeMaxUnlockedWorld'), 10);
            maxUnlockedWorld = Number.isFinite(savedMaxUnlockedWorld) && savedMaxUnlockedWorld >= 1 ? savedMaxUnlockedWorld : 1;

            const savedLevelsProgress = localStorage.getItem('snakeLevelsProgress');
            if (savedLevelsProgress) {
                try {
                    levelsProgress = JSON.parse(savedLevelsProgress);
                    if (!Array.isArray(levelsProgress) || levelsProgress.length !== TOTAL_WORLDS * LEVELS_PER_WORLD) {
                        console.warn("Invalid levels progress found in localStorage, resetting.");
                        levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
                    }
                } catch (e) {
                    console.error("Error parsing levels progress from localStorage, resetting.", e);
                    levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
                }
            } else {
                 levelsProgress = Array(TOTAL_WORLDS * LEVELS_PER_WORLD).fill(false);
            }

            const savedMazeLevel = parseInt(localStorage.getItem('snakeCurrentMazeLevel'), 10);
            currentMazeLevel = Number.isFinite(savedMazeLevel) && savedMazeLevel >= 1 ? savedMazeLevel : 1;
            displayMazeLevel = currentMazeLevel;
            mazeLevelSelector.value = currentMazeLevel.toString();

            const savedMazeLevelStars = localStorage.getItem('snakeMazeLevelStars');
            if (savedMazeLevelStars) {
                try {
                    mazeLevelStars = JSON.parse(savedMazeLevelStars);
                    if (!Array.isArray(mazeLevelStars) || mazeLevelStars.length !== MAZE_LEVEL_COUNT) {
                        console.warn("Invalid maze level stars in localStorage, resetting.");
                        mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
                    }
                } catch (e) {
                    console.error("Error parsing maze level stars from localStorage, resetting.", e);
                    mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
                }
            } else {
                mazeLevelStars = Array(MAZE_LEVEL_COUNT).fill(0);
            }

            // Initialize display variables after loading game state
            displayWorld = currentWorld;
            displayLevelInWorld = currentLevelInWorld;
            gameMode = gameModeSelector.value; // Ensure gameMode is set before calculating displayTargetScore
            modeSelectIndex = MODE_SELECT_ORDER.indexOf(gameMode);

            if (gameMode === 'levels') {
                const absoluteDisplayLevelIndex = (displayWorld - 1) * LEVELS_PER_WORLD + (displayLevelInWorld - 1);
                if (absoluteDisplayLevelIndex >= 0 && absoluteDisplayLevelIndex < TARGET_SCORES_LEVELS.length) {
                    displayTargetScore = TARGET_SCORES_LEVELS[absoluteDisplayLevelIndex];
                } else { // Default if out of bounds (e.g., after completing all levels)
                    displayTargetScore = TARGET_SCORES_LEVELS[TARGET_SCORES_LEVELS.length -1];
                }
            } else if (gameMode === 'maze') {
                mazePreviousStars = mazeLevelStars[displayMazeLevel - 1] || 0;
                mazeStarsEarned = mazePreviousStars;
                if (mazePreviousStars < MAZE_STAR_TARGETS.length) {
                    displayTargetScore = MAZE_STAR_TARGETS[mazePreviousStars];
                } else {
                    displayTargetScore = MAZE_STAR_TARGETS[MAZE_STAR_TARGETS.length - 1];
                }
            } else {
                displayTargetScore = 0; // No target score for free mode
            }


            difficulty = difficultySelector.value;
            const cfg = DIFFICULTY_SETTINGS[difficulty];
            snakeSpeed = cfg.speed;
            initialSnakeLength = cfg.initialLength;
            currentSkin = skinSelector.value;
            currentFood = foodSelector.value;
            
            isMusicEnabled = (audioToggleSelector.value === 'all');
            areSfxEnabled = (audioToggleSelector.value === 'all' || audioToggleSelector.value === 'sfx_only');
            
            if(musicVolumeValue) musicVolumeValue.textContent = musicVolumeSlider.value; 

            console.log("Configuraciones cargadas de localStorage y aplicadas a selectores.");
            updateGameModeUI(); // This will use the newly set display variables
            updateCoinDisplay();
        }


        async function initializeGameLogic() { 
            if (!canvasEl) { 
                console.error("Elemento Canvas no encontrado en initializeGameLogic.");
                return;
            }
            if (!ctx) { 
                 ctx = canvasEl.getContext("2d");
                 if (!ctx) {
                    console.error("Fallo al obtener el contexto 2D del canvas en initializeGameLogic.");
                    return; 
                 }
            }
            
            // HTML5 Audio objects are now created in window.onload
            // Volume is also applied there via updateMusicVolume()
            // Tone.js synths (except splash) are initialized via ensureAudioContextRunning -> initializeToneSynths

            if (typeof Audio !== 'undefined') {
                // Music playback logic based on current game state
                const isSettingsOpen = settingsPanel && !settingsPanel.classList.contains("settings-panel-hidden");
                const isInfoOpen = infoPanel && !infoPanel.classList.contains("info-panel-hidden");
                if (isMusicEnabled && !gameIntervalId && !gameOver && !isSettingsOpen && !isInfoOpen && !screenState.showCoverForWorld && !screenState.showWorldCompleteCover && !screenState.showLevelCompleteCover && !screenState.showDefeatCoverForWorld && !screenState.showFreeModeCover && !screenState.showClassificationCover && !screenState.showMazeCover && !screenState.mazeResultType) {
                    if (inGameBackgroundMusic && !inGameBackgroundMusic.paused) {
                        inGameBackgroundMusic.pause();
                    }
                    if (generalBackgroundMusic && generalBackgroundMusic.paused) {
                        generalBackgroundMusic.play().catch(e => console.warn("Reproducción automática de música general (initializeGameLogic) fallida:", e));
                    }
                } else if (!isMusicEnabled || screenState.showCoverForWorld || screenState.showWorldCompleteCover || screenState.showLevelCompleteCover || screenState.showDefeatCoverForWorld || screenState.showTimeoutCover || screenState.showFreeModeCover || screenState.showClassificationCover || screenState.showMazeCover || screenState.mazeResultType) { // Pause if music disabled or any cover shown
                    if (generalBackgroundMusic) generalBackgroundMusic.pause();
                    if (inGameBackgroundMusic) inGameBackgroundMusic.pause();
                }
            }


            requestAnimationFrame(() => {
                resizeGameElements(); 
                draw();                 
                updateMainButtonStates(); 
            });

            applySkin(currentSkin); // Apply skin based on loaded settings
            applyFood(currentFood);

            // Reset screen states for a fresh start after splash
            screenState.gameActuallyStarted = false; 
            screenState.showWorldCompleteCover = 0;
            screenState.showLevelCompleteCover = 0;
            screenState.showDefeatCoverForWorld = 0;
            screenState.showTimeoutCover = false;
            screenState.showFreeModeCover = false;
            screenState.showClassificationCover = false;

            // Set initial display state based on current gameMode
            // but ensure correct cover screen is shown
            if (gameMode === 'levels') {
                screenState.showCoverForWorld = currentWorld; // currentWorld from loaded settings
            } else if (gameMode === 'freeMode') {
                screenState.showFreeModeCover = true;
                // Ensure gameOver is false if free mode cover is shown before first game
                if (snake.length === 0) gameOver = false;
            } else if (gameMode === 'classification') {
                screenState.showClassificationCover = true;
                // Ensure gameOver is false if free mode cover is shown before first game
                if (snake.length === 0) gameOver = false;
            } else if (gameMode === 'maze') {
                screenState.showMazeCover = true;
            }
            updateGameModeUI(); // Refresh UI based on potentially new screenState

        }

        window.onload = () => {
            loadSkinImages();
            loadWorldImages();
            loadModeSelectionImages();
            loadGameSettings(); // Loads settings including audio preferences and volume

            // Initialize HTML5 Audio Players
            if (typeof Audio !== 'undefined') {
                if (!generalBackgroundMusic) {
                    generalBackgroundMusic = new Audio(generalBackgroundMusicURL);
                    generalBackgroundMusic.loop = true;
                    console.log("Reproductor de música general (HTML5 Audio) creado en window.onload.");
                }
                if (!inGameBackgroundMusic) {
                    inGameBackgroundMusic = new Audio(inGameBackgroundMusicURL);
                    inGameBackgroundMusic.loop = true;
                    console.log("Reproductor de música de partida (HTML5 Audio) creado en window.onload.");
                }
                // Apply loaded volume settings. updateMusicVolume is safe to call.
                // It reads from musicVolumeSlider.value which is set by loadGameSettings.
                updateMusicVolume(); 
            } else {
                console.warn("HTML5 Audio no soportado, música de fondo desactivada (chequeo en window.onload).");
                isMusicEnabled = false; // Ensure this is set if Audio is not supported
                areSfxEnabled = (audioToggleSelector.value === 'sfx_only'); // Keep SFX if it was sfx_only
                if (audioToggleSelector.value === 'all') {
                    audioToggleSelector.value = areSfxEnabled ? 'sfx_only' : 'off';
                }
                Array.from(audioToggleSelector.options).forEach(option => {
                   if (option.value === 'all') option.disabled = true;
                });
                musicVolumeSlider.disabled = true;
                if (musicVolumeControlGroup) musicVolumeControlGroup.classList.remove("interactive-mode");
            }

            const splashStartButtonEl = document.getElementById('splash-start-button');
            const splashTopImageEl = document.getElementById('splash-top-image');
            const splashBottomImageEl = document.getElementById('splash-bottom-image');

            // Initialize synthSplashStart (Tone.Player) here
            if (typeof Tone !== 'undefined') {
                synthSplashStart = new Tone.Player({
                    url: "https://raw.githubusercontent.com/GamificAitor/JuegosEducativos/f8cf11c2f8447c929e260b8ad8b417d1edc6048c/start-game-v2.mp3",
                    onload: () => { console.log("Sonido del botón de inicio del splash cargado (Tone.Player)."); },
                    onerror: (error) => { console.error("Error cargando sonido del botón de inicio del splash (Tone.Player):", error); }
                }).toDestination();
                synthSplashStart.volume.value = -3.1; // Adjust volume as needed for Tone.Player
                // We no longer call initializeToneSynths() directly here.
                // ensureAudioContextRunning (on first click) will handle it.
            }



            if (splashStartButtonEl) {
                splashStartButtonEl.addEventListener('mousedown', () => {
                    splashStartButtonEl.classList.add('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('mouseup', () => {
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('mouseleave', () => { 
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchstart', (e) => {
                    splashStartButtonEl.classList.add('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchend', () => {
                    splashStartButtonEl.classList.remove('splash-button-pressed');
                });
                splashStartButtonEl.addEventListener('touchcancel', () => { 
                     splashStartButtonEl.classList.remove('splash-button-pressed');
                });

                splashStartButtonEl.addEventListener('click', async () => {
                    console.log("Splash start button CLICK event triggered.");
                    try {
                        splashStartButtonEl.classList.remove('splash-button-pressed'); // Ensure visual state resets

                        const audioContextStarted = await ensureAudioContextRunning(); // This is key for Tone.js
                        if (audioContextStarted) {
                             if (areSfxEnabled && synthSplashStart && synthSplashStart.loaded) { // synthSplashStart is Tone.Player
                                synthSplashStart.start(); // Play the preloaded sound
                             } else if (areSfxEnabled) {
                                 console.warn("Splash sound not played: SFX disabled, synth not loaded, or synth undefined.");
                             }
                        } else {
                            console.warn("Tone.js context could not be started by splash button click.");
                        }

                        if (splashScreen) splashScreen.classList.add('hidden');
                        if (gameContainer) gameContainer.classList.remove('hidden');
                        modeSelectIndex = 0;
                        showModeSelect = true;
                        introOptionAvailable = true; // reset intro visibility on fresh start
                        modeTransitionStart = null;
                        screenState.showCoverForWorld = 0;
                        screenState.showLevelCompleteCover = 0;
                        screenState.showWorldCompleteCover = 0;
                        screenState.showDefeatCoverForWorld = 0;
                        screenState.showTimeoutCover = false;
                        screenState.showFreeModeCover = false;
                        screenState.showMazeCover = false;
                        screenState.mazeResultType = '';
                        initializeGameLogic(); // This will handle playing HTML5 audio if enabled
                        draw();
                        updateMainButtonStates();
                    } catch (error) {
                        console.error("Error within splash start button click handler:", error);
                    }
                });
            } else {
                console.error("Botón de inicio del splash no encontrado!");
                if (splashScreen) splashScreen.classList.add('hidden');
                if (gameContainer) gameContainer.classList.remove('hidden');
                initializeGameLogic();
            }
        };
    </script>
</body>
</html>
